<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>glibmm: Gio::File Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">glibmm
   &#160;<span id="projectnumber">2.48.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceGio.html">Gio</a></li><li class="navelem"><a class="el" href="classGio_1_1File.html">File</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classGio_1_1File-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Gio::File Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> and directory handling.  
 <a href="classGio_1_1File.html#details">More...</a></p>

<p><code>#include &lt;giomm/file.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Gio::File:</div>
<div class="dyncontent">
<div class="center"><img src="classGio_1_1File__inherit__graph.png" border="0" usemap="#Gio_1_1File_inherit__map" alt="Inheritance graph"/></div>
<map name="Gio_1_1File_inherit__map" id="Gio_1_1File_inherit__map">
<area shape="rect" id="node2" href="classGlib_1_1Interface.html" title="Glib::Interface" alt="" coords="13,155,124,181"/><area shape="rect" id="node3" href="classGlib_1_1ObjectBase.html" title="Glib::ObjectBase is a common base class for Objects and Interfaces. " alt="" coords="5,80,132,107"/><area shape="rect" id="node4" href="file:///C:/msys/1.0/local/share/doc/libsigc++-2.0/reference/html/structsigc_1_1trackable.html" title="sigc::trackable" alt="" coords="11,5,126,32"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac5ff32ee99845479d138eee49d92e59c"><td class="memItemLeft" align="right" valign="top">typedef <a class="elRef" href="file:///C:/msys/1.0/local/share/doc/libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt; void, goffset, goffset &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ac5ff32ee99845479d138eee49d92e59c">SlotFileProgress</a></td></tr>
<tr class="memdesc:ac5ff32ee99845479d138eee49d92e59c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A signal handler would be, for instance: void on_file_progress(goffset current_num_bytes, goffset total_num_bytes);.  <a href="#ac5ff32ee99845479d138eee49d92e59c">More...</a><br /></td></tr>
<tr class="separator:ac5ff32ee99845479d138eee49d92e59c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb470935903b3745b2c8bcca1f40536"><td class="memItemLeft" align="right" valign="top">typedef <a class="elRef" href="file:///C:/msys/1.0/local/share/doc/libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt; void, bool, guint64, guint64, guint64 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a6bb470935903b3745b2c8bcca1f40536">SlotFileMeasureProgress</a></td></tr>
<tr class="memdesc:a6bb470935903b3745b2c8bcca1f40536"><td class="mdescLeft">&#160;</td><td class="mdescRight">This slot type is used by <a class="el" href="classGio_1_1File.html#a27d273c8119ef09426405e35f75e533e" title="Recursively measures the disk usage of the file. ">measure_disk_usage()</a> to make periodic progress reports when measuring the amount of disk spaced used by a directory.  <a href="#a6bb470935903b3745b2c8bcca1f40536">More...</a><br /></td></tr>
<tr class="separator:a6bb470935903b3745b2c8bcca1f40536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add182d22071784fc345adc757b3d687b"><td class="memItemLeft" align="right" valign="top">typedef <a class="elRef" href="file:///C:/msys/1.0/local/share/doc/libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt; bool, const char*, goffset &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#add182d22071784fc345adc757b3d687b">SlotReadMore</a></td></tr>
<tr class="memdesc:add182d22071784fc345adc757b3d687b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A signal handler would be, for instance: bool on_read_more(const char* file_contents, goffset file_size);.  <a href="#add182d22071784fc345adc757b3d687b">More...</a><br /></td></tr>
<tr class="separator:add182d22071784fc345adc757b3d687b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_structsigc_1_1trackable"><td colspan="2" onclick="javascript:toggleInherit('pub_types_structsigc_1_1trackable')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1trackable.html">sigc::trackable</a></td></tr>
<tr class="memitem:a3338954d7565534bd945290b798e13ed inherit pub_types_structsigc_1_1trackable"><td class="memItemLeft" align="right" valign="top">typedef internal::func_destroy_notify&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="file:///C:/msys/1.0/local/share/doc/libsigc++-2.0/reference/html/structsigc_1_1trackable.html#a3338954d7565534bd945290b798e13ed">func_destroy_notify</a></td></tr>
<tr class="separator:a3338954d7565534bd945290b798e13ed inherit pub_types_structsigc_1_1trackable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a91341a5c27005398bef11c6b232f2ec8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a91341a5c27005398bef11c6b232f2ec8">File</a> (<a class="el" href="classGio_1_1File.html">File</a>&amp;&amp; src) noexcept</td></tr>
<tr class="separator:a91341a5c27005398bef11c6b232f2ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d8c21aa35f4703e0b46b04ae2f5b82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGio_1_1File.html">File</a>&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#af4d8c21aa35f4703e0b46b04ae2f5b82">operator=</a> (<a class="el" href="classGio_1_1File.html">File</a>&amp;&amp; src) noexcept</td></tr>
<tr class="separator:af4d8c21aa35f4703e0b46b04ae2f5b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cdc62e6bba80b07800d0a40ffc81e8a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a5cdc62e6bba80b07800d0a40ffc81e8a">~File</a> () noexceptoverride</td></tr>
<tr class="separator:a5cdc62e6bba80b07800d0a40ffc81e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96552cfbaf2e5fa3659a1568db8cca91"><td class="memItemLeft" align="right" valign="top">GFile*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a96552cfbaf2e5fa3659a1568db8cca91">gobj</a> ()</td></tr>
<tr class="memdesc:a96552cfbaf2e5fa3659a1568db8cca91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C GObject.  <a href="#a96552cfbaf2e5fa3659a1568db8cca91">More...</a><br /></td></tr>
<tr class="separator:a96552cfbaf2e5fa3659a1568db8cca91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5437bc648d8b73451e8bee0bc902cfc0"><td class="memItemLeft" align="right" valign="top">const GFile*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a5437bc648d8b73451e8bee0bc902cfc0">gobj</a> () const </td></tr>
<tr class="memdesc:a5437bc648d8b73451e8bee0bc902cfc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C GObject.  <a href="#a5437bc648d8b73451e8bee0bc902cfc0">More...</a><br /></td></tr>
<tr class="separator:a5437bc648d8b73451e8bee0bc902cfc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea238062cdc317ae982ffae5c226c9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a9ea238062cdc317ae982ffae5c226c9b">dup</a> () const </td></tr>
<tr class="memdesc:a9ea238062cdc317ae982ffae5c226c9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicates a <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> handle.  <a href="#a9ea238062cdc317ae982ffae5c226c9b">More...</a><br /></td></tr>
<tr class="separator:a9ea238062cdc317ae982ffae5c226c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0320bac72ecc9ced1f894f1af696856f"><td class="memItemLeft" align="right" valign="top">guint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a0320bac72ecc9ced1f894f1af696856f">hash</a> () const </td></tr>
<tr class="memdesc:a0320bac72ecc9ced1f894f1af696856f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a hash value for a <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a>.  <a href="#a0320bac72ecc9ced1f894f1af696856f">More...</a><br /></td></tr>
<tr class="separator:a0320bac72ecc9ced1f894f1af696856f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8877115c870ea8f58b03d1d3c01a83e4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a8877115c870ea8f58b03d1d3c01a83e4">equal</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; const <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; other) const </td></tr>
<tr class="memdesc:a8877115c870ea8f58b03d1d3c01a83e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks equality of two given Files.  <a href="#a8877115c870ea8f58b03d1d3c01a83e4">More...</a><br /></td></tr>
<tr class="separator:a8877115c870ea8f58b03d1d3c01a83e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac731bed45bb7fcfd411eb69c49d3b883"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ac731bed45bb7fcfd411eb69c49d3b883">get_basename</a> () const </td></tr>
<tr class="memdesc:ac731bed45bb7fcfd411eb69c49d3b883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the base name (the last component of the path) for a given <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a>.  <a href="#ac731bed45bb7fcfd411eb69c49d3b883">More...</a><br /></td></tr>
<tr class="separator:ac731bed45bb7fcfd411eb69c49d3b883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b3edc7946b681b6db2cdcdad08d2b00"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a7b3edc7946b681b6db2cdcdad08d2b00">get_path</a> () const </td></tr>
<tr class="memdesc:a7b3edc7946b681b6db2cdcdad08d2b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the local pathname for <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a>, if one exists.  <a href="#a7b3edc7946b681b6db2cdcdad08d2b00">More...</a><br /></td></tr>
<tr class="separator:a7b3edc7946b681b6db2cdcdad08d2b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d1313e4a4eb5de034b693ec1cc9fba0"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a2d1313e4a4eb5de034b693ec1cc9fba0">get_uri</a> () const </td></tr>
<tr class="memdesc:a2d1313e4a4eb5de034b693ec1cc9fba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the URI for the <em>file</em>.  <a href="#a2d1313e4a4eb5de034b693ec1cc9fba0">More...</a><br /></td></tr>
<tr class="separator:a2d1313e4a4eb5de034b693ec1cc9fba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea4a78163e3085a35cbaacde9a3a7628"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aea4a78163e3085a35cbaacde9a3a7628">get_parse_name</a> () const </td></tr>
<tr class="memdesc:aea4a78163e3085a35cbaacde9a3a7628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the parse name of the <em>file</em>.  <a href="#aea4a78163e3085a35cbaacde9a3a7628">More...</a><br /></td></tr>
<tr class="separator:aea4a78163e3085a35cbaacde9a3a7628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39bbd5013b2dd675911df322e12ff94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#af39bbd5013b2dd675911df322e12ff94">get_parent</a> () const </td></tr>
<tr class="memdesc:af39bbd5013b2dd675911df322e12ff94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the parent directory for the <em>file</em>.  <a href="#af39bbd5013b2dd675911df322e12ff94">More...</a><br /></td></tr>
<tr class="separator:af39bbd5013b2dd675911df322e12ff94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b0d16b849b2f92699ad57ee7c935d9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ae0b0d16b849b2f92699ad57ee7c935d9">has_parent</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; parent) const </td></tr>
<tr class="memdesc:ae0b0d16b849b2f92699ad57ee7c935d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <em>file</em> has a parent, and optionally, if it is <em>parent</em>.  <a href="#ae0b0d16b849b2f92699ad57ee7c935d9">More...</a><br /></td></tr>
<tr class="separator:ae0b0d16b849b2f92699ad57ee7c935d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1daee0498c403e83ac509e6157edd1c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aa1daee0498c403e83ac509e6157edd1c">has_parent</a> () const </td></tr>
<tr class="memdesc:aa1daee0498c403e83ac509e6157edd1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the file has any parent at all.  <a href="#aa1daee0498c403e83ac509e6157edd1c">More...</a><br /></td></tr>
<tr class="separator:aa1daee0498c403e83ac509e6157edd1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c533d6bbeaaadd1b5592cf1e5ef93c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a53c533d6bbeaaadd1b5592cf1e5ef93c">get_child</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; name) const </td></tr>
<tr class="memdesc:a53c533d6bbeaaadd1b5592cf1e5ef93c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a child of <em>file</em> with basename equal to <em>name</em>.  <a href="#a53c533d6bbeaaadd1b5592cf1e5ef93c">More...</a><br /></td></tr>
<tr class="separator:a53c533d6bbeaaadd1b5592cf1e5ef93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a479cfd632af30b29e125f904f809ed71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a479cfd632af30b29e125f904f809ed71">get_child_for_display_name</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; display_name) const </td></tr>
<tr class="memdesc:a479cfd632af30b29e125f904f809ed71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the child of <em>file</em> for a given <em>display_name</em> (i.e. a UTF-8 version of the name).  <a href="#a479cfd632af30b29e125f904f809ed71">More...</a><br /></td></tr>
<tr class="separator:a479cfd632af30b29e125f904f809ed71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c40ec88dfc4333f19e939d26a1e0332"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a4c40ec88dfc4333f19e939d26a1e0332">has_prefix</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; const <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; prefix) const </td></tr>
<tr class="memdesc:a4c40ec88dfc4333f19e939d26a1e0332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <em>file</em> has the prefix specified by <em>prefix</em>.  <a href="#a4c40ec88dfc4333f19e939d26a1e0332">More...</a><br /></td></tr>
<tr class="separator:a4c40ec88dfc4333f19e939d26a1e0332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464248111fa2bc5df89c620354eb99bb"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a464248111fa2bc5df89c620354eb99bb">get_relative_path</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; const <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; descendant) const </td></tr>
<tr class="memdesc:a464248111fa2bc5df89c620354eb99bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the path for <em>descendant</em> relative to <em>parent</em>.  <a href="#a464248111fa2bc5df89c620354eb99bb">More...</a><br /></td></tr>
<tr class="separator:a464248111fa2bc5df89c620354eb99bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5e286d421c7236df39881f8ce0a4e03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ac5e286d421c7236df39881f8ce0a4e03">resolve_relative_path</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; relative_path) const </td></tr>
<tr class="memdesc:ac5e286d421c7236df39881f8ce0a4e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolves a relative path for <em>file</em> to an absolute path.  <a href="#ac5e286d421c7236df39881f8ce0a4e03">More...</a><br /></td></tr>
<tr class="separator:ac5e286d421c7236df39881f8ce0a4e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3b910bc9f240d4ebd0efc70979f163"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aaa3b910bc9f240d4ebd0efc70979f163">is_native</a> () const </td></tr>
<tr class="memdesc:aaa3b910bc9f240d4ebd0efc70979f163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a file is native to the platform.  <a href="#aaa3b910bc9f240d4ebd0efc70979f163">More...</a><br /></td></tr>
<tr class="separator:aaa3b910bc9f240d4ebd0efc70979f163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d71529e5b51b9ff73914eaf90be0f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a90d71529e5b51b9ff73914eaf90be0f1">has_uri_scheme</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; uri_scheme) const </td></tr>
<tr class="memdesc:a90d71529e5b51b9ff73914eaf90be0f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks to see if a <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> has a given URI scheme.  <a href="#a90d71529e5b51b9ff73914eaf90be0f1">More...</a><br /></td></tr>
<tr class="separator:a90d71529e5b51b9ff73914eaf90be0f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeecec6962f955bd72ac5595be37db7a4"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aeecec6962f955bd72ac5595be37db7a4">get_uri_scheme</a> () const </td></tr>
<tr class="memdesc:aeecec6962f955bd72ac5595be37db7a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the URI scheme for a <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a>.  <a href="#aeecec6962f955bd72ac5595be37db7a4">More...</a><br /></td></tr>
<tr class="separator:aeecec6962f955bd72ac5595be37db7a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef959c7ad7096846f26eb8b282e3c68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInputStream.html">FileInputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a3ef959c7ad7096846f26eb8b282e3c68">read</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:a3ef959c7ad7096846f26eb8b282e3c68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a file for reading.  <a href="#a3ef959c7ad7096846f26eb8b282e3c68">More...</a><br /></td></tr>
<tr class="separator:a3ef959c7ad7096846f26eb8b282e3c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0395b3b0b8cec5dc1fd9953e52e5fbc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInputStream.html">FileInputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a0395b3b0b8cec5dc1fd9953e52e5fbc1">read</a> ()</td></tr>
<tr class="memdesc:a0395b3b0b8cec5dc1fd9953e52e5fbc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classGio_1_1File.html#a0395b3b0b8cec5dc1fd9953e52e5fbc1" title="A read() convenience overload. ">read()</a> convenience overload.  <a href="#a0395b3b0b8cec5dc1fd9953e52e5fbc1">More...</a><br /></td></tr>
<tr class="separator:a0395b3b0b8cec5dc1fd9953e52e5fbc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2826eed0b1e76c3771f6ad5f5b993991"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a2826eed0b1e76c3771f6ad5f5b993991">read_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:a2826eed0b1e76c3771f6ad5f5b993991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously opens the file for reading.  <a href="#a2826eed0b1e76c3771f6ad5f5b993991">More...</a><br /></td></tr>
<tr class="separator:a2826eed0b1e76c3771f6ad5f5b993991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab451a182a647408e697c9115e66f6194"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ab451a182a647408e697c9115e66f6194">read_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:ab451a182a647408e697c9115e66f6194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously opens the file for reading.  <a href="#ab451a182a647408e697c9115e66f6194">More...</a><br /></td></tr>
<tr class="separator:ab451a182a647408e697c9115e66f6194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e71d2cd04c5c9c17a51fe8f1dc87c78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInputStream.html">FileInputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a3e71d2cd04c5c9c17a51fe8f1dc87c78">read_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; res)</td></tr>
<tr class="memdesc:a3e71d2cd04c5c9c17a51fe8f1dc87c78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous file read operation started with g_file_read_async().  <a href="#a3e71d2cd04c5c9c17a51fe8f1dc87c78">More...</a><br /></td></tr>
<tr class="separator:a3e71d2cd04c5c9c17a51fe8f1dc87c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c93ee71eee738690cb551d11df9528"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a91c93ee71eee738690cb551d11df9528">append_to</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a>)</td></tr>
<tr class="memdesc:a91c93ee71eee738690cb551d11df9528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an output stream for appending data to the file.  <a href="#a91c93ee71eee738690cb551d11df9528">More...</a><br /></td></tr>
<tr class="separator:a91c93ee71eee738690cb551d11df9528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db337b93f3b9b9a6e163477391e6c89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a8db337b93f3b9b9a6e163477391e6c89">append_to</a> (<a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a>)</td></tr>
<tr class="memdesc:a8db337b93f3b9b9a6e163477391e6c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an output stream for appending data to the file.  <a href="#a8db337b93f3b9b9a6e163477391e6c89">More...</a><br /></td></tr>
<tr class="separator:a8db337b93f3b9b9a6e163477391e6c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86258e11b2884422819d051c3cfd07a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a86258e11b2884422819d051c3cfd07a2">create_file</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a>)</td></tr>
<tr class="memdesc:a86258e11b2884422819d051c3cfd07a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new file and returns an output stream for writing to it.  <a href="#a86258e11b2884422819d051c3cfd07a2">More...</a><br /></td></tr>
<tr class="separator:a86258e11b2884422819d051c3cfd07a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf2b17b953ccfefb1d13c39bd1be72c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a5cf2b17b953ccfefb1d13c39bd1be72c">create_file</a> (<a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a>)</td></tr>
<tr class="memdesc:a5cf2b17b953ccfefb1d13c39bd1be72c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new file and returns an output stream for writing to it.  <a href="#a5cf2b17b953ccfefb1d13c39bd1be72c">More...</a><br /></td></tr>
<tr class="separator:a5cf2b17b953ccfefb1d13c39bd1be72c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ec69c5360219bccb794bab6a128e88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileIOStream.html">FileIOStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ad5ec69c5360219bccb794bab6a128e88">create_file_readwrite</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a>)</td></tr>
<tr class="memdesc:ad5ec69c5360219bccb794bab6a128e88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new file and returns a stream for reading and writing to it.  <a href="#ad5ec69c5360219bccb794bab6a128e88">More...</a><br /></td></tr>
<tr class="separator:ad5ec69c5360219bccb794bab6a128e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf5673ceb9095405e458b5035b0986b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileIOStream.html">FileIOStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#acf5673ceb9095405e458b5035b0986b4">create_file_readwrite</a> (<a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a>)</td></tr>
<tr class="memdesc:acf5673ceb9095405e458b5035b0986b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new file and returns a stream for reading and writing to it.  <a href="#acf5673ceb9095405e458b5035b0986b4">More...</a><br /></td></tr>
<tr class="separator:acf5673ceb9095405e458b5035b0986b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7cf0360096504e40f799fde5cc8e9de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ad7cf0360096504e40f799fde5cc8e9de">replace</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag=<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>(), bool make_backup=false, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a>)</td></tr>
<tr class="memdesc:ad7cf0360096504e40f799fde5cc8e9de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an output stream for overwriting the file, possibly creating a backup copy of the file first.  <a href="#ad7cf0360096504e40f799fde5cc8e9de">More...</a><br /></td></tr>
<tr class="separator:ad7cf0360096504e40f799fde5cc8e9de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf55f9291659566f6fd36271801b013b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#acf55f9291659566f6fd36271801b013b">replace</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag=<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>(), bool make_backup=false, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a>)</td></tr>
<tr class="memdesc:acf55f9291659566f6fd36271801b013b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an output stream for overwriting the file, possibly creating a backup copy of the file first.  <a href="#acf55f9291659566f6fd36271801b013b">More...</a><br /></td></tr>
<tr class="separator:acf55f9291659566f6fd36271801b013b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3dfb193e8f2ab69e24c4370de5335a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a1e3dfb193e8f2ab69e24c4370de5335a">append_to_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:a1e3dfb193e8f2ab69e24c4370de5335a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously opens the file for appending.  <a href="#a1e3dfb193e8f2ab69e24c4370de5335a">More...</a><br /></td></tr>
<tr class="separator:a1e3dfb193e8f2ab69e24c4370de5335a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff3163e9bf8d8208cd0c0e568b777de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#abff3163e9bf8d8208cd0c0e568b777de">append_to_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:abff3163e9bf8d8208cd0c0e568b777de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously opens the file for appending.  <a href="#abff3163e9bf8d8208cd0c0e568b777de">More...</a><br /></td></tr>
<tr class="separator:abff3163e9bf8d8208cd0c0e568b777de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab95fdc72631ad9a07a94eac0bac50090"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ab95fdc72631ad9a07a94eac0bac50090">append_to_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; res)</td></tr>
<tr class="memdesc:ab95fdc72631ad9a07a94eac0bac50090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous file append operation started with g_file_append_to_async().  <a href="#ab95fdc72631ad9a07a94eac0bac50090">More...</a><br /></td></tr>
<tr class="separator:ab95fdc72631ad9a07a94eac0bac50090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c42446d37aa466173965b7db1a2053"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ae0c42446d37aa466173965b7db1a2053">create_file_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:ae0c42446d37aa466173965b7db1a2053"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously creates a new file and returns an output stream for writing to it.  <a href="#ae0c42446d37aa466173965b7db1a2053">More...</a><br /></td></tr>
<tr class="separator:ae0c42446d37aa466173965b7db1a2053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe6ed015f3d2bb72aa7aceed8dc7ca1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a3fe6ed015f3d2bb72aa7aceed8dc7ca1">create_file_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:a3fe6ed015f3d2bb72aa7aceed8dc7ca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously creates a new file and returns an output stream for writing to it.  <a href="#a3fe6ed015f3d2bb72aa7aceed8dc7ca1">More...</a><br /></td></tr>
<tr class="separator:a3fe6ed015f3d2bb72aa7aceed8dc7ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a128001018104d45b158a27003c0c2638"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a128001018104d45b158a27003c0c2638">create_file_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; res)</td></tr>
<tr class="memdesc:a128001018104d45b158a27003c0c2638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous file create operation started with g_file_create_async().  <a href="#a128001018104d45b158a27003c0c2638">More...</a><br /></td></tr>
<tr class="separator:a128001018104d45b158a27003c0c2638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c27a2460468aab1d3c3665234c24a56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a4c27a2460468aab1d3c3665234c24a56">create_file_readwrite_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:a4c27a2460468aab1d3c3665234c24a56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously creates a new file and returns a stream for reading and writing to it.  <a href="#a4c27a2460468aab1d3c3665234c24a56">More...</a><br /></td></tr>
<tr class="separator:a4c27a2460468aab1d3c3665234c24a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5989cfdee54778de733a529c24607b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a5a5989cfdee54778de733a529c24607b">create_file_readwrite_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:a5a5989cfdee54778de733a529c24607b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously creates a new file and returns a stream for reading and writing to it.  <a href="#a5a5989cfdee54778de733a529c24607b">More...</a><br /></td></tr>
<tr class="separator:a5a5989cfdee54778de733a529c24607b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a339d08bf6cafea58d9d0b0675e741d25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileIOStream.html">FileIOStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a339d08bf6cafea58d9d0b0675e741d25">create_file_readwrite_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; res)</td></tr>
<tr class="memdesc:a339d08bf6cafea58d9d0b0675e741d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous file create operation started with g_file_create_readwrite_async().  <a href="#a339d08bf6cafea58d9d0b0675e741d25">More...</a><br /></td></tr>
<tr class="separator:a339d08bf6cafea58d9d0b0675e741d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad777cdaa404a6a668ee8d520299687ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ad777cdaa404a6a668ee8d520299687ce">replace_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag=<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>(), bool make_backup=false, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:ad777cdaa404a6a668ee8d520299687ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asyncronously overwrites the file, replacing the contents, possibly creating a backup copy of the file first.  <a href="#ad777cdaa404a6a668ee8d520299687ce">More...</a><br /></td></tr>
<tr class="separator:ad777cdaa404a6a668ee8d520299687ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51e51a2e3a45da4324230b4d5401a58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ae51e51a2e3a45da4324230b4d5401a58">replace_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag=<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>(), bool make_backup=false, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:ae51e51a2e3a45da4324230b4d5401a58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asyncronously overwrites the file, replacing the contents, possibly creating a backup copy of the file first.  <a href="#ae51e51a2e3a45da4324230b4d5401a58">More...</a><br /></td></tr>
<tr class="separator:ae51e51a2e3a45da4324230b4d5401a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5fe0438c73500d3d6ec7d0d4b39daa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a4e5fe0438c73500d3d6ec7d0d4b39daa">replace_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; res)</td></tr>
<tr class="memdesc:a4e5fe0438c73500d3d6ec7d0d4b39daa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous file replace operation started with g_file_replace_async().  <a href="#a4e5fe0438c73500d3d6ec7d0d4b39daa">More...</a><br /></td></tr>
<tr class="separator:a4e5fe0438c73500d3d6ec7d0d4b39daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a128757d6cf7b152c82bb378a095003ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileIOStream.html">FileIOStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a128757d6cf7b152c82bb378a095003ef">open_readwrite</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:a128757d6cf7b152c82bb378a095003ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens an existing file for reading and writing.  <a href="#a128757d6cf7b152c82bb378a095003ef">More...</a><br /></td></tr>
<tr class="separator:a128757d6cf7b152c82bb378a095003ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a456f74951f371ef5cca4282751efc66a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileIOStream.html">FileIOStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a456f74951f371ef5cca4282751efc66a">open_readwrite</a> ()</td></tr>
<tr class="memdesc:a456f74951f371ef5cca4282751efc66a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classGio_1_1File.html#a456f74951f371ef5cca4282751efc66a" title="A open_readwrite() convenience overload. ">open_readwrite()</a> convenience overload.  <a href="#a456f74951f371ef5cca4282751efc66a">More...</a><br /></td></tr>
<tr class="separator:a456f74951f371ef5cca4282751efc66a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d95a731716c7ffaa86c3af90afe8d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a73d95a731716c7ffaa86c3af90afe8d3">open_readwrite_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:a73d95a731716c7ffaa86c3af90afe8d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens an existing file for reading and writing.  <a href="#a73d95a731716c7ffaa86c3af90afe8d3">More...</a><br /></td></tr>
<tr class="separator:a73d95a731716c7ffaa86c3af90afe8d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a405af7082f531a7a39f3e7a453ab6267"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a405af7082f531a7a39f3e7a453ab6267">open_readwrite_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:a405af7082f531a7a39f3e7a453ab6267"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens an existing file for reading and writing.  <a href="#a405af7082f531a7a39f3e7a453ab6267">More...</a><br /></td></tr>
<tr class="separator:a405af7082f531a7a39f3e7a453ab6267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fdcb54ece686c870eac69c6f93aed75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileIOStream.html">FileIOStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a5fdcb54ece686c870eac69c6f93aed75">open_readwrite_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; res)</td></tr>
<tr class="memdesc:a5fdcb54ece686c870eac69c6f93aed75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous file read operation started with g_file_open_readwrite_async().  <a href="#a5fdcb54ece686c870eac69c6f93aed75">More...</a><br /></td></tr>
<tr class="separator:a5fdcb54ece686c870eac69c6f93aed75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af483e2ddc29cbb6cd1ad751403247bad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileIOStream.html">FileIOStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#af483e2ddc29cbb6cd1ad751403247bad">replace_readwrite</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag=<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>(), bool make_backup=false, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a>)</td></tr>
<tr class="memdesc:af483e2ddc29cbb6cd1ad751403247bad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an output stream for overwriting the file in readwrite mode, possibly creating a backup copy of the file first.  <a href="#af483e2ddc29cbb6cd1ad751403247bad">More...</a><br /></td></tr>
<tr class="separator:af483e2ddc29cbb6cd1ad751403247bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c4aa84e74b27a67bce6b5fdccb91449"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileIOStream.html">FileIOStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a0c4aa84e74b27a67bce6b5fdccb91449">replace_readwrite</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag=<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>(), bool make_backup=false, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a>)</td></tr>
<tr class="memdesc:a0c4aa84e74b27a67bce6b5fdccb91449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an output stream for overwriting the file in readwrite mode, possibly creating a backup copy of the file first.  <a href="#a0c4aa84e74b27a67bce6b5fdccb91449">More...</a><br /></td></tr>
<tr class="separator:a0c4aa84e74b27a67bce6b5fdccb91449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ebbb5e33c0afd302add9863f2d8c24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#af5ebbb5e33c0afd302add9863f2d8c24">replace_readwrite_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag=<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>(), bool make_backup=false, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:af5ebbb5e33c0afd302add9863f2d8c24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asyncronously overwrites the file in read-write mode, replacing the contents, possibly creating a backup copy of the file first.  <a href="#af5ebbb5e33c0afd302add9863f2d8c24">More...</a><br /></td></tr>
<tr class="separator:af5ebbb5e33c0afd302add9863f2d8c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b7d1782f03a4d6a4dbf3be16321324"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a38b7d1782f03a4d6a4dbf3be16321324">replace_readwrite_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag=<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>(), bool make_backup=false, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:a38b7d1782f03a4d6a4dbf3be16321324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asyncronously overwrites the file in read-write mode, replacing the contents, possibly creating a backup copy of the file first.  <a href="#a38b7d1782f03a4d6a4dbf3be16321324">More...</a><br /></td></tr>
<tr class="separator:a38b7d1782f03a4d6a4dbf3be16321324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47d246b8ff87be3aaef635ac123d1e44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileIOStream.html">FileIOStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a47d246b8ff87be3aaef635ac123d1e44">replace_readwrite_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; res)</td></tr>
<tr class="memdesc:a47d246b8ff87be3aaef635ac123d1e44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous file replace operation started with g_file_replace_readwrite_async().  <a href="#a47d246b8ff87be3aaef635ac123d1e44">More...</a><br /></td></tr>
<tr class="separator:a47d246b8ff87be3aaef635ac123d1e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb25ffdbe571d33e89c9503fe9a20dcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#adb25ffdbe571d33e89c9503fe9a20dcd">query_info</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attributes=&quot;*&quot;, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags=<a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0a4e412b5c20ae24607975e36b1d2142c9">FILE_QUERY_INFO_NONE</a>) const </td></tr>
<tr class="memdesc:adb25ffdbe571d33e89c9503fe9a20dcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the requested information about the file.  <a href="#adb25ffdbe571d33e89c9503fe9a20dcd">More...</a><br /></td></tr>
<tr class="separator:adb25ffdbe571d33e89c9503fe9a20dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4b9c07ade255b12e2b43c38c3aba90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a4e4b9c07ade255b12e2b43c38c3aba90">query_info</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attributes=&quot;*&quot;, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags=<a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0a4e412b5c20ae24607975e36b1d2142c9">FILE_QUERY_INFO_NONE</a>) const </td></tr>
<tr class="memdesc:a4e4b9c07ade255b12e2b43c38c3aba90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the requested information about the file.  <a href="#a4e4b9c07ade255b12e2b43c38c3aba90">More...</a><br /></td></tr>
<tr class="separator:a4e4b9c07ade255b12e2b43c38c3aba90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b0a75e0afdb5f6874ea5e304d55ea8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ad8b0a75e0afdb5f6874ea5e304d55ea8">query_exists</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable) const </td></tr>
<tr class="memdesc:ad8b0a75e0afdb5f6874ea5e304d55ea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to check if a particular file exists.  <a href="#ad8b0a75e0afdb5f6874ea5e304d55ea8">More...</a><br /></td></tr>
<tr class="separator:ad8b0a75e0afdb5f6874ea5e304d55ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4cfdbf4fedacd364e40a72c71ab341a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ab4cfdbf4fedacd364e40a72c71ab341a">query_exists</a> () const </td></tr>
<tr class="memdesc:ab4cfdbf4fedacd364e40a72c71ab341a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classGio_1_1File.html#ad8b0a75e0afdb5f6874ea5e304d55ea8" title="Utility function to check if a particular file exists. ">query_exists()</a> convenience overload.  <a href="#ab4cfdbf4fedacd364e40a72c71ab341a">More...</a><br /></td></tr>
<tr class="separator:ab4cfdbf4fedacd364e40a72c71ab341a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa27c5b271c8f7667ce117cfc6118262e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__giommEnums.html#ga7dcba95023d74c47bba3fd0a07f8824c">FileType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aa27c5b271c8f7667ce117cfc6118262e">query_file_type</a> (<a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable) const </td></tr>
<tr class="memdesc:aa27c5b271c8f7667ce117cfc6118262e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to inspect the FileType of a file.  <a href="#aa27c5b271c8f7667ce117cfc6118262e">More...</a><br /></td></tr>
<tr class="separator:aa27c5b271c8f7667ce117cfc6118262e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a691a9de5512b870bf358a9b0d292e146"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__giommEnums.html#ga7dcba95023d74c47bba3fd0a07f8824c">FileType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a691a9de5512b870bf358a9b0d292e146">query_file_type</a> (<a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags=<a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0a4e412b5c20ae24607975e36b1d2142c9">FILE_QUERY_INFO_NONE</a>) const </td></tr>
<tr class="memdesc:a691a9de5512b870bf358a9b0d292e146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to inspect the FileType of a file.  <a href="#a691a9de5512b870bf358a9b0d292e146">More...</a><br /></td></tr>
<tr class="separator:a691a9de5512b870bf358a9b0d292e146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd60e7864f8954c35e3b0891058e61c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a7bd60e7864f8954c35e3b0891058e61c">query_info_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attributes=&quot;*&quot;, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags=<a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0a4e412b5c20ae24607975e36b1d2142c9">FILE_QUERY_INFO_NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>) const </td></tr>
<tr class="memdesc:a7bd60e7864f8954c35e3b0891058e61c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously gets the requested information about specified file.  <a href="#a7bd60e7864f8954c35e3b0891058e61c">More...</a><br /></td></tr>
<tr class="separator:a7bd60e7864f8954c35e3b0891058e61c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcad69d782a971802a8aa85125ac2c8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#afcad69d782a971802a8aa85125ac2c8c">query_info_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attributes=&quot;*&quot;, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags=<a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0a4e412b5c20ae24607975e36b1d2142c9">FILE_QUERY_INFO_NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>) const </td></tr>
<tr class="memdesc:afcad69d782a971802a8aa85125ac2c8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously gets the requested information about specified file.  <a href="#afcad69d782a971802a8aa85125ac2c8c">More...</a><br /></td></tr>
<tr class="separator:afcad69d782a971802a8aa85125ac2c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33eadfff77c93a77ecde795307728e52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a33eadfff77c93a77ecde795307728e52">query_info_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; res)</td></tr>
<tr class="memdesc:a33eadfff77c93a77ecde795307728e52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous file info query.  <a href="#a33eadfff77c93a77ecde795307728e52">More...</a><br /></td></tr>
<tr class="separator:a33eadfff77c93a77ecde795307728e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40486bc2f0c8758ef8a705b6b8b57e57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a40486bc2f0c8758ef8a705b6b8b57e57">query_filesystem_info</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attributes=&quot;*&quot;)</td></tr>
<tr class="memdesc:a40486bc2f0c8758ef8a705b6b8b57e57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="classGio_1_1File.html#adb25ffdbe571d33e89c9503fe9a20dcd" title="Gets the requested information about the file. ">query_info()</a>, but obtains information about the filesystem the file is on, rather than the file itself.  <a href="#a40486bc2f0c8758ef8a705b6b8b57e57">More...</a><br /></td></tr>
<tr class="separator:a40486bc2f0c8758ef8a705b6b8b57e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac737012f8df97d90e2447d94d30b817d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ac737012f8df97d90e2447d94d30b817d">query_filesystem_info</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attributes=&quot;*&quot;)</td></tr>
<tr class="memdesc:ac737012f8df97d90e2447d94d30b817d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="classGio_1_1File.html#adb25ffdbe571d33e89c9503fe9a20dcd" title="Gets the requested information about the file. ">query_info()</a>, but obtains information about the filesystem the file is on, rather than the file itself.  <a href="#ac737012f8df97d90e2447d94d30b817d">More...</a><br /></td></tr>
<tr class="separator:ac737012f8df97d90e2447d94d30b817d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b881926b8d58c49d3baa1f51f2ee5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Mount.html">Mount</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a45b881926b8d58c49d3baa1f51f2ee5d">find_enclosing_mount</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:a45b881926b8d58c49d3baa1f51f2ee5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a <a class="el" href="classGio_1_1Mount.html" title="The Mount interface represents user-visible mounts. ">Mount</a> for the <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a>.  <a href="#a45b881926b8d58c49d3baa1f51f2ee5d">More...</a><br /></td></tr>
<tr class="separator:a45b881926b8d58c49d3baa1f51f2ee5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb675267c7ea1c2a0d40e2e754d8333"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Mount.html">Mount</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a6eb675267c7ea1c2a0d40e2e754d8333">find_enclosing_mount</a> ()</td></tr>
<tr class="memdesc:a6eb675267c7ea1c2a0d40e2e754d8333"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classGio_1_1File.html#a6eb675267c7ea1c2a0d40e2e754d8333" title="A find_enclosing_mount() convenience overload. ">find_enclosing_mount()</a> convenience overload.  <a href="#a6eb675267c7ea1c2a0d40e2e754d8333">More...</a><br /></td></tr>
<tr class="separator:a6eb675267c7ea1c2a0d40e2e754d8333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39184ff9c9437259df4b9a9e2f283a0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a39184ff9c9437259df4b9a9e2f283a0b">query_filesystem_info_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attributes=&quot;*&quot;, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>) const </td></tr>
<tr class="memdesc:a39184ff9c9437259df4b9a9e2f283a0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously gets the requested information about the filesystem that the file is on.  <a href="#a39184ff9c9437259df4b9a9e2f283a0b">More...</a><br /></td></tr>
<tr class="separator:a39184ff9c9437259df4b9a9e2f283a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4557ab16a50337f73d8a4649cf60fe70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a4557ab16a50337f73d8a4649cf60fe70">query_filesystem_info_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attributes=&quot;*&quot;, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>) const </td></tr>
<tr class="memdesc:a4557ab16a50337f73d8a4649cf60fe70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously gets the requested information about the filesystem that the file is on.  <a href="#a4557ab16a50337f73d8a4649cf60fe70">More...</a><br /></td></tr>
<tr class="separator:a4557ab16a50337f73d8a4649cf60fe70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af986512a5b8cb8acf75afd7206b09be1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#af986512a5b8cb8acf75afd7206b09be1">query_filesystem_info_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; res)</td></tr>
<tr class="memdesc:af986512a5b8cb8acf75afd7206b09be1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous filesystem info query.  <a href="#af986512a5b8cb8acf75afd7206b09be1">More...</a><br /></td></tr>
<tr class="separator:af986512a5b8cb8acf75afd7206b09be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c95d4fa47157f7757b686677dec018"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a78c95d4fa47157f7757b686677dec018">find_enclosing_mount_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:a78c95d4fa47157f7757b686677dec018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously gets the mount for the file.  <a href="#a78c95d4fa47157f7757b686677dec018">More...</a><br /></td></tr>
<tr class="separator:a78c95d4fa47157f7757b686677dec018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67458be57c5687e7469bc26e2594f4be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a67458be57c5687e7469bc26e2594f4be">find_enclosing_mount_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:a67458be57c5687e7469bc26e2594f4be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously gets the mount for the file.  <a href="#a67458be57c5687e7469bc26e2594f4be">More...</a><br /></td></tr>
<tr class="separator:a67458be57c5687e7469bc26e2594f4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b415b02053e16a92cabb6a48368733"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Mount.html">Mount</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ad4b415b02053e16a92cabb6a48368733">find_enclosing_mount_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; res)</td></tr>
<tr class="memdesc:ad4b415b02053e16a92cabb6a48368733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous find mount request.  <a href="#ad4b415b02053e16a92cabb6a48368733">More...</a><br /></td></tr>
<tr class="separator:ad4b415b02053e16a92cabb6a48368733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c3afcddc0d4860aa2afb4bf715bb20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileEnumerator.html">FileEnumerator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a68c3afcddc0d4860aa2afb4bf715bb20">enumerate_children</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attributes=&quot;*&quot;, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags=<a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0a4e412b5c20ae24607975e36b1d2142c9">FILE_QUERY_INFO_NONE</a>)</td></tr>
<tr class="memdesc:a68c3afcddc0d4860aa2afb4bf715bb20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the requested information about the files in a directory.  <a href="#a68c3afcddc0d4860aa2afb4bf715bb20">More...</a><br /></td></tr>
<tr class="separator:a68c3afcddc0d4860aa2afb4bf715bb20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e293d607499b223f4892fb290ab2d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileEnumerator.html">FileEnumerator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ac0e293d607499b223f4892fb290ab2d6">enumerate_children</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attributes=&quot;*&quot;, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags=<a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0a4e412b5c20ae24607975e36b1d2142c9">FILE_QUERY_INFO_NONE</a>)</td></tr>
<tr class="memdesc:ac0e293d607499b223f4892fb290ab2d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the requested information about the files in a directory.  <a href="#ac0e293d607499b223f4892fb290ab2d6">More...</a><br /></td></tr>
<tr class="separator:ac0e293d607499b223f4892fb290ab2d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ead7237b7057d9b15cf5f3065988131"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a1ead7237b7057d9b15cf5f3065988131">enumerate_children_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attributes=&quot;*&quot;, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags=<a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0a4e412b5c20ae24607975e36b1d2142c9">FILE_QUERY_INFO_NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:a1ead7237b7057d9b15cf5f3065988131"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously gets the requested information about the files in a directory.  <a href="#a1ead7237b7057d9b15cf5f3065988131">More...</a><br /></td></tr>
<tr class="separator:a1ead7237b7057d9b15cf5f3065988131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5470cf1c97754a12169201665f1202"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a5b5470cf1c97754a12169201665f1202">enumerate_children_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attributes=&quot;*&quot;, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags=<a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0a4e412b5c20ae24607975e36b1d2142c9">FILE_QUERY_INFO_NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:a5b5470cf1c97754a12169201665f1202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously gets the requested information about the files in a directory.  <a href="#a5b5470cf1c97754a12169201665f1202">More...</a><br /></td></tr>
<tr class="separator:a5b5470cf1c97754a12169201665f1202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdabb80157c69c01479e0b89821c1299"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileEnumerator.html">FileEnumerator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#acdabb80157c69c01479e0b89821c1299">enumerate_children_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; res)</td></tr>
<tr class="memdesc:acdabb80157c69c01479e0b89821c1299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an async enumerate children operation.  <a href="#acdabb80157c69c01479e0b89821c1299">More...</a><br /></td></tr>
<tr class="separator:acdabb80157c69c01479e0b89821c1299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd75810d7c9ebafac398288f5afc018"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a3dd75810d7c9ebafac398288f5afc018">set_display_name</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; display_name, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:a3dd75810d7c9ebafac398288f5afc018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Renames <em>file</em> to the specified display name.  <a href="#a3dd75810d7c9ebafac398288f5afc018">More...</a><br /></td></tr>
<tr class="separator:a3dd75810d7c9ebafac398288f5afc018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2aa80b2d0ecdd22f0222c8ce42d177"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a8c2aa80b2d0ecdd22f0222c8ce42d177">set_display_name</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; display_name)</td></tr>
<tr class="memdesc:a8c2aa80b2d0ecdd22f0222c8ce42d177"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classGio_1_1File.html#a3dd75810d7c9ebafac398288f5afc018" title="Renames file to the specified display name. ">set_display_name()</a> convenience overload.  <a href="#a8c2aa80b2d0ecdd22f0222c8ce42d177">More...</a><br /></td></tr>
<tr class="separator:a8c2aa80b2d0ecdd22f0222c8ce42d177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac539d7758b9c0de809f8c83e0bba79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a0ac539d7758b9c0de809f8c83e0bba79">set_display_name_async</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; display_name, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:a0ac539d7758b9c0de809f8c83e0bba79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously sets the display name for a given <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">Gio::File</a>.  <a href="#a0ac539d7758b9c0de809f8c83e0bba79">More...</a><br /></td></tr>
<tr class="separator:a0ac539d7758b9c0de809f8c83e0bba79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74d219d321dca3d438f876256dee82d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a74d219d321dca3d438f876256dee82d2">set_display_name_async</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; display_name, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:a74d219d321dca3d438f876256dee82d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously sets the display name for a given <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">Gio::File</a>.  <a href="#a74d219d321dca3d438f876256dee82d2">More...</a><br /></td></tr>
<tr class="separator:a74d219d321dca3d438f876256dee82d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2abb19573076b426434f7d8d2d5a0cdb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a2abb19573076b426434f7d8d2d5a0cdb">set_display_name_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; res)</td></tr>
<tr class="memdesc:a2abb19573076b426434f7d8d2d5a0cdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes setting a display name started with g_file_set_display_name_async().  <a href="#a2abb19573076b426434f7d8d2d5a0cdb">More...</a><br /></td></tr>
<tr class="separator:a2abb19573076b426434f7d8d2d5a0cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aded971b0cf84801f6684ad4bd5dc66c5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aded971b0cf84801f6684ad4bd5dc66c5">remove</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:aded971b0cf84801f6684ad4bd5dc66c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes a file.  <a href="#aded971b0cf84801f6684ad4bd5dc66c5">More...</a><br /></td></tr>
<tr class="separator:aded971b0cf84801f6684ad4bd5dc66c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f34508dea523cbf889b7193e513ca4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a14f34508dea523cbf889b7193e513ca4">remove</a> ()</td></tr>
<tr class="memdesc:a14f34508dea523cbf889b7193e513ca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classGio_1_1File.html#a14f34508dea523cbf889b7193e513ca4" title="A remove() convenience overload. ">remove()</a> convenience overload.  <a href="#a14f34508dea523cbf889b7193e513ca4">More...</a><br /></td></tr>
<tr class="separator:a14f34508dea523cbf889b7193e513ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8499cabde1f50f1cbd5d928d63e73fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ad8499cabde1f50f1cbd5d928d63e73fb">remove_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot_ready, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:ad8499cabde1f50f1cbd5d928d63e73fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously delete a file.  <a href="#ad8499cabde1f50f1cbd5d928d63e73fb">More...</a><br /></td></tr>
<tr class="separator:ad8499cabde1f50f1cbd5d928d63e73fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21198001203267126de9a24a8e91b0d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a21198001203267126de9a24a8e91b0d1">remove_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot_ready, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:a21198001203267126de9a24a8e91b0d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously delete a file.  <a href="#a21198001203267126de9a24a8e91b0d1">More...</a><br /></td></tr>
<tr class="separator:a21198001203267126de9a24a8e91b0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0240c85a3ec46e107666e65da9b92c54"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a0240c85a3ec46e107666e65da9b92c54">remove_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr class="memdesc:a0240c85a3ec46e107666e65da9b92c54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes deleting a file started with g_file_delete_async().  <a href="#a0240c85a3ec46e107666e65da9b92c54">More...</a><br /></td></tr>
<tr class="separator:a0240c85a3ec46e107666e65da9b92c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae5ecd962e832cf8d538877f4118da8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#acae5ecd962e832cf8d538877f4118da8">trash</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:acae5ecd962e832cf8d538877f4118da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends <em>file</em> to the "Trashcan", if possible.  <a href="#acae5ecd962e832cf8d538877f4118da8">More...</a><br /></td></tr>
<tr class="separator:acae5ecd962e832cf8d538877f4118da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1925736f9af338eaf9942468b4d6d65e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a1925736f9af338eaf9942468b4d6d65e">trash</a> ()</td></tr>
<tr class="memdesc:a1925736f9af338eaf9942468b4d6d65e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classGio_1_1File.html#a1925736f9af338eaf9942468b4d6d65e" title="A trash() convenience overload. ">trash()</a> convenience overload.  <a href="#a1925736f9af338eaf9942468b4d6d65e">More...</a><br /></td></tr>
<tr class="separator:a1925736f9af338eaf9942468b4d6d65e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab15e7d88376d144253bce7bfba2730"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#afab15e7d88376d144253bce7bfba2730">trash_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot_ready, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:afab15e7d88376d144253bce7bfba2730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously sends the file to the Trash location, if possible.  <a href="#afab15e7d88376d144253bce7bfba2730">More...</a><br /></td></tr>
<tr class="separator:afab15e7d88376d144253bce7bfba2730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb6f01422a66c141ba721fc8790f10a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a5cb6f01422a66c141ba721fc8790f10a">trash_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot_ready, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:a5cb6f01422a66c141ba721fc8790f10a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously sends the file to the Trash location, if possible.  <a href="#a5cb6f01422a66c141ba721fc8790f10a">More...</a><br /></td></tr>
<tr class="separator:a5cb6f01422a66c141ba721fc8790f10a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee78bd712cb24661335cee8e3d29344"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a7ee78bd712cb24661335cee8e3d29344">trash_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr class="memdesc:a7ee78bd712cb24661335cee8e3d29344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous file trashing operation, started with g_file_trash_async().  <a href="#a7ee78bd712cb24661335cee8e3d29344">More...</a><br /></td></tr>
<tr class="separator:a7ee78bd712cb24661335cee8e3d29344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e906ed93069e6adb6d87dae158cad9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#af9e906ed93069e6adb6d87dae158cad9">copy</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; destination, const <a class="el" href="classGio_1_1File.html#ac5ff32ee99845479d138eee49d92e59c">SlotFileProgress</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a> flags=<a class="el" href="namespaceGio.html#ga08edc09a45449b136b27493647d4ecbea74324723d31670f9d554d43d4d21cba9">FILE_COPY_NONE</a>)</td></tr>
<tr class="memdesc:af9e906ed93069e6adb6d87dae158cad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the file source to the location specified by destination.  <a href="#af9e906ed93069e6adb6d87dae158cad9">More...</a><br /></td></tr>
<tr class="separator:af9e906ed93069e6adb6d87dae158cad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d8159b5b377db174b376b3c09deb7c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a1d8159b5b377db174b376b3c09deb7c1">copy</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; destination, const <a class="el" href="classGio_1_1File.html#ac5ff32ee99845479d138eee49d92e59c">SlotFileProgress</a>&amp; slot, <a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a> flags=<a class="el" href="namespaceGio.html#ga08edc09a45449b136b27493647d4ecbea74324723d31670f9d554d43d4d21cba9">FILE_COPY_NONE</a>)</td></tr>
<tr class="memdesc:a1d8159b5b377db174b376b3c09deb7c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the file source to the location specified by destination.  <a href="#a1d8159b5b377db174b376b3c09deb7c1">More...</a><br /></td></tr>
<tr class="separator:a1d8159b5b377db174b376b3c09deb7c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6b45bed32567031bc7b48273ad4079"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a7a6b45bed32567031bc7b48273ad4079">copy</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; destination, <a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a> flags=<a class="el" href="namespaceGio.html#ga08edc09a45449b136b27493647d4ecbea74324723d31670f9d554d43d4d21cba9">FILE_COPY_NONE</a>)</td></tr>
<tr class="memdesc:a7a6b45bed32567031bc7b48273ad4079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the file source to the location specified by destination.  <a href="#a7a6b45bed32567031bc7b48273ad4079">More...</a><br /></td></tr>
<tr class="separator:a7a6b45bed32567031bc7b48273ad4079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1785b7a4780d5d4ba5ae651350e34398"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a1785b7a4780d5d4ba5ae651350e34398">copy_async</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; destination, const <a class="el" href="classGio_1_1File.html#ac5ff32ee99845479d138eee49d92e59c">SlotFileProgress</a>&amp; slot_progress, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot_ready, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a> flags=<a class="el" href="namespaceGio.html#ga08edc09a45449b136b27493647d4ecbea74324723d31670f9d554d43d4d21cba9">FILE_COPY_NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:a1785b7a4780d5d4ba5ae651350e34398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the file to the location specified by <em>destination</em> asynchronously.  <a href="#a1785b7a4780d5d4ba5ae651350e34398">More...</a><br /></td></tr>
<tr class="separator:a1785b7a4780d5d4ba5ae651350e34398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b8ae7393c73a9a1d383a82d61f4ac30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a5b8ae7393c73a9a1d383a82d61f4ac30">copy_async</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; destination, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot_ready, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a> flags=<a class="el" href="namespaceGio.html#ga08edc09a45449b136b27493647d4ecbea74324723d31670f9d554d43d4d21cba9">FILE_COPY_NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:a5b8ae7393c73a9a1d383a82d61f4ac30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the file to the location specified by <em>destination</em> asynchronously.  <a href="#a5b8ae7393c73a9a1d383a82d61f4ac30">More...</a><br /></td></tr>
<tr class="separator:a5b8ae7393c73a9a1d383a82d61f4ac30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b1a85f29bbbe15998c090b3794cbf5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ac2b1a85f29bbbe15998c090b3794cbf5">copy_async</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; destination, const <a class="el" href="classGio_1_1File.html#ac5ff32ee99845479d138eee49d92e59c">SlotFileProgress</a>&amp; slot_progress, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot_ready, <a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a> flags=<a class="el" href="namespaceGio.html#ga08edc09a45449b136b27493647d4ecbea74324723d31670f9d554d43d4d21cba9">FILE_COPY_NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:ac2b1a85f29bbbe15998c090b3794cbf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the file to the location specified by <em>destination</em> asynchronously.  <a href="#ac2b1a85f29bbbe15998c090b3794cbf5">More...</a><br /></td></tr>
<tr class="separator:ac2b1a85f29bbbe15998c090b3794cbf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad538a383b8761d04bd36ed1aa1071e50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ad538a383b8761d04bd36ed1aa1071e50">copy_async</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; destination, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot_ready, <a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a> flags=<a class="el" href="namespaceGio.html#ga08edc09a45449b136b27493647d4ecbea74324723d31670f9d554d43d4d21cba9">FILE_COPY_NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:ad538a383b8761d04bd36ed1aa1071e50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the file to the location specified by <em>destination</em> asynchronously.  <a href="#ad538a383b8761d04bd36ed1aa1071e50">More...</a><br /></td></tr>
<tr class="separator:ad538a383b8761d04bd36ed1aa1071e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab16cd89db6cd5bb0c8dfdd4b635002d7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ab16cd89db6cd5bb0c8dfdd4b635002d7">copy_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; res)</td></tr>
<tr class="memdesc:ab16cd89db6cd5bb0c8dfdd4b635002d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes copying the file started with g_file_copy_async().  <a href="#ab16cd89db6cd5bb0c8dfdd4b635002d7">More...</a><br /></td></tr>
<tr class="separator:ab16cd89db6cd5bb0c8dfdd4b635002d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c0d55880178c37dee578fdc723b0f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a51c0d55880178c37dee578fdc723b0f2">move</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; destination, const <a class="el" href="classGio_1_1File.html#ac5ff32ee99845479d138eee49d92e59c">SlotFileProgress</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a> flags=<a class="el" href="namespaceGio.html#ga08edc09a45449b136b27493647d4ecbea74324723d31670f9d554d43d4d21cba9">FILE_COPY_NONE</a>)</td></tr>
<tr class="memdesc:a51c0d55880178c37dee578fdc723b0f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to move the file or directory source to the location specified by destination.  <a href="#a51c0d55880178c37dee578fdc723b0f2">More...</a><br /></td></tr>
<tr class="separator:a51c0d55880178c37dee578fdc723b0f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb2d8bfed1cb7af50e5e5795ebea732"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#adfb2d8bfed1cb7af50e5e5795ebea732">move</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; destination, const <a class="el" href="classGio_1_1File.html#ac5ff32ee99845479d138eee49d92e59c">SlotFileProgress</a>&amp; slot, <a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a> flags=<a class="el" href="namespaceGio.html#ga08edc09a45449b136b27493647d4ecbea74324723d31670f9d554d43d4d21cba9">FILE_COPY_NONE</a>)</td></tr>
<tr class="separator:adfb2d8bfed1cb7af50e5e5795ebea732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba1fab56c3a8bea0b7e4d7f7324c5320"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aba1fab56c3a8bea0b7e4d7f7324c5320">move</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; destination, <a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a> flags=<a class="el" href="namespaceGio.html#ga08edc09a45449b136b27493647d4ecbea74324723d31670f9d554d43d4d21cba9">FILE_COPY_NONE</a>)</td></tr>
<tr class="separator:aba1fab56c3a8bea0b7e4d7f7324c5320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa05e23e95e77cabac289ab4e294a58"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#abfa05e23e95e77cabac289ab4e294a58">make_directory</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:abfa05e23e95e77cabac289ab4e294a58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a directory.  <a href="#abfa05e23e95e77cabac289ab4e294a58">More...</a><br /></td></tr>
<tr class="separator:abfa05e23e95e77cabac289ab4e294a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e9aa5f58a76a8562fd00a13434f554"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aa1e9aa5f58a76a8562fd00a13434f554">make_directory</a> ()</td></tr>
<tr class="memdesc:aa1e9aa5f58a76a8562fd00a13434f554"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classGio_1_1File.html#aa1e9aa5f58a76a8562fd00a13434f554" title="A make_directory() convenience overload. ">make_directory()</a> convenience overload.  <a href="#aa1e9aa5f58a76a8562fd00a13434f554">More...</a><br /></td></tr>
<tr class="separator:aa1e9aa5f58a76a8562fd00a13434f554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60cf2bf09420aec99766fa132d8ae0a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a60cf2bf09420aec99766fa132d8ae0a8">make_directory_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot_ready, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:a60cf2bf09420aec99766fa132d8ae0a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously creates a directory.  <a href="#a60cf2bf09420aec99766fa132d8ae0a8">More...</a><br /></td></tr>
<tr class="separator:a60cf2bf09420aec99766fa132d8ae0a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7facff532924459948de0031396f9b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ad7facff532924459948de0031396f9b5">make_directory_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot_ready, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:ad7facff532924459948de0031396f9b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously creates a directory.  <a href="#ad7facff532924459948de0031396f9b5">More...</a><br /></td></tr>
<tr class="separator:ad7facff532924459948de0031396f9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0758295d049fe070dd235786775f777e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a0758295d049fe070dd235786775f777e">make_directory_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr class="memdesc:a0758295d049fe070dd235786775f777e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous directory creation, started with g_file_make_directory_async().  <a href="#a0758295d049fe070dd235786775f777e">More...</a><br /></td></tr>
<tr class="separator:a0758295d049fe070dd235786775f777e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0b5b094339057b4b15952eb73e08d6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#afb0b5b094339057b4b15952eb73e08d6">make_directory_with_parents</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:afb0b5b094339057b4b15952eb73e08d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a directory and any parent directories that may not exist similar to 'mkdir -p'.  <a href="#afb0b5b094339057b4b15952eb73e08d6">More...</a><br /></td></tr>
<tr class="separator:afb0b5b094339057b4b15952eb73e08d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a874a487551d49ca62b31a3e5cf32fee6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a874a487551d49ca62b31a3e5cf32fee6">make_directory_with_parents</a> ()</td></tr>
<tr class="memdesc:a874a487551d49ca62b31a3e5cf32fee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classGio_1_1File.html#a874a487551d49ca62b31a3e5cf32fee6" title="A make_directory_with_parents() convenience overload. ">make_directory_with_parents()</a> convenience overload.  <a href="#a874a487551d49ca62b31a3e5cf32fee6">More...</a><br /></td></tr>
<tr class="separator:a874a487551d49ca62b31a3e5cf32fee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2709318e1f24dfd0cd498d28f5e1b8fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a2709318e1f24dfd0cd498d28f5e1b8fe">make_symbolic_link</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; symlink_value, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:a2709318e1f24dfd0cd498d28f5e1b8fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a symbolic link.  <a href="#a2709318e1f24dfd0cd498d28f5e1b8fe">More...</a><br /></td></tr>
<tr class="separator:a2709318e1f24dfd0cd498d28f5e1b8fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a9a3d060c2675ff9ac1c758f0b2c024"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a8a9a3d060c2675ff9ac1c758f0b2c024">make_symbolic_link</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; symlink_value)</td></tr>
<tr class="memdesc:a8a9a3d060c2675ff9ac1c758f0b2c024"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classGio_1_1File.html#a2709318e1f24dfd0cd498d28f5e1b8fe" title="Creates a symbolic link. ">make_symbolic_link()</a> convenience overload.  <a href="#a8a9a3d060c2675ff9ac1c758f0b2c024">More...</a><br /></td></tr>
<tr class="separator:a8a9a3d060c2675ff9ac1c758f0b2c024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a543339b58cff6a7e5ddd840df0e69e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileAttributeInfoList.html">FileAttributeInfoList</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a4a543339b58cff6a7e5ddd840df0e69e">query_settable_attributes</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:a4a543339b58cff6a7e5ddd840df0e69e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the list of settable attributes for the file.  <a href="#a4a543339b58cff6a7e5ddd840df0e69e">More...</a><br /></td></tr>
<tr class="separator:a4a543339b58cff6a7e5ddd840df0e69e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae03d0652bcfbad2f47409b8f815bc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileAttributeInfoList.html">FileAttributeInfoList</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a1ae03d0652bcfbad2f47409b8f815bc4">query_settable_attributes</a> ()</td></tr>
<tr class="memdesc:a1ae03d0652bcfbad2f47409b8f815bc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classGio_1_1File.html#a1ae03d0652bcfbad2f47409b8f815bc4" title="A query_settable_attributes() convenience overload. ">query_settable_attributes()</a> convenience overload.  <a href="#a1ae03d0652bcfbad2f47409b8f815bc4">More...</a><br /></td></tr>
<tr class="separator:a1ae03d0652bcfbad2f47409b8f815bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c7463b92e2887597486e7b195ca12f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileAttributeInfoList.html">FileAttributeInfoList</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#af5c7463b92e2887597486e7b195ca12f">query_writable_namespaces</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:af5c7463b92e2887597486e7b195ca12f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain the list of attribute namespaces where new attributes can be created by a user.  <a href="#af5c7463b92e2887597486e7b195ca12f">More...</a><br /></td></tr>
<tr class="separator:af5c7463b92e2887597486e7b195ca12f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0278acd7d09ed292359004defb742b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileAttributeInfoList.html">FileAttributeInfoList</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aa0278acd7d09ed292359004defb742b0">query_writable_namespaces</a> ()</td></tr>
<tr class="memdesc:aa0278acd7d09ed292359004defb742b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classGio_1_1File.html#aa0278acd7d09ed292359004defb742b0" title="A query_writable_namespaces() convenience overload. ">query_writable_namespaces()</a> convenience overload.  <a href="#aa0278acd7d09ed292359004defb742b0">More...</a><br /></td></tr>
<tr class="separator:aa0278acd7d09ed292359004defb742b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d9e40a85b96809abc5189b34e8d9b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a69d9e40a85b96809abc5189b34e8d9b7">set_attributes_from_info</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&amp; info, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags=<a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0a4e412b5c20ae24607975e36b1d2142c9">FILE_QUERY_INFO_NONE</a>)</td></tr>
<tr class="memdesc:a69d9e40a85b96809abc5189b34e8d9b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to set all attributes in the <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes. ">FileInfo</a> on the target values, not stopping on the first error.  <a href="#a69d9e40a85b96809abc5189b34e8d9b7">More...</a><br /></td></tr>
<tr class="separator:a69d9e40a85b96809abc5189b34e8d9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f6975ffef28f0d7145601a99de0903"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ae9f6975ffef28f0d7145601a99de0903">set_attributes_from_info</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&amp; info, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags=<a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0a4e412b5c20ae24607975e36b1d2142c9">FILE_QUERY_INFO_NONE</a>)</td></tr>
<tr class="memdesc:ae9f6975ffef28f0d7145601a99de0903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to set all attributes in the <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes. ">FileInfo</a> on the target values, not stopping on the first error.  <a href="#ae9f6975ffef28f0d7145601a99de0903">More...</a><br /></td></tr>
<tr class="separator:ae9f6975ffef28f0d7145601a99de0903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14165fba9bf7d91448c3207407ae50c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a14165fba9bf7d91448c3207407ae50c2">set_attributes_async</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&amp; info, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags=<a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0a4e412b5c20ae24607975e36b1d2142c9">FILE_QUERY_INFO_NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:a14165fba9bf7d91448c3207407ae50c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously sets the attributes of file with info.  <a href="#a14165fba9bf7d91448c3207407ae50c2">More...</a><br /></td></tr>
<tr class="separator:a14165fba9bf7d91448c3207407ae50c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61317a1980318537aa8ada7bb8cc2390"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a61317a1980318537aa8ada7bb8cc2390">set_attributes_async</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&amp; info, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags=<a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0a4e412b5c20ae24607975e36b1d2142c9">FILE_QUERY_INFO_NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:a61317a1980318537aa8ada7bb8cc2390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously sets the attributes of file with info.  <a href="#a61317a1980318537aa8ada7bb8cc2390">More...</a><br /></td></tr>
<tr class="separator:a61317a1980318537aa8ada7bb8cc2390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd45aed7b975b6e204e67927de2817a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aefd45aed7b975b6e204e67927de2817a">set_attributes_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&amp; info)</td></tr>
<tr class="separator:aefd45aed7b975b6e204e67927de2817a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce5f43fd5e2836ac1989a54d3233ff6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a5ce5f43fd5e2836ac1989a54d3233ff6">set_attribute_string</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attribute, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; value, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:a5ce5f43fd5e2836ac1989a54d3233ff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_STRING to <em>value</em>.  <a href="#a5ce5f43fd5e2836ac1989a54d3233ff6">More...</a><br /></td></tr>
<tr class="separator:a5ce5f43fd5e2836ac1989a54d3233ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75fa7e1a44e97a910d232f2b4ab4bfdd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a75fa7e1a44e97a910d232f2b4ab4bfdd">set_attribute_string</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attribute, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; value, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags)</td></tr>
<tr class="memdesc:a75fa7e1a44e97a910d232f2b4ab4bfdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classGio_1_1File.html#a5ce5f43fd5e2836ac1989a54d3233ff6" title="Sets attribute of type FILE_ATTRIBUTE_TYPE_STRING to value. ">set_attribute_string()</a> convenience overload.  <a href="#a75fa7e1a44e97a910d232f2b4ab4bfdd">More...</a><br /></td></tr>
<tr class="separator:a75fa7e1a44e97a910d232f2b4ab4bfdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f4373b8694c346a6908195f1f2644f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a4f4373b8694c346a6908195f1f2644f3">set_attribute_byte_string</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attribute, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; value, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:a4f4373b8694c346a6908195f1f2644f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_BYTE_STRING to <em>value</em>.  <a href="#a4f4373b8694c346a6908195f1f2644f3">More...</a><br /></td></tr>
<tr class="separator:a4f4373b8694c346a6908195f1f2644f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f574259052186e1b516bdcbe696710"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a09f574259052186e1b516bdcbe696710">set_attribute_byte_string</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attribute, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; value, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags)</td></tr>
<tr class="memdesc:a09f574259052186e1b516bdcbe696710"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classGio_1_1File.html#a4f4373b8694c346a6908195f1f2644f3" title="Sets attribute of type FILE_ATTRIBUTE_TYPE_BYTE_STRING to value. ">set_attribute_byte_string()</a> convenience overload.  <a href="#a09f574259052186e1b516bdcbe696710">More...</a><br /></td></tr>
<tr class="separator:a09f574259052186e1b516bdcbe696710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53b0f4d2214e050a290c8e35cac0f27"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ae53b0f4d2214e050a290c8e35cac0f27">set_attribute_uint32</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attribute, guint32 value, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:ae53b0f4d2214e050a290c8e35cac0f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_UINT32 to <em>value</em>.  <a href="#ae53b0f4d2214e050a290c8e35cac0f27">More...</a><br /></td></tr>
<tr class="separator:ae53b0f4d2214e050a290c8e35cac0f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f769f140143f2e96a7587a10b6792a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a7f769f140143f2e96a7587a10b6792a9">set_attribute_uint32</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attribute, guint32 value, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags)</td></tr>
<tr class="memdesc:a7f769f140143f2e96a7587a10b6792a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classGio_1_1File.html#ae53b0f4d2214e050a290c8e35cac0f27" title="Sets attribute of type FILE_ATTRIBUTE_TYPE_UINT32 to value. ">set_attribute_uint32()</a> convenience overload.  <a href="#a7f769f140143f2e96a7587a10b6792a9">More...</a><br /></td></tr>
<tr class="separator:a7f769f140143f2e96a7587a10b6792a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0290ecba7b06ccf7736e2292708667e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ab0290ecba7b06ccf7736e2292708667e">set_attribute_int32</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attribute, gint32 value, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:ab0290ecba7b06ccf7736e2292708667e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_INT32 to <em>value</em>.  <a href="#ab0290ecba7b06ccf7736e2292708667e">More...</a><br /></td></tr>
<tr class="separator:ab0290ecba7b06ccf7736e2292708667e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a707084a3c0a963548a21d17d0ec0b5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a4a707084a3c0a963548a21d17d0ec0b5">set_attribute_int32</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attribute, gint32 value, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags)</td></tr>
<tr class="memdesc:a4a707084a3c0a963548a21d17d0ec0b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classGio_1_1File.html#ab0290ecba7b06ccf7736e2292708667e" title="Sets attribute of type FILE_ATTRIBUTE_TYPE_INT32 to value. ">set_attribute_int32()</a> convenience overload.  <a href="#a4a707084a3c0a963548a21d17d0ec0b5">More...</a><br /></td></tr>
<tr class="separator:a4a707084a3c0a963548a21d17d0ec0b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48638081fd7af772a39af59a558b17f7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a48638081fd7af772a39af59a558b17f7">set_attribute_uint64</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attribute, guint64 value, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:a48638081fd7af772a39af59a558b17f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_UINT64 to <em>value</em>.  <a href="#a48638081fd7af772a39af59a558b17f7">More...</a><br /></td></tr>
<tr class="separator:a48638081fd7af772a39af59a558b17f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa77b3580df88cfd3d7231af78155c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a4aa77b3580df88cfd3d7231af78155c7">set_attribute_uint64</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attribute, guint64 value, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags)</td></tr>
<tr class="memdesc:a4aa77b3580df88cfd3d7231af78155c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classGio_1_1File.html#a48638081fd7af772a39af59a558b17f7" title="Sets attribute of type FILE_ATTRIBUTE_TYPE_UINT64 to value. ">set_attribute_uint64()</a> convenience overload.  <a href="#a4aa77b3580df88cfd3d7231af78155c7">More...</a><br /></td></tr>
<tr class="separator:a4aa77b3580df88cfd3d7231af78155c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a111d73a2d003e5a5a4c5f86c7c3d2fb7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a111d73a2d003e5a5a4c5f86c7c3d2fb7">set_attribute_int64</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attribute, gint64 value, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:a111d73a2d003e5a5a4c5f86c7c3d2fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_INT64 to <em>value</em>.  <a href="#a111d73a2d003e5a5a4c5f86c7c3d2fb7">More...</a><br /></td></tr>
<tr class="separator:a111d73a2d003e5a5a4c5f86c7c3d2fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4477b0063110951b26c855696ec34802"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a4477b0063110951b26c855696ec34802">set_attribute_int64</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; attribute, gint64 value, <a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a> flags)</td></tr>
<tr class="memdesc:a4477b0063110951b26c855696ec34802"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classGio_1_1File.html#a111d73a2d003e5a5a4c5f86c7c3d2fb7" title="Sets attribute of type FILE_ATTRIBUTE_TYPE_INT64 to value. ">set_attribute_int64()</a> convenience overload.  <a href="#a4477b0063110951b26c855696ec34802">More...</a><br /></td></tr>
<tr class="separator:a4477b0063110951b26c855696ec34802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144aa2de6b696da90a6baffbe959d732"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a144aa2de6b696da90a6baffbe959d732">mount_enclosing_volume</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; mount_operation, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga5484bace25c932fd4c7354259e138814">MountMountFlags</a> flags=<a class="el" href="namespaceGio.html#ga5484bace25c932fd4c7354259e138814a73c8f98eedd8a952ae25a55533dc145d">MOUNT_MOUNT_NONE</a>)</td></tr>
<tr class="memdesc:a144aa2de6b696da90a6baffbe959d732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a <em>mount_operation</em>, mounting the volume that contains the file.  <a href="#a144aa2de6b696da90a6baffbe959d732">More...</a><br /></td></tr>
<tr class="separator:a144aa2de6b696da90a6baffbe959d732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70fd22116d9c8682433c4bb8cbd764c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a70fd22116d9c8682433c4bb8cbd764c1">mount_enclosing_volume</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; mount_operation, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, <a class="el" href="group__giommEnums.html#ga5484bace25c932fd4c7354259e138814">MountMountFlags</a> flags=<a class="el" href="namespaceGio.html#ga5484bace25c932fd4c7354259e138814a73c8f98eedd8a952ae25a55533dc145d">MOUNT_MOUNT_NONE</a>)</td></tr>
<tr class="memdesc:a70fd22116d9c8682433c4bb8cbd764c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a <em>mount_operation</em>, mounting the volume that contains the file.  <a href="#a70fd22116d9c8682433c4bb8cbd764c1">More...</a><br /></td></tr>
<tr class="separator:a70fd22116d9c8682433c4bb8cbd764c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2172cdcdb683630b719c521bf00b1eb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a2172cdcdb683630b719c521bf00b1eb4">mount_enclosing_volume</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, <a class="el" href="group__giommEnums.html#ga5484bace25c932fd4c7354259e138814">MountMountFlags</a> flags=<a class="el" href="namespaceGio.html#ga5484bace25c932fd4c7354259e138814a73c8f98eedd8a952ae25a55533dc145d">MOUNT_MOUNT_NONE</a>)</td></tr>
<tr class="memdesc:a2172cdcdb683630b719c521bf00b1eb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a <em>mount_operation</em>, mounting the volume that contains the file.  <a href="#a2172cdcdb683630b719c521bf00b1eb4">More...</a><br /></td></tr>
<tr class="separator:a2172cdcdb683630b719c521bf00b1eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20f8f18876102a5efaa0536bfa71d71c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a20f8f18876102a5efaa0536bfa71d71c">mount_enclosing_volume</a> (<a class="el" href="group__giommEnums.html#ga5484bace25c932fd4c7354259e138814">MountMountFlags</a> flags=<a class="el" href="namespaceGio.html#ga5484bace25c932fd4c7354259e138814a73c8f98eedd8a952ae25a55533dc145d">MOUNT_MOUNT_NONE</a>)</td></tr>
<tr class="memdesc:a20f8f18876102a5efaa0536bfa71d71c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a <em>mount_operation</em>, mounting the volume that contains the file.  <a href="#a20f8f18876102a5efaa0536bfa71d71c">More...</a><br /></td></tr>
<tr class="separator:a20f8f18876102a5efaa0536bfa71d71c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd44b1b3467bcc474b345ff98b4aa6d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aefd44b1b3467bcc474b345ff98b4aa6d">mount_enclosing_volume_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr class="memdesc:aefd44b1b3467bcc474b345ff98b4aa6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes a mount operation started by g_file_mount_enclosing_volume().  <a href="#aefd44b1b3467bcc474b345ff98b4aa6d">More...</a><br /></td></tr>
<tr class="separator:aefd44b1b3467bcc474b345ff98b4aa6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c88a403f5d01d722b5900545b6a4fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a40c88a403f5d01d722b5900545b6a4fe">mount_mountable</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; mount_operation, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga5484bace25c932fd4c7354259e138814">MountMountFlags</a> flags=<a class="el" href="namespaceGio.html#ga5484bace25c932fd4c7354259e138814a73c8f98eedd8a952ae25a55533dc145d">MOUNT_MOUNT_NONE</a>)</td></tr>
<tr class="memdesc:a40c88a403f5d01d722b5900545b6a4fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mounts a file of type FILE_TYPE_MOUNTABLE.  <a href="#a40c88a403f5d01d722b5900545b6a4fe">More...</a><br /></td></tr>
<tr class="separator:a40c88a403f5d01d722b5900545b6a4fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c29682ef5a50de73dc2c3c3333301c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ac3c29682ef5a50de73dc2c3c3333301c">mount_mountable</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; mount_operation, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, <a class="el" href="group__giommEnums.html#ga5484bace25c932fd4c7354259e138814">MountMountFlags</a> flags=<a class="el" href="namespaceGio.html#ga5484bace25c932fd4c7354259e138814a73c8f98eedd8a952ae25a55533dc145d">MOUNT_MOUNT_NONE</a>)</td></tr>
<tr class="memdesc:ac3c29682ef5a50de73dc2c3c3333301c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mounts a file of type FILE_TYPE_MOUNTABLE.  <a href="#ac3c29682ef5a50de73dc2c3c3333301c">More...</a><br /></td></tr>
<tr class="separator:ac3c29682ef5a50de73dc2c3c3333301c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049e06c3d95b49ad4bff1837ef6d8677"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a049e06c3d95b49ad4bff1837ef6d8677">mount_mountable</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, <a class="el" href="group__giommEnums.html#ga5484bace25c932fd4c7354259e138814">MountMountFlags</a> flags=<a class="el" href="namespaceGio.html#ga5484bace25c932fd4c7354259e138814a73c8f98eedd8a952ae25a55533dc145d">MOUNT_MOUNT_NONE</a>)</td></tr>
<tr class="memdesc:a049e06c3d95b49ad4bff1837ef6d8677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mounts a file of type FILE_TYPE_MOUNTABLE without user interaction.  <a href="#a049e06c3d95b49ad4bff1837ef6d8677">More...</a><br /></td></tr>
<tr class="separator:a049e06c3d95b49ad4bff1837ef6d8677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8501fa88f4aaa8d52c001596960a4572"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a8501fa88f4aaa8d52c001596960a4572">mount_mountable</a> (<a class="el" href="group__giommEnums.html#ga5484bace25c932fd4c7354259e138814">MountMountFlags</a> flags=<a class="el" href="namespaceGio.html#ga5484bace25c932fd4c7354259e138814a73c8f98eedd8a952ae25a55533dc145d">MOUNT_MOUNT_NONE</a>)</td></tr>
<tr class="memdesc:a8501fa88f4aaa8d52c001596960a4572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mounts a file of type FILE_TYPE_MOUNTABLE without user interaction.  <a href="#a8501fa88f4aaa8d52c001596960a4572">More...</a><br /></td></tr>
<tr class="separator:a8501fa88f4aaa8d52c001596960a4572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae15d36a7969c55122b9f85a1690a46e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ae15d36a7969c55122b9f85a1690a46e8">mount_mountable_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr class="memdesc:ae15d36a7969c55122b9f85a1690a46e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes a mount operation.  <a href="#ae15d36a7969c55122b9f85a1690a46e8">More...</a><br /></td></tr>
<tr class="separator:ae15d36a7969c55122b9f85a1690a46e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b687c8f19411e955bb069c469be92b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a5b687c8f19411e955bb069c469be92b4">unmount_mountable</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a> flags=<a class="el" href="namespaceGio.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44a1599c4ebeb5c0c6e9c312a4b9e4231b6">MOUNT_UNMOUNT_NONE</a>)</td></tr>
<tr class="memdesc:a5b687c8f19411e955bb069c469be92b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmounts a file of type FILE_TYPE_MOUNTABLE.  <a href="#a5b687c8f19411e955bb069c469be92b4">More...</a><br /></td></tr>
<tr class="separator:a5b687c8f19411e955bb069c469be92b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c8e9ef0e5d83a271c8307b18e779d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ab6c8e9ef0e5d83a271c8307b18e779d8">unmount_mountable</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, <a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a> flags=<a class="el" href="namespaceGio.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44a1599c4ebeb5c0c6e9c312a4b9e4231b6">MOUNT_UNMOUNT_NONE</a>)</td></tr>
<tr class="memdesc:ab6c8e9ef0e5d83a271c8307b18e779d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmounts a file of type FILE_TYPE_MOUNTABLE.  <a href="#ab6c8e9ef0e5d83a271c8307b18e779d8">More...</a><br /></td></tr>
<tr class="separator:ab6c8e9ef0e5d83a271c8307b18e779d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f3e87e198493f4332a08aa79f6ebd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a95f3e87e198493f4332a08aa79f6ebd3">unmount_mountable</a> (<a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a> flags=<a class="el" href="namespaceGio.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44a1599c4ebeb5c0c6e9c312a4b9e4231b6">MOUNT_UNMOUNT_NONE</a>)</td></tr>
<tr class="memdesc:a95f3e87e198493f4332a08aa79f6ebd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmounts a file of type FILE_TYPE_MOUNTABLE.  <a href="#a95f3e87e198493f4332a08aa79f6ebd3">More...</a><br /></td></tr>
<tr class="separator:a95f3e87e198493f4332a08aa79f6ebd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f7cceb9754a7498789593dd58d818c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a13f7cceb9754a7498789593dd58d818c">unmount_mountable</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; mount_operation, <a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a> flags=<a class="el" href="namespaceGio.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44a1599c4ebeb5c0c6e9c312a4b9e4231b6">MOUNT_UNMOUNT_NONE</a>)</td></tr>
<tr class="memdesc:a13f7cceb9754a7498789593dd58d818c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmounts a file of type FILE_TYPE_MOUNTABLE.  <a href="#a13f7cceb9754a7498789593dd58d818c">More...</a><br /></td></tr>
<tr class="separator:a13f7cceb9754a7498789593dd58d818c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad82d5b087fef21cbadcb9407d7f43223"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ad82d5b087fef21cbadcb9407d7f43223">unmount_mountable</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; mount_operation, <a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a> flags=<a class="el" href="namespaceGio.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44a1599c4ebeb5c0c6e9c312a4b9e4231b6">MOUNT_UNMOUNT_NONE</a>)</td></tr>
<tr class="memdesc:ad82d5b087fef21cbadcb9407d7f43223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmounts a file of type FILE_TYPE_MOUNTABLE.  <a href="#ad82d5b087fef21cbadcb9407d7f43223">More...</a><br /></td></tr>
<tr class="separator:ad82d5b087fef21cbadcb9407d7f43223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae322b2d5f8f1d95023831c3964c9b015"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ae322b2d5f8f1d95023831c3964c9b015">unmount_mountable</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; mount_operation, <a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a> flags=<a class="el" href="namespaceGio.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44a1599c4ebeb5c0c6e9c312a4b9e4231b6">MOUNT_UNMOUNT_NONE</a>)</td></tr>
<tr class="memdesc:ae322b2d5f8f1d95023831c3964c9b015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmounts a file of type FILE_TYPE_MOUNTABLE.  <a href="#ae322b2d5f8f1d95023831c3964c9b015">More...</a><br /></td></tr>
<tr class="separator:ae322b2d5f8f1d95023831c3964c9b015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51458cf04ad25e4a784a3ebcb906155d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a51458cf04ad25e4a784a3ebcb906155d">unmount_mountable_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr class="memdesc:a51458cf04ad25e4a784a3ebcb906155d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an unmount operation, see g_file_unmount_mountable_with_operation() for details.  <a href="#a51458cf04ad25e4a784a3ebcb906155d">More...</a><br /></td></tr>
<tr class="separator:a51458cf04ad25e4a784a3ebcb906155d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a8223e3b661f03c7a60ac0f003b916e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a8a8223e3b661f03c7a60ac0f003b916e">eject_mountable</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a> flags=<a class="el" href="namespaceGio.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44a1599c4ebeb5c0c6e9c312a4b9e4231b6">MOUNT_UNMOUNT_NONE</a>)</td></tr>
<tr class="memdesc:a8a8223e3b661f03c7a60ac0f003b916e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts an asynchronous eject on a mountable.  <a href="#a8a8223e3b661f03c7a60ac0f003b916e">More...</a><br /></td></tr>
<tr class="separator:a8a8223e3b661f03c7a60ac0f003b916e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8422a939a634d2248ef6d8658f0fdad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ad8422a939a634d2248ef6d8658f0fdad">eject_mountable</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, <a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a> flags=<a class="el" href="namespaceGio.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44a1599c4ebeb5c0c6e9c312a4b9e4231b6">MOUNT_UNMOUNT_NONE</a>)</td></tr>
<tr class="memdesc:ad8422a939a634d2248ef6d8658f0fdad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts an asynchronous eject on a mountable.  <a href="#ad8422a939a634d2248ef6d8658f0fdad">More...</a><br /></td></tr>
<tr class="separator:ad8422a939a634d2248ef6d8658f0fdad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb28fd505cab23a82c68ff00445b12e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aeb28fd505cab23a82c68ff00445b12e7">eject_mountable</a> (<a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a> flags=<a class="el" href="namespaceGio.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44a1599c4ebeb5c0c6e9c312a4b9e4231b6">MOUNT_UNMOUNT_NONE</a>)</td></tr>
<tr class="memdesc:aeb28fd505cab23a82c68ff00445b12e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts an asynchronous eject on a mountable.  <a href="#aeb28fd505cab23a82c68ff00445b12e7">More...</a><br /></td></tr>
<tr class="separator:aeb28fd505cab23a82c68ff00445b12e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c103886296fd1ea1107906deebec8a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a1c103886296fd1ea1107906deebec8a5">eject_mountable</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; mount_operation, <a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a> flags=<a class="el" href="namespaceGio.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44a1599c4ebeb5c0c6e9c312a4b9e4231b6">MOUNT_UNMOUNT_NONE</a>)</td></tr>
<tr class="memdesc:a1c103886296fd1ea1107906deebec8a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts an asynchronous eject on a mountable.  <a href="#a1c103886296fd1ea1107906deebec8a5">More...</a><br /></td></tr>
<tr class="separator:a1c103886296fd1ea1107906deebec8a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c75952828023d27d109a3a23fafc00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ab6c75952828023d27d109a3a23fafc00">eject_mountable</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; mount_operation, <a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a> flags=<a class="el" href="namespaceGio.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44a1599c4ebeb5c0c6e9c312a4b9e4231b6">MOUNT_UNMOUNT_NONE</a>)</td></tr>
<tr class="memdesc:ab6c75952828023d27d109a3a23fafc00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts an asynchronous eject on a mountable.  <a href="#ab6c75952828023d27d109a3a23fafc00">More...</a><br /></td></tr>
<tr class="separator:ab6c75952828023d27d109a3a23fafc00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7aea22f6cb30b3f2be43682ddd543d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ab7aea22f6cb30b3f2be43682ddd543d9">eject_mountable</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; mount_operation, <a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a> flags=<a class="el" href="namespaceGio.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44a1599c4ebeb5c0c6e9c312a4b9e4231b6">MOUNT_UNMOUNT_NONE</a>)</td></tr>
<tr class="memdesc:ab7aea22f6cb30b3f2be43682ddd543d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts an asynchronous eject on a mountable.  <a href="#ab7aea22f6cb30b3f2be43682ddd543d9">More...</a><br /></td></tr>
<tr class="separator:ab7aea22f6cb30b3f2be43682ddd543d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5124de7c55e9dc5e85ffcb9d3dd14f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a6a5124de7c55e9dc5e85ffcb9d3dd14f">eject_mountable_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr class="memdesc:a6a5124de7c55e9dc5e85ffcb9d3dd14f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous eject operation started by g_file_eject_mountable_with_operation().  <a href="#a6a5124de7c55e9dc5e85ffcb9d3dd14f">More...</a><br /></td></tr>
<tr class="separator:a6a5124de7c55e9dc5e85ffcb9d3dd14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90726dcf94248d2fddf2e4c8584b7bf0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a90726dcf94248d2fddf2e4c8584b7bf0">copy_attributes</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; destination, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a> flags=<a class="el" href="namespaceGio.html#ga08edc09a45449b136b27493647d4ecbea74324723d31670f9d554d43d4d21cba9">FILE_COPY_NONE</a>)</td></tr>
<tr class="memdesc:a90726dcf94248d2fddf2e4c8584b7bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the file attributes from <em>source</em> to <em>destination</em>.  <a href="#a90726dcf94248d2fddf2e4c8584b7bf0">More...</a><br /></td></tr>
<tr class="separator:a90726dcf94248d2fddf2e4c8584b7bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c1101ede98028c9234486eb0434250"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a05c1101ede98028c9234486eb0434250">copy_attributes</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp; destination, <a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a> flags=<a class="el" href="namespaceGio.html#ga08edc09a45449b136b27493647d4ecbea74324723d31670f9d554d43d4d21cba9">FILE_COPY_NONE</a>)</td></tr>
<tr class="memdesc:a05c1101ede98028c9234486eb0434250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the file attributes from <em>source</em> to <em>destination</em>.  <a href="#a05c1101ede98028c9234486eb0434250">More...</a><br /></td></tr>
<tr class="separator:a05c1101ede98028c9234486eb0434250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0fa22ffba0ff50779e49ff9d12344e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileMonitor.html">FileMonitor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aa0fa22ffba0ff50779e49ff9d12344e6">monitor_directory</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga469f795e9a4dddb2421c0e5568be6649">FileMonitorFlags</a> flags=<a class="el" href="namespaceGio.html#ga469f795e9a4dddb2421c0e5568be6649adedf14a2a5916e81bc91e6174b400290">FILE_MONITOR_NONE</a>)</td></tr>
<tr class="memdesc:aa0fa22ffba0ff50779e49ff9d12344e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a directory monitor for the given file.  <a href="#aa0fa22ffba0ff50779e49ff9d12344e6">More...</a><br /></td></tr>
<tr class="separator:aa0fa22ffba0ff50779e49ff9d12344e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d36689c1024ff9fc8819f619910a92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileMonitor.html">FileMonitor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a12d36689c1024ff9fc8819f619910a92">monitor_directory</a> (<a class="el" href="group__giommEnums.html#ga469f795e9a4dddb2421c0e5568be6649">FileMonitorFlags</a> flags=<a class="el" href="namespaceGio.html#ga469f795e9a4dddb2421c0e5568be6649adedf14a2a5916e81bc91e6174b400290">FILE_MONITOR_NONE</a>)</td></tr>
<tr class="memdesc:a12d36689c1024ff9fc8819f619910a92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a directory monitor for the given file.  <a href="#a12d36689c1024ff9fc8819f619910a92">More...</a><br /></td></tr>
<tr class="separator:a12d36689c1024ff9fc8819f619910a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e14809f330ddd58e628c96921cd987"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileMonitor.html">FileMonitor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ab8e14809f330ddd58e628c96921cd987">monitor_file</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga469f795e9a4dddb2421c0e5568be6649">FileMonitorFlags</a> flags=<a class="el" href="namespaceGio.html#ga469f795e9a4dddb2421c0e5568be6649adedf14a2a5916e81bc91e6174b400290">FILE_MONITOR_NONE</a>)</td></tr>
<tr class="memdesc:ab8e14809f330ddd58e628c96921cd987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a file monitor for the given file.  <a href="#ab8e14809f330ddd58e628c96921cd987">More...</a><br /></td></tr>
<tr class="separator:ab8e14809f330ddd58e628c96921cd987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa410183ed3b4a745093383d038d271b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileMonitor.html">FileMonitor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aa410183ed3b4a745093383d038d271b9">monitor_file</a> (<a class="el" href="group__giommEnums.html#ga469f795e9a4dddb2421c0e5568be6649">FileMonitorFlags</a> flags=<a class="el" href="namespaceGio.html#ga469f795e9a4dddb2421c0e5568be6649adedf14a2a5916e81bc91e6174b400290">FILE_MONITOR_NONE</a>)</td></tr>
<tr class="memdesc:aa410183ed3b4a745093383d038d271b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a file monitor for the given file.  <a href="#aa410183ed3b4a745093383d038d271b9">More...</a><br /></td></tr>
<tr class="separator:aa410183ed3b4a745093383d038d271b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88aacee7bb6f6d968b4383311a9dd002"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileMonitor.html">FileMonitor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a88aacee7bb6f6d968b4383311a9dd002">monitor</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, <a class="el" href="group__giommEnums.html#ga469f795e9a4dddb2421c0e5568be6649">FileMonitorFlags</a> flags=<a class="el" href="namespaceGio.html#ga469f795e9a4dddb2421c0e5568be6649adedf14a2a5916e81bc91e6174b400290">FILE_MONITOR_NONE</a>)</td></tr>
<tr class="memdesc:a88aacee7bb6f6d968b4383311a9dd002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a file monitor for the given file.  <a href="#a88aacee7bb6f6d968b4383311a9dd002">More...</a><br /></td></tr>
<tr class="separator:a88aacee7bb6f6d968b4383311a9dd002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50896969a9de87f810f0bf5e2d3335bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileMonitor.html">FileMonitor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a50896969a9de87f810f0bf5e2d3335bd">monitor</a> (<a class="el" href="group__giommEnums.html#ga469f795e9a4dddb2421c0e5568be6649">FileMonitorFlags</a> flags=<a class="el" href="namespaceGio.html#ga469f795e9a4dddb2421c0e5568be6649adedf14a2a5916e81bc91e6174b400290">FILE_MONITOR_NONE</a>)</td></tr>
<tr class="memdesc:a50896969a9de87f810f0bf5e2d3335bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtains a file monitor for the given file.  <a href="#a50896969a9de87f810f0bf5e2d3335bd">More...</a><br /></td></tr>
<tr class="separator:a50896969a9de87f810f0bf5e2d3335bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27d273c8119ef09426405e35f75e533e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a27d273c8119ef09426405e35f75e533e">measure_disk_usage</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="el" href="classGio_1_1File.html#a6bb470935903b3745b2c8bcca1f40536">SlotFileMeasureProgress</a>&amp; slot_progress, guint64&amp; disk_usage, guint64&amp; num_dirs, guint64&amp; num_files, <a class="el" href="group__giommEnums.html#ga3d27573e797e8e78e7b71705ad015ced">FileMeasureFlags</a> flags=<a class="el" href="namespaceGio.html#ga3d27573e797e8e78e7b71705ad015ceda96dacae2624b3093efe929aed02cbca3">FILE_MEASURE_NONE</a>)</td></tr>
<tr class="memdesc:a27d273c8119ef09426405e35f75e533e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively measures the disk usage of the file.  <a href="#a27d273c8119ef09426405e35f75e533e">More...</a><br /></td></tr>
<tr class="separator:a27d273c8119ef09426405e35f75e533e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ebd8baacbbdf12f1b34fca92b4c8f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a85ebd8baacbbdf12f1b34fca92b4c8f2">measure_disk_usage_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot_ready, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="el" href="classGio_1_1File.html#a6bb470935903b3745b2c8bcca1f40536">SlotFileMeasureProgress</a>&amp; slot_progress, <a class="el" href="group__giommEnums.html#ga3d27573e797e8e78e7b71705ad015ced">FileMeasureFlags</a> flags=<a class="el" href="namespaceGio.html#ga3d27573e797e8e78e7b71705ad015ceda96dacae2624b3093efe929aed02cbca3">FILE_MEASURE_NONE</a>, int io_priority=<a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a>)</td></tr>
<tr class="memdesc:a85ebd8baacbbdf12f1b34fca92b4c8f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively measures the disk usage of the file.  <a href="#a85ebd8baacbbdf12f1b34fca92b4c8f2">More...</a><br /></td></tr>
<tr class="separator:a85ebd8baacbbdf12f1b34fca92b4c8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5463283f6a20c51d4db7943190350d26"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a5463283f6a20c51d4db7943190350d26">measure_disk_usage_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result, guint64&amp; disk_usage, guint64&amp; num_dirs, guint64&amp; num_files)</td></tr>
<tr class="memdesc:a5463283f6a20c51d4db7943190350d26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects the results from an earlier call to g_file_measure_disk_usage_async().  <a href="#a5463283f6a20c51d4db7943190350d26">More...</a><br /></td></tr>
<tr class="separator:a5463283f6a20c51d4db7943190350d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4438daeeb2171e3065bb677b6768721"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aa4438daeeb2171e3065bb677b6768721">start_mountable</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; start_operation, <a class="el" href="group__giommEnums.html#gab628e70b1d028b3bc9b02b0d3b8acf2d">DriveStartFlags</a> flags=<a class="el" href="namespaceGio.html#gab628e70b1d028b3bc9b02b0d3b8acf2da9fe888bc06249b6238868b8fffa4c9cd">DRIVE_START_NONE</a>)</td></tr>
<tr class="memdesc:aa4438daeeb2171e3065bb677b6768721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a file of type Mountable.  <a href="#aa4438daeeb2171e3065bb677b6768721">More...</a><br /></td></tr>
<tr class="separator:aa4438daeeb2171e3065bb677b6768721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad629eaf059b2e05b1f9bfc10c5732974"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ad629eaf059b2e05b1f9bfc10c5732974">start_mountable</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; start_operation, <a class="el" href="group__giommEnums.html#gab628e70b1d028b3bc9b02b0d3b8acf2d">DriveStartFlags</a> flags=<a class="el" href="namespaceGio.html#gab628e70b1d028b3bc9b02b0d3b8acf2da9fe888bc06249b6238868b8fffa4c9cd">DRIVE_START_NONE</a>)</td></tr>
<tr class="memdesc:ad629eaf059b2e05b1f9bfc10c5732974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a file of type Mountable.  <a href="#ad629eaf059b2e05b1f9bfc10c5732974">More...</a><br /></td></tr>
<tr class="separator:ad629eaf059b2e05b1f9bfc10c5732974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af11e51943807876180474b39d2e521ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#af11e51943807876180474b39d2e521ac">start_mountable_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr class="memdesc:af11e51943807876180474b39d2e521ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes a start operation.  <a href="#af11e51943807876180474b39d2e521ac">More...</a><br /></td></tr>
<tr class="separator:af11e51943807876180474b39d2e521ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac101831f87245a881c338014f15d38d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ac101831f87245a881c338014f15d38d8">stop_mountable</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; start_operation, <a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a> flags=<a class="el" href="namespaceGio.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44a1599c4ebeb5c0c6e9c312a4b9e4231b6">MOUNT_UNMOUNT_NONE</a>)</td></tr>
<tr class="memdesc:ac101831f87245a881c338014f15d38d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops a file of type Mountable.  <a href="#ac101831f87245a881c338014f15d38d8">More...</a><br /></td></tr>
<tr class="separator:ac101831f87245a881c338014f15d38d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ccfb3006c2bc69a32e5055939b462d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a5ccfb3006c2bc69a32e5055939b462d6">stop_mountable</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp; start_operation, <a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a> flags=<a class="el" href="namespaceGio.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44a1599c4ebeb5c0c6e9c312a4b9e4231b6">MOUNT_UNMOUNT_NONE</a>)</td></tr>
<tr class="memdesc:a5ccfb3006c2bc69a32e5055939b462d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops a file of type Mountable.  <a href="#a5ccfb3006c2bc69a32e5055939b462d6">More...</a><br /></td></tr>
<tr class="separator:a5ccfb3006c2bc69a32e5055939b462d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a195990af8825745d0d26147174824565"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a195990af8825745d0d26147174824565">stop_mountable_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr class="memdesc:a195990af8825745d0d26147174824565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an stop operation, see g_file_stop_mountable() for details.  <a href="#a195990af8825745d0d26147174824565">More...</a><br /></td></tr>
<tr class="separator:a195990af8825745d0d26147174824565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e81dd0bab13e56ed98456f6a53591ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a8e81dd0bab13e56ed98456f6a53591ca">poll_mountable</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:a8e81dd0bab13e56ed98456f6a53591ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polls a file of type Mountable.  <a href="#a8e81dd0bab13e56ed98456f6a53591ca">More...</a><br /></td></tr>
<tr class="separator:a8e81dd0bab13e56ed98456f6a53591ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2025339de9d7ed9b62300cad1a8e8fd4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a2025339de9d7ed9b62300cad1a8e8fd4">poll_mountable</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot)</td></tr>
<tr class="memdesc:a2025339de9d7ed9b62300cad1a8e8fd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Polls a file of type Mountable.  <a href="#a2025339de9d7ed9b62300cad1a8e8fd4">More...</a><br /></td></tr>
<tr class="separator:a2025339de9d7ed9b62300cad1a8e8fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da5ec13a4a32f229ca97cce8961e637"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a2da5ec13a4a32f229ca97cce8961e637">poll_mountable_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr class="memdesc:a2da5ec13a4a32f229ca97cce8961e637"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes a poll operation.  <a href="#a2da5ec13a4a32f229ca97cce8961e637">More...</a><br /></td></tr>
<tr class="separator:a2da5ec13a4a32f229ca97cce8961e637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a753546465735b25633b003333b66d05c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AppInfo.html">AppInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a753546465735b25633b003333b66d05c">query_default_handler</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:a753546465735b25633b003333b66d05c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="classGio_1_1AppInfo.html" title="Application information, to describe applications installed on the system, and launch them...">AppInfo</a> that is registered as the default application to handle the file specified by <em>file</em>.  <a href="#a753546465735b25633b003333b66d05c">More...</a><br /></td></tr>
<tr class="separator:a753546465735b25633b003333b66d05c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c0fd0ece2570b6704889df5ee43c283"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AppInfo.html">AppInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a0c0fd0ece2570b6704889df5ee43c283">query_default_handler</a> ()</td></tr>
<tr class="memdesc:a0c0fd0ece2570b6704889df5ee43c283"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classGio_1_1File.html#a0c0fd0ece2570b6704889df5ee43c283" title="A query_default_handler() convenience overload. ">query_default_handler()</a> convenience overload.  <a href="#a0c0fd0ece2570b6704889df5ee43c283">More...</a><br /></td></tr>
<tr class="separator:a0c0fd0ece2570b6704889df5ee43c283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac53be228d732b34e062a2a57814cdf15"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ac53be228d732b34e062a2a57814cdf15">load_contents</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, char*&amp; contents, gsize&amp; length, <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag_out)</td></tr>
<tr class="memdesc:ac53be228d732b34e062a2a57814cdf15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the content of the file into memory, returning the size of the data.  <a href="#ac53be228d732b34e062a2a57814cdf15">More...</a><br /></td></tr>
<tr class="separator:ac53be228d732b34e062a2a57814cdf15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7c826a417f88b405244c8dc39ae1ef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ada7c826a417f88b405244c8dc39ae1ef">load_contents</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, char*&amp; contents, gsize&amp; length)</td></tr>
<tr class="memdesc:ada7c826a417f88b405244c8dc39ae1ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the content of the file into memory, returning the size of the data.  <a href="#ada7c826a417f88b405244c8dc39ae1ef">More...</a><br /></td></tr>
<tr class="separator:ada7c826a417f88b405244c8dc39ae1ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f7781b0ba65bc4e7e613b80b353fd7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a77f7781b0ba65bc4e7e613b80b353fd7">load_contents</a> (char*&amp; contents, gsize&amp; length, <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag_out)</td></tr>
<tr class="memdesc:a77f7781b0ba65bc4e7e613b80b353fd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the content of the file into memory, returning the size of the data.  <a href="#a77f7781b0ba65bc4e7e613b80b353fd7">More...</a><br /></td></tr>
<tr class="separator:a77f7781b0ba65bc4e7e613b80b353fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f3ce7cf905144bac7218f9988d2d35"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a40f3ce7cf905144bac7218f9988d2d35">load_contents</a> (char*&amp; contents, gsize&amp; length)</td></tr>
<tr class="memdesc:a40f3ce7cf905144bac7218f9988d2d35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads the content of the file into memory, returning the size of the data.  <a href="#a40f3ce7cf905144bac7218f9988d2d35">More...</a><br /></td></tr>
<tr class="separator:a40f3ce7cf905144bac7218f9988d2d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0e02ebffbaa13036e4636d2118f71a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ad0e02ebffbaa13036e4636d2118f71a0">load_contents_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:ad0e02ebffbaa13036e4636d2118f71a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts an asynchronous load of the file's contents.  <a href="#ad0e02ebffbaa13036e4636d2118f71a0">More...</a><br /></td></tr>
<tr class="separator:ad0e02ebffbaa13036e4636d2118f71a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6af7ec98d5543bce07b917b65d7276ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a6af7ec98d5543bce07b917b65d7276ce">load_contents_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot)</td></tr>
<tr class="memdesc:a6af7ec98d5543bce07b917b65d7276ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts an asynchronous load of the file's contents.  <a href="#a6af7ec98d5543bce07b917b65d7276ce">More...</a><br /></td></tr>
<tr class="separator:a6af7ec98d5543bce07b917b65d7276ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd15277ab90bcc57db088be04cac457"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a5fd15277ab90bcc57db088be04cac457">load_contents_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result, char*&amp; contents, gsize&amp; length, <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag_out)</td></tr>
<tr class="memdesc:a5fd15277ab90bcc57db088be04cac457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous load of the <em>file's</em> contents.  <a href="#a5fd15277ab90bcc57db088be04cac457">More...</a><br /></td></tr>
<tr class="separator:a5fd15277ab90bcc57db088be04cac457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee93c7e24e8391615f9f263584fb02bd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aee93c7e24e8391615f9f263584fb02bd">load_contents_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result, char*&amp; contents, gsize&amp; length)</td></tr>
<tr class="memdesc:aee93c7e24e8391615f9f263584fb02bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous load of the <em>file's</em> contents.  <a href="#aee93c7e24e8391615f9f263584fb02bd">More...</a><br /></td></tr>
<tr class="separator:aee93c7e24e8391615f9f263584fb02bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8d95fcdf7c2aa38f54e90a22d3ab6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a0e8d95fcdf7c2aa38f54e90a22d3ab6f">load_partial_contents_async</a> (const <a class="el" href="classGio_1_1File.html#add182d22071784fc345adc757b3d687b">SlotReadMore</a>&amp; slot_read_more, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot_async_ready, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable)</td></tr>
<tr class="memdesc:a0e8d95fcdf7c2aa38f54e90a22d3ab6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the partial contents of a file.  <a href="#a0e8d95fcdf7c2aa38f54e90a22d3ab6f">More...</a><br /></td></tr>
<tr class="separator:a0e8d95fcdf7c2aa38f54e90a22d3ab6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362d71932c0ba8797a8c47b77df1b6d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a362d71932c0ba8797a8c47b77df1b6d7">load_partial_contents_async</a> (const <a class="el" href="classGio_1_1File.html#add182d22071784fc345adc757b3d687b">SlotReadMore</a>&amp; slot_read_more, const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot_async_ready)</td></tr>
<tr class="memdesc:a362d71932c0ba8797a8c47b77df1b6d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the partial contents of a file.  <a href="#a362d71932c0ba8797a8c47b77df1b6d7">More...</a><br /></td></tr>
<tr class="separator:a362d71932c0ba8797a8c47b77df1b6d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b323508401d2e6fd2b3ad659f9bb5eb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a4b323508401d2e6fd2b3ad659f9bb5eb">load_partial_contents_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result, char*&amp; contents, gsize&amp; length, <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag_out)</td></tr>
<tr class="memdesc:a4b323508401d2e6fd2b3ad659f9bb5eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous partial load operation that was started with <a class="el" href="classGio_1_1File.html#a0e8d95fcdf7c2aa38f54e90a22d3ab6f" title="Reads the partial contents of a file. ">load_partial_contents_async()</a>.  <a href="#a4b323508401d2e6fd2b3ad659f9bb5eb">More...</a><br /></td></tr>
<tr class="separator:a4b323508401d2e6fd2b3ad659f9bb5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a59c3831feeadea9bd0709617d2db9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ae3a59c3831feeadea9bd0709617d2db9">load_partial_contents_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result, char*&amp; contents, gsize&amp; length)</td></tr>
<tr class="memdesc:ae3a59c3831feeadea9bd0709617d2db9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous partial load operation that was started with <a class="el" href="classGio_1_1File.html#a0e8d95fcdf7c2aa38f54e90a22d3ab6f" title="Reads the partial contents of a file. ">load_partial_contents_async()</a>.  <a href="#ae3a59c3831feeadea9bd0709617d2db9">More...</a><br /></td></tr>
<tr class="separator:ae3a59c3831feeadea9bd0709617d2db9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af10deca1d5c5d1f650d3b182624330dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#af10deca1d5c5d1f650d3b182624330dc">replace_contents</a> (const char* contents, gsize length, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag, <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; new_etag, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, bool make_backup=false, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a>)</td></tr>
<tr class="memdesc:af10deca1d5c5d1f650d3b182624330dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents of the file with <em>contents</em> of <em>length</em> bytes.  <a href="#af10deca1d5c5d1f650d3b182624330dc">More...</a><br /></td></tr>
<tr class="separator:af10deca1d5c5d1f650d3b182624330dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7febf1f0f3b4b9efca9fae469082846"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ae7febf1f0f3b4b9efca9fae469082846">replace_contents</a> (const char* contents, gsize length, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag, <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; new_etag, bool make_backup=false, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a>)</td></tr>
<tr class="memdesc:ae7febf1f0f3b4b9efca9fae469082846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents of the file with <em>contents</em> of <em>length</em> bytes.  <a href="#ae7febf1f0f3b4b9efca9fae469082846">More...</a><br /></td></tr>
<tr class="separator:ae7febf1f0f3b4b9efca9fae469082846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23126b43cd262b63c0e458c3a4d0b65c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a23126b43cd262b63c0e458c3a4d0b65c">replace_contents</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; contents, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag, <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; new_etag, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, bool make_backup=false, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a>)</td></tr>
<tr class="memdesc:a23126b43cd262b63c0e458c3a4d0b65c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents of the file with <em>contents</em>.  <a href="#a23126b43cd262b63c0e458c3a4d0b65c">More...</a><br /></td></tr>
<tr class="separator:a23126b43cd262b63c0e458c3a4d0b65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf33a17461ff4f70fed06818e364f617"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aaf33a17461ff4f70fed06818e364f617">replace_contents</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; contents, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag, <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; new_etag, bool make_backup=false, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a>)</td></tr>
<tr class="memdesc:aaf33a17461ff4f70fed06818e364f617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the contents of the file with <em>contents</em>.  <a href="#aaf33a17461ff4f70fed06818e364f617">More...</a><br /></td></tr>
<tr class="separator:aaf33a17461ff4f70fed06818e364f617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad33b24a7942429157f47379f4353378c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ad33b24a7942429157f47379f4353378c">replace_contents_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const char* contents, gsize length, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag, bool make_backup=false, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a>)</td></tr>
<tr class="memdesc:ad33b24a7942429157f47379f4353378c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts an asynchronous replacement of the file with the given <em>contents</em> of <em>length</em> bytes.  <a href="#ad33b24a7942429157f47379f4353378c">More...</a><br /></td></tr>
<tr class="separator:ad33b24a7942429157f47379f4353378c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a1c445e84124e16294974a73f2f1bbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a9a1c445e84124e16294974a73f2f1bbb">replace_contents_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const char* contents, gsize length, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag, bool make_backup=false, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a>)</td></tr>
<tr class="memdesc:a9a1c445e84124e16294974a73f2f1bbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts an asynchronous replacement of the file with the given <em>contents</em> of <em>length</em> bytes.  <a href="#a9a1c445e84124e16294974a73f2f1bbb">More...</a><br /></td></tr>
<tr class="separator:a9a1c445e84124e16294974a73f2f1bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a380d6ce6362fc05e0e18ff1b881ceac7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a380d6ce6362fc05e0e18ff1b881ceac7">replace_contents_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; contents, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag, bool make_backup=false, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a>)</td></tr>
<tr class="memdesc:a380d6ce6362fc05e0e18ff1b881ceac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts an asynchronous replacement of the file with the given <em>contents</em> of <em>length</em> bytes.  <a href="#a380d6ce6362fc05e0e18ff1b881ceac7">More...</a><br /></td></tr>
<tr class="separator:a380d6ce6362fc05e0e18ff1b881ceac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc86aab90620881899a701c2b2775cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a6fc86aab90620881899a701c2b2775cb">replace_contents_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; contents, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag, bool make_backup=false, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a>)</td></tr>
<tr class="memdesc:a6fc86aab90620881899a701c2b2775cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts an asynchronous replacement of the file with the given <em>contents</em>.  <a href="#a6fc86aab90620881899a701c2b2775cb">More...</a><br /></td></tr>
<tr class="separator:a6fc86aab90620881899a701c2b2775cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe0e644bafcb88ce52b62de803167cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#afbe0e644bafcb88ce52b62de803167cd">replace_contents_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result, <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; new_etag)</td></tr>
<tr class="memdesc:afbe0e644bafcb88ce52b62de803167cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous replace of the given file .  <a href="#afbe0e644bafcb88ce52b62de803167cd">More...</a><br /></td></tr>
<tr class="separator:afbe0e644bafcb88ce52b62de803167cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0372ffd3f535f39b7e48c0483e4c1f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#af0372ffd3f535f39b7e48c0483e4c1f4">replace_contents_finish</a> (const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp; result)</td></tr>
<tr class="memdesc:af0372ffd3f535f39b7e48c0483e4c1f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finishes an asynchronous replace of the given file .  <a href="#af0372ffd3f535f39b7e48c0483e4c1f4">More...</a><br /></td></tr>
<tr class="separator:af0372ffd3f535f39b7e48c0483e4c1f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e6caba24b605600338ffdab6901620e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a4e6caba24b605600338ffdab6901620e">replace_contents_bytes_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp; cancellable, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; const <a class="el" href="classGlib_1_1Bytes.html">Glib::Bytes</a> &gt;&amp; contents, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag, bool make_backup=false, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a>)</td></tr>
<tr class="memdesc:a4e6caba24b605600338ffdab6901620e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classGio_1_1File.html#ad33b24a7942429157f47379f4353378c" title="Starts an asynchronous replacement of the file with the given contents of length bytes. ">replace_contents_async()</a> but takes a Gio::Bytes input instead.  <a href="#a4e6caba24b605600338ffdab6901620e">More...</a><br /></td></tr>
<tr class="separator:a4e6caba24b605600338ffdab6901620e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8e166a3ffdd266eff7fab5b24154bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#afa8e166a3ffdd266eff7fab5b24154bd">replace_contents_bytes_async</a> (const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp; slot, const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; const <a class="el" href="classGlib_1_1Bytes.html">Glib::Bytes</a> &gt;&amp; contents, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; etag, bool make_backup=false, <a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a> flags=<a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a>)</td></tr>
<tr class="memdesc:afa8e166a3ffdd266eff7fab5b24154bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classGio_1_1File.html#ad33b24a7942429157f47379f4353378c" title="Starts an asynchronous replacement of the file with the given contents of length bytes. ">replace_contents_async()</a> but takes a Gio::Bytes input instead.  <a href="#afa8e166a3ffdd266eff7fab5b24154bd">More...</a><br /></td></tr>
<tr class="separator:afa8e166a3ffdd266eff7fab5b24154bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab666a9ec3922903646504f4080758522"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ab666a9ec3922903646504f4080758522">supports_thread_contexts</a> () const </td></tr>
<tr class="memdesc:ab666a9ec3922903646504f4080758522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <em>file</em> supports [thread-default contexts][g-main-context-push-thread-default-context].  <a href="#ab666a9ec3922903646504f4080758522">More...</a><br /></td></tr>
<tr class="separator:ab666a9ec3922903646504f4080758522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classGlib_1_1Interface"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classGlib_1_1Interface')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classGlib_1_1Interface.html">Glib::Interface</a></td></tr>
<tr class="memitem:a3ab20f29c40967352d1bf2d88bfe11e5 inherit pub_methods_classGlib_1_1Interface"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Interface.html#a3ab20f29c40967352d1bf2d88bfe11e5">Interface</a> ()</td></tr>
<tr class="memdesc:a3ab20f29c40967352d1bf2d88bfe11e5 inherit pub_methods_classGlib_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Default constructor.  <a href="#a3ab20f29c40967352d1bf2d88bfe11e5">More...</a><br /></td></tr>
<tr class="separator:a3ab20f29c40967352d1bf2d88bfe11e5 inherit pub_methods_classGlib_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83337dc270f966539b9f46804460ab75 inherit pub_methods_classGlib_1_1Interface"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Interface.html#a83337dc270f966539b9f46804460ab75">Interface</a> (<a class="el" href="classGlib_1_1Interface.html">Interface</a>&amp;&amp; src) noexcept</td></tr>
<tr class="separator:a83337dc270f966539b9f46804460ab75 inherit pub_methods_classGlib_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a411d66c7467e749dbb2c4b31c4d518b5 inherit pub_methods_classGlib_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1Interface.html">Interface</a>&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Interface.html#a411d66c7467e749dbb2c4b31c4d518b5">operator=</a> (<a class="el" href="classGlib_1_1Interface.html">Interface</a>&amp;&amp; src) noexcept</td></tr>
<tr class="separator:a411d66c7467e749dbb2c4b31c4d518b5 inherit pub_methods_classGlib_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae05bf6a4ce0f0992c2ad01429d13f9f7 inherit pub_methods_classGlib_1_1Interface"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Interface.html#ae05bf6a4ce0f0992c2ad01429d13f9f7">Interface</a> (const Glib::Interface_Class&amp; interface_class)</td></tr>
<tr class="memdesc:ae05bf6a4ce0f0992c2ad01429d13f9f7 inherit pub_methods_classGlib_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by constructors of derived classes.  <a href="#ae05bf6a4ce0f0992c2ad01429d13f9f7">More...</a><br /></td></tr>
<tr class="separator:ae05bf6a4ce0f0992c2ad01429d13f9f7 inherit pub_methods_classGlib_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00253b22a76f751f1627865451cbc404 inherit pub_methods_classGlib_1_1Interface"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Interface.html#a00253b22a76f751f1627865451cbc404">Interface</a> (GObject* castitem)</td></tr>
<tr class="memdesc:a00253b22a76f751f1627865451cbc404 inherit pub_methods_classGlib_1_1Interface"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called by constructors of derived classes.  <a href="#a00253b22a76f751f1627865451cbc404">More...</a><br /></td></tr>
<tr class="separator:a00253b22a76f751f1627865451cbc404 inherit pub_methods_classGlib_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b6cc885cb02bc158ce779939dd4654 inherit pub_methods_classGlib_1_1Interface"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Interface.html#a50b6cc885cb02bc158ce779939dd4654">~Interface</a> () noexceptoverride</td></tr>
<tr class="separator:a50b6cc885cb02bc158ce779939dd4654 inherit pub_methods_classGlib_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bb27d294728f34452be66b4ec4cd757 inherit pub_methods_classGlib_1_1Interface"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Interface.html#a4bb27d294728f34452be66b4ec4cd757">Interface</a> (const <a class="el" href="classGlib_1_1Interface.html">Interface</a>&amp;)=delete</td></tr>
<tr class="separator:a4bb27d294728f34452be66b4ec4cd757 inherit pub_methods_classGlib_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf322f95cef17aa4cc232d8ef25f2b42 inherit pub_methods_classGlib_1_1Interface"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1Interface.html">Interface</a>&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Interface.html#acf322f95cef17aa4cc232d8ef25f2b42">operator=</a> (const <a class="el" href="classGlib_1_1Interface.html">Interface</a>&amp;)=delete</td></tr>
<tr class="separator:acf322f95cef17aa4cc232d8ef25f2b42 inherit pub_methods_classGlib_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a969e9396f75132a9577428f4fa932d42 inherit pub_methods_classGlib_1_1Interface"><td class="memItemLeft" align="right" valign="top">GObject*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Interface.html#a969e9396f75132a9577428f4fa932d42">gobj</a> ()</td></tr>
<tr class="separator:a969e9396f75132a9577428f4fa932d42 inherit pub_methods_classGlib_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70a443071a69d3372c2cdd7128a91ed1 inherit pub_methods_classGlib_1_1Interface"><td class="memItemLeft" align="right" valign="top">const GObject*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Interface.html#a70a443071a69d3372c2cdd7128a91ed1">gobj</a> () const </td></tr>
<tr class="separator:a70a443071a69d3372c2cdd7128a91ed1 inherit pub_methods_classGlib_1_1Interface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classGlib_1_1ObjectBase"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classGlib_1_1ObjectBase')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classGlib_1_1ObjectBase.html">Glib::ObjectBase</a></td></tr>
<tr class="memitem:aaf0e140e7192dcecddd9f57c46825434 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#aaf0e140e7192dcecddd9f57c46825434">ObjectBase</a> (const <a class="el" href="classGlib_1_1ObjectBase.html">ObjectBase</a>&amp;)=delete</td></tr>
<tr class="separator:aaf0e140e7192dcecddd9f57c46825434 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f8834a320eac98dc1c1b8a9a2fd4c1 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1ObjectBase.html">ObjectBase</a>&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a15f8834a320eac98dc1c1b8a9a2fd4c1">operator=</a> (const <a class="el" href="classGlib_1_1ObjectBase.html">ObjectBase</a>&amp;)=delete</td></tr>
<tr class="separator:a15f8834a320eac98dc1c1b8a9a2fd4c1 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab599d3eec4b4a9ddc95ccdc6100053d inherit pub_methods_classGlib_1_1ObjectBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#aab599d3eec4b4a9ddc95ccdc6100053d">set_property_value</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; property_name, const <a class="el" href="classGlib_1_1ValueBase.html">Glib::ValueBase</a>&amp; value)</td></tr>
<tr class="memdesc:aab599d3eec4b4a9ddc95ccdc6100053d inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">You probably want to use a specific property_*() accessor method instead.  <a href="#aab599d3eec4b4a9ddc95ccdc6100053d">More...</a><br /></td></tr>
<tr class="separator:aab599d3eec4b4a9ddc95ccdc6100053d inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e30750441b92f0246c9d4ece95fc8a0 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a5e30750441b92f0246c9d4ece95fc8a0">get_property_value</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; property_name, <a class="el" href="classGlib_1_1ValueBase.html">Glib::ValueBase</a>&amp; value) const </td></tr>
<tr class="memdesc:a5e30750441b92f0246c9d4ece95fc8a0 inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">You probably want to use a specific property_*() accessor method instead.  <a href="#a5e30750441b92f0246c9d4ece95fc8a0">More...</a><br /></td></tr>
<tr class="separator:a5e30750441b92f0246c9d4ece95fc8a0 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad37844f7ea2c0091a22d011e04c48820 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memTemplParams" colspan="2">template&lt;class PropertyType &gt; </td></tr>
<tr class="memitem:ad37844f7ea2c0091a22d011e04c48820 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#ad37844f7ea2c0091a22d011e04c48820">set_property</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; property_name, const PropertyType&amp; value)</td></tr>
<tr class="memdesc:ad37844f7ea2c0091a22d011e04c48820 inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">You probably want to use a specific property_*() accessor method instead.  <a href="#ad37844f7ea2c0091a22d011e04c48820">More...</a><br /></td></tr>
<tr class="separator:ad37844f7ea2c0091a22d011e04c48820 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f894c9c36ad391fdc85552af67a8530 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memTemplParams" colspan="2">template&lt;class PropertyType &gt; </td></tr>
<tr class="memitem:a5f894c9c36ad391fdc85552af67a8530 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a5f894c9c36ad391fdc85552af67a8530">get_property</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; property_name, PropertyType&amp; value) const </td></tr>
<tr class="memdesc:a5f894c9c36ad391fdc85552af67a8530 inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">You probably want to use a specific property_*() accessor method instead.  <a href="#a5f894c9c36ad391fdc85552af67a8530">More...</a><br /></td></tr>
<tr class="separator:a5f894c9c36ad391fdc85552af67a8530 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc6c1e8f094275114d6e2c3ef3a33f98 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#adc6c1e8f094275114d6e2c3ef3a33f98">connect_property_changed</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; property_name, const <a class="elRef" href="file:///C:/msys/1.0/local/share/doc/libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt; void &gt;&amp; slot)</td></tr>
<tr class="memdesc:adc6c1e8f094275114d6e2c3ef3a33f98 inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">You can use the signal_changed() signal of the property proxy instead.  <a href="#adc6c1e8f094275114d6e2c3ef3a33f98">More...</a><br /></td></tr>
<tr class="separator:adc6c1e8f094275114d6e2c3ef3a33f98 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fff4abb6ecc939866a6ff5d32808221 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a9fff4abb6ecc939866a6ff5d32808221">connect_property_changed</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; property_name, <a class="elRef" href="file:///C:/msys/1.0/local/share/doc/libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt; void &gt;&amp;&amp; slot)</td></tr>
<tr class="memdesc:a9fff4abb6ecc939866a6ff5d32808221 inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">You can use the signal_changed() signal of the property proxy instead.  <a href="#a9fff4abb6ecc939866a6ff5d32808221">More...</a><br /></td></tr>
<tr class="separator:a9fff4abb6ecc939866a6ff5d32808221 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a896d7773c00bd2dcd310c861282ee8d1 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="file:///C:/msys/1.0/local/share/doc/libsigc++-2.0/reference/html/structsigc_1_1connection.html">sigc::connection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a896d7773c00bd2dcd310c861282ee8d1">connect_property_changed_with_return</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; property_name, const <a class="elRef" href="file:///C:/msys/1.0/local/share/doc/libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt; void &gt;&amp; slot)</td></tr>
<tr class="memdesc:a896d7773c00bd2dcd310c861282ee8d1 inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">You can use the signal_changed() signal of the property proxy instead.  <a href="#a896d7773c00bd2dcd310c861282ee8d1">More...</a><br /></td></tr>
<tr class="separator:a896d7773c00bd2dcd310c861282ee8d1 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f0e2119fbb42efe42d66b8188a0daf inherit pub_methods_classGlib_1_1ObjectBase"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="file:///C:/msys/1.0/local/share/doc/libsigc++-2.0/reference/html/structsigc_1_1connection.html">sigc::connection</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a00f0e2119fbb42efe42d66b8188a0daf">connect_property_changed_with_return</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; property_name, <a class="elRef" href="file:///C:/msys/1.0/local/share/doc/libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt; void &gt;&amp;&amp; slot)</td></tr>
<tr class="memdesc:a00f0e2119fbb42efe42d66b8188a0daf inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">You can use the signal_changed() signal of the property proxy instead.  <a href="#a00f0e2119fbb42efe42d66b8188a0daf">More...</a><br /></td></tr>
<tr class="separator:a00f0e2119fbb42efe42d66b8188a0daf inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9e13b75f116c20212d318204ce8ea3 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a6e9e13b75f116c20212d318204ce8ea3">freeze_notify</a> ()</td></tr>
<tr class="memdesc:a6e9e13b75f116c20212d318204ce8ea3 inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increases the freeze count on object.  <a href="#a6e9e13b75f116c20212d318204ce8ea3">More...</a><br /></td></tr>
<tr class="separator:a6e9e13b75f116c20212d318204ce8ea3 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd8ea7bd8c4084ade6b3c27dddf06a4 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a1bd8ea7bd8c4084ade6b3c27dddf06a4">thaw_notify</a> ()</td></tr>
<tr class="memdesc:a1bd8ea7bd8c4084ade6b3c27dddf06a4 inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverts the effect of a previous call to <a class="el" href="classGlib_1_1ObjectBase.html#a6e9e13b75f116c20212d318204ce8ea3" title="Increases the freeze count on object. ">freeze_notify()</a>.  <a href="#a1bd8ea7bd8c4084ade6b3c27dddf06a4">More...</a><br /></td></tr>
<tr class="separator:a1bd8ea7bd8c4084ade6b3c27dddf06a4 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a896a8a5db20043ea82956e3ef4b9c4ae inherit pub_methods_classGlib_1_1ObjectBase"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a896a8a5db20043ea82956e3ef4b9c4ae">reference</a> () const </td></tr>
<tr class="memdesc:a896a8a5db20043ea82956e3ef4b9c4ae inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the reference count for this object.  <a href="#a896a8a5db20043ea82956e3ef4b9c4ae">More...</a><br /></td></tr>
<tr class="separator:a896a8a5db20043ea82956e3ef4b9c4ae inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3234b8ffb2a35b927e2978c8f3bfbfe3 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a3234b8ffb2a35b927e2978c8f3bfbfe3">unreference</a> () const </td></tr>
<tr class="memdesc:a3234b8ffb2a35b927e2978c8f3bfbfe3 inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement the reference count for this object.  <a href="#a3234b8ffb2a35b927e2978c8f3bfbfe3">More...</a><br /></td></tr>
<tr class="separator:a3234b8ffb2a35b927e2978c8f3bfbfe3 inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6efc18be8cb9c56e58fc0bd20fafbe inherit pub_methods_classGlib_1_1ObjectBase"><td class="memItemLeft" align="right" valign="top">GObject*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a4c6efc18be8cb9c56e58fc0bd20fafbe">gobj</a> ()</td></tr>
<tr class="memdesc:a4c6efc18be8cb9c56e58fc0bd20fafbe inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C GObject.  <a href="#a4c6efc18be8cb9c56e58fc0bd20fafbe">More...</a><br /></td></tr>
<tr class="separator:a4c6efc18be8cb9c56e58fc0bd20fafbe inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778a94181132976bbfb0519793f3b32e inherit pub_methods_classGlib_1_1ObjectBase"><td class="memItemLeft" align="right" valign="top">const GObject*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a778a94181132976bbfb0519793f3b32e">gobj</a> () const </td></tr>
<tr class="memdesc:a778a94181132976bbfb0519793f3b32e inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C GObject.  <a href="#a778a94181132976bbfb0519793f3b32e">More...</a><br /></td></tr>
<tr class="separator:a778a94181132976bbfb0519793f3b32e inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b2a5eb93102f1849e5419016e22a15f inherit pub_methods_classGlib_1_1ObjectBase"><td class="memItemLeft" align="right" valign="top">GObject*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a9b2a5eb93102f1849e5419016e22a15f">gobj_copy</a> () const </td></tr>
<tr class="memdesc:a9b2a5eb93102f1849e5419016e22a15f inherit pub_methods_classGlib_1_1ObjectBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">Give a ref-ed copy to someone. Use for direct struct access.  <a href="#a9b2a5eb93102f1849e5419016e22a15f">More...</a><br /></td></tr>
<tr class="separator:a9b2a5eb93102f1849e5419016e22a15f inherit pub_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_structsigc_1_1trackable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_structsigc_1_1trackable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1trackable.html">sigc::trackable</a></td></tr>
<tr class="memitem:a7e1348841e762fb41b41c6f2ce9fa073 inherit pub_methods_structsigc_1_1trackable"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="file:///C:/msys/1.0/local/share/doc/libsigc++-2.0/reference/html/structsigc_1_1trackable.html#a7e1348841e762fb41b41c6f2ce9fa073">trackable</a> () noexcept</td></tr>
<tr class="separator:a7e1348841e762fb41b41c6f2ce9fa073 inherit pub_methods_structsigc_1_1trackable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8431d9452c9698a012597e6560c72fa inherit pub_methods_structsigc_1_1trackable"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="file:///C:/msys/1.0/local/share/doc/libsigc++-2.0/reference/html/structsigc_1_1trackable.html#ac8431d9452c9698a012597e6560c72fa">trackable</a> (const <a class="elRef" href="file:///C:/msys/1.0/local/share/doc/libsigc++-2.0/reference/html/structsigc_1_1trackable.html">trackable</a> &amp;src) noexcept</td></tr>
<tr class="separator:ac8431d9452c9698a012597e6560c72fa inherit pub_methods_structsigc_1_1trackable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba42ed8afb6598106cf68c18a7387f18 inherit pub_methods_structsigc_1_1trackable"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="file:///C:/msys/1.0/local/share/doc/libsigc++-2.0/reference/html/structsigc_1_1trackable.html#aba42ed8afb6598106cf68c18a7387f18">trackable</a> (<a class="elRef" href="file:///C:/msys/1.0/local/share/doc/libsigc++-2.0/reference/html/structsigc_1_1trackable.html">trackable</a> &amp;&amp;src)</td></tr>
<tr class="separator:aba42ed8afb6598106cf68c18a7387f18 inherit pub_methods_structsigc_1_1trackable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75587da09e30031db7a2519843f1f4fb inherit pub_methods_structsigc_1_1trackable"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="file:///C:/msys/1.0/local/share/doc/libsigc++-2.0/reference/html/structsigc_1_1trackable.html#a75587da09e30031db7a2519843f1f4fb">~trackable</a> ()</td></tr>
<tr class="separator:a75587da09e30031db7a2519843f1f4fb inherit pub_methods_structsigc_1_1trackable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab14931670837728e49bb5ca88fb16db5 inherit pub_methods_structsigc_1_1trackable"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="file:///C:/msys/1.0/local/share/doc/libsigc++-2.0/reference/html/structsigc_1_1trackable.html#ab14931670837728e49bb5ca88fb16db5">add_destroy_notify_callback</a> (void *data, <a class="elRef" href="file:///C:/msys/1.0/local/share/doc/libsigc++-2.0/reference/html/structsigc_1_1trackable.html#a3338954d7565534bd945290b798e13ed">func_destroy_notify</a> func) const </td></tr>
<tr class="separator:ab14931670837728e49bb5ca88fb16db5 inherit pub_methods_structsigc_1_1trackable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e23cfe7adc1ca844a3350bbac557cb inherit pub_methods_structsigc_1_1trackable"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="file:///C:/msys/1.0/local/share/doc/libsigc++-2.0/reference/html/structsigc_1_1trackable.html#af2e23cfe7adc1ca844a3350bbac557cb">notify_callbacks</a> ()</td></tr>
<tr class="separator:af2e23cfe7adc1ca844a3350bbac557cb inherit pub_methods_structsigc_1_1trackable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7494fbad23a65932ff1457d00d4edaf5 inherit pub_methods_structsigc_1_1trackable"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="file:///C:/msys/1.0/local/share/doc/libsigc++-2.0/reference/html/structsigc_1_1trackable.html">trackable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="file:///C:/msys/1.0/local/share/doc/libsigc++-2.0/reference/html/structsigc_1_1trackable.html#a7494fbad23a65932ff1457d00d4edaf5">operator=</a> (const <a class="elRef" href="file:///C:/msys/1.0/local/share/doc/libsigc++-2.0/reference/html/structsigc_1_1trackable.html">trackable</a> &amp;src)</td></tr>
<tr class="separator:a7494fbad23a65932ff1457d00d4edaf5 inherit pub_methods_structsigc_1_1trackable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d61cdb452dc46fcdc8a8d42d9c079d inherit pub_methods_structsigc_1_1trackable"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="file:///C:/msys/1.0/local/share/doc/libsigc++-2.0/reference/html/structsigc_1_1trackable.html">trackable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="file:///C:/msys/1.0/local/share/doc/libsigc++-2.0/reference/html/structsigc_1_1trackable.html#ac3d61cdb452dc46fcdc8a8d42d9c079d">operator=</a> (<a class="elRef" href="file:///C:/msys/1.0/local/share/doc/libsigc++-2.0/reference/html/structsigc_1_1trackable.html">trackable</a> &amp;&amp;src)</td></tr>
<tr class="separator:ac3d61cdb452dc46fcdc8a8d42d9c079d inherit pub_methods_structsigc_1_1trackable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b9dffa8a50ff13ba33e6c7f10468e2b inherit pub_methods_structsigc_1_1trackable"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="file:///C:/msys/1.0/local/share/doc/libsigc++-2.0/reference/html/structsigc_1_1trackable.html#a8b9dffa8a50ff13ba33e6c7f10468e2b">remove_destroy_notify_callback</a> (void *data) const </td></tr>
<tr class="separator:a8b9dffa8a50ff13ba33e6c7f10468e2b inherit pub_methods_structsigc_1_1trackable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aa9352e68c93431dd16b8ac587703772f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#aa9352e68c93431dd16b8ac587703772f">add_interface</a> (GType gtype_implementer)</td></tr>
<tr class="separator:aa9352e68c93431dd16b8ac587703772f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a1cbe348685c278bb7df93ee8018442"><td class="memItemLeft" align="right" valign="top">static GType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a9a1cbe348685c278bb7df93ee8018442">get_type</a> ()</td></tr>
<tr class="memdesc:a9a1cbe348685c278bb7df93ee8018442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the GType for this class, for use with the underlying GObject type system.  <a href="#a9a1cbe348685c278bb7df93ee8018442">More...</a><br /></td></tr>
<tr class="separator:a9a1cbe348685c278bb7df93ee8018442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1a4553b226689d50b9525488223e25"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a1b1a4553b226689d50b9525488223e25">create_for_path</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; path)</td></tr>
<tr class="memdesc:a1b1a4553b226689d50b9525488223e25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> for a given path.  <a href="#a1b1a4553b226689d50b9525488223e25">More...</a><br /></td></tr>
<tr class="separator:a1b1a4553b226689d50b9525488223e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a412b6b55f37f69bd4fb8fbd24d4967be"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a412b6b55f37f69bd4fb8fbd24d4967be">create_for_uri</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; uri)</td></tr>
<tr class="memdesc:a412b6b55f37f69bd4fb8fbd24d4967be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> for a given URI.  <a href="#a412b6b55f37f69bd4fb8fbd24d4967be">More...</a><br /></td></tr>
<tr class="separator:a412b6b55f37f69bd4fb8fbd24d4967be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab311a1c606b3907865fc8aecd4691de8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#ab311a1c606b3907865fc8aecd4691de8">create_for_commandline_arg</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp;<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01644.html#ga943544cb1017a51d7cafc7b4d3cd022f">arg</a>)</td></tr>
<tr class="memdesc:ab311a1c606b3907865fc8aecd4691de8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> for a given argument from the command line.  <a href="#ab311a1c606b3907865fc8aecd4691de8">More...</a><br /></td></tr>
<tr class="separator:ab311a1c606b3907865fc8aecd4691de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7532baa6ce71fe27cfd1e9bba91a3536"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a7532baa6ce71fe27cfd1e9bba91a3536">create_for_parse_name</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; parse_name)</td></tr>
<tr class="separator:a7532baa6ce71fe27cfd1e9bba91a3536"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:abb3b1f0b8e19505b34ae084c518d20fc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#abb3b1f0b8e19505b34ae084c518d20fc">File</a> ()</td></tr>
<tr class="memdesc:abb3b1f0b8e19505b34ae084c518d20fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">You should derive from this class to use it.  <a href="#abb3b1f0b8e19505b34ae084c518d20fc">More...</a><br /></td></tr>
<tr class="separator:abb3b1f0b8e19505b34ae084c518d20fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classGlib_1_1ObjectBase"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classGlib_1_1ObjectBase')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classGlib_1_1ObjectBase.html">Glib::ObjectBase</a></td></tr>
<tr class="memitem:a27d3451d9ca28d6a2f00838d7c56d545 inherit pro_methods_classGlib_1_1ObjectBase"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a27d3451d9ca28d6a2f00838d7c56d545">ObjectBase</a> ()</td></tr>
<tr class="memdesc:a27d3451d9ca28d6a2f00838d7c56d545 inherit pro_methods_classGlib_1_1ObjectBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This default constructor is called implicitly from the constructor of user-derived classes, even if, for instance, Gtk::Button calls a different <a class="el" href="classGlib_1_1ObjectBase.html" title="Glib::ObjectBase is a common base class for Objects and Interfaces. ">ObjectBase</a> constructor.  <a href="#a27d3451d9ca28d6a2f00838d7c56d545">More...</a><br /></td></tr>
<tr class="separator:a27d3451d9ca28d6a2f00838d7c56d545 inherit pro_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ef18214894c6874579313ab21d1018 inherit pro_methods_classGlib_1_1ObjectBase"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#ad4ef18214894c6874579313ab21d1018">ObjectBase</a> (const char* custom_type_name)</td></tr>
<tr class="memdesc:ad4ef18214894c6874579313ab21d1018 inherit pro_methods_classGlib_1_1ObjectBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">A derived constructor always overrides this choice.  <a href="#ad4ef18214894c6874579313ab21d1018">More...</a><br /></td></tr>
<tr class="separator:ad4ef18214894c6874579313ab21d1018 inherit pro_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d59b4d85b0ee72a727e6b2e1b31a2ff inherit pro_methods_classGlib_1_1ObjectBase"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a3d59b4d85b0ee72a727e6b2e1b31a2ff">ObjectBase</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00947.html">std::type_info</a>&amp; custom_type_info)</td></tr>
<tr class="memdesc:a3d59b4d85b0ee72a727e6b2e1b31a2ff inherit pro_methods_classGlib_1_1ObjectBase"><td class="mdescLeft">&#160;</td><td class="mdescRight">This constructor is a special feature to allow creation of derived types on the fly, without having to use g_object_new() manually.  <a href="#a3d59b4d85b0ee72a727e6b2e1b31a2ff">More...</a><br /></td></tr>
<tr class="separator:a3d59b4d85b0ee72a727e6b2e1b31a2ff inherit pro_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e2e177061f6a6e09c4cf3da49c6dfd3 inherit pro_methods_classGlib_1_1ObjectBase"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a7e2e177061f6a6e09c4cf3da49c6dfd3">ObjectBase</a> (<a class="el" href="classGlib_1_1ObjectBase.html">ObjectBase</a>&amp;&amp; src) noexcept</td></tr>
<tr class="separator:a7e2e177061f6a6e09c4cf3da49c6dfd3 inherit pro_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e968f118314ba4d5debfd2850d18003 inherit pro_methods_classGlib_1_1ObjectBase"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1ObjectBase.html">ObjectBase</a>&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a2e968f118314ba4d5debfd2850d18003">operator=</a> (<a class="el" href="classGlib_1_1ObjectBase.html">ObjectBase</a>&amp;&amp; src) noexcept</td></tr>
<tr class="separator:a2e968f118314ba4d5debfd2850d18003 inherit pro_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56ec45e9ebeaacf24be4fb54ed2eea3 inherit pro_methods_classGlib_1_1ObjectBase"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#ae56ec45e9ebeaacf24be4fb54ed2eea3">~ObjectBase</a> () noexcept=0</td></tr>
<tr class="separator:ae56ec45e9ebeaacf24be4fb54ed2eea3 inherit pro_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3faafb14c4f0ca60fbf0f5f5c4d549d0 inherit pro_methods_classGlib_1_1ObjectBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a3faafb14c4f0ca60fbf0f5f5c4d549d0">initialize</a> (GObject* castitem)</td></tr>
<tr class="separator:a3faafb14c4f0ca60fbf0f5f5c4d549d0 inherit pro_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ddc123cd98ed0083aa06364365c8d3 inherit pro_methods_classGlib_1_1ObjectBase"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1ObjectBase.html#a44ddc123cd98ed0083aa06364365c8d3">initialize_move</a> (GObject* castitem, <a class="el" href="classGlib_1_1ObjectBase.html">Glib::ObjectBase</a>* previous_wrapper)</td></tr>
<tr class="separator:a44ddc123cd98ed0083aa06364365c8d3 inherit pro_methods_classGlib_1_1ObjectBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a69670cdc7cf63783d6f9370dcbd7cc3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">Gio::File</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGio_1_1File.html#a69670cdc7cf63783d6f9370dcbd7cc3d">wrap</a> (GFile* object, bool take_copy=false)</td></tr>
<tr class="memdesc:a69670cdc7cf63783d6f9370dcbd7cc3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="namespaceGlib.html#a671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object.  <a href="#a69670cdc7cf63783d6f9370dcbd7cc3d">More...</a><br /></td></tr>
<tr class="separator:a69670cdc7cf63783d6f9370dcbd7cc3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> and directory handling. </p>
<p><a class="el" href="classGio_1_1File.html" title="File and directory handling. ">Gio::File</a> is a high level abstraction for manipulating files on a virtual file system. Gio::Files are lightweight, immutable objects that do no I/O upon creation. It is necessary to understand that a <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">Gio::File</a> object does not represent a file, merely a handle to a file. All file I/O is implemented as streaming operations (see <a class="el" href="classGio_1_1InputStream.html" title="Base class for implementing streaming input. ">Gio::InputStream</a> and <a class="el" href="classGio_1_1OutputStream.html" title="Base class for implementing streaming output. ">Gio::OutputStream</a>).</p>
<p>A GioFile can be constructed from a path, URI, or a command line argument.</p>
<p>You can move through the filesystem with <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">Gio::File</a> handles with <a class="el" href="classGio_1_1File.html#af39bbd5013b2dd675911df322e12ff94" title="Gets the parent directory for the file. ">get_parent()</a> to get a handle to the parent directory, <a class="el" href="classGio_1_1File.html#a53c533d6bbeaaadd1b5592cf1e5ef93c" title="Gets a child of file with basename equal to name. ">get_child()</a> to get a handle to a child within a directory, and <a class="el" href="classGio_1_1File.html#ac5e286d421c7236df39881f8ce0a4e03" title="Resolves a relative path for file to an absolute path. ">resolve_relative_path()</a> to resolve a relative path between two Gio::Files.</p>
<p>Many <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">Gio::File</a> operations have both synchronous and asynchronous versions to suit your application. Asynchronous versions of synchronous functions simply have _async() appended to their function names. The asynchronous I/O functions call a SlotAsyncReady callback slot which is then used to finalize the operation, producing a <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a> which is then passed to the function's matching _finish() operation.</p>
<p>Some <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">Gio::File</a> operations do not have synchronous analogs, as they may take a very long time to finish, and blocking may leave an application unusable. Notable cases include: <a class="el" href="classGio_1_1File.html#a40c88a403f5d01d722b5900545b6a4fe" title="Mounts a file of type FILE_TYPE_MOUNTABLE. ">mount_mountable()</a> to mount a mountable file, <a class="el" href="classGio_1_1File.html#a5b687c8f19411e955bb069c469be92b4" title="Unmounts a file of type FILE_TYPE_MOUNTABLE. ">unmount_mountable()</a> to unmount a mountable file, and <a class="el" href="classGio_1_1File.html#a8a8223e3b661f03c7a60ac0f003b916e" title="Starts an asynchronous eject on a mountable. ">eject_mountable()</a> to eject a mountable file.</p>
<p>One notable feature of Gio::Files are entity tags, or "etags" for short. Entity tags are somewhat like a more abstract version of the traditional mtime, and can be used to quickly determine if the file has been modified from the version on the file system. See the HTTP 1.1 specification for HTTP Etag headers, which are a very similar concept.</p>
<dl class="since_2_16"><dt><b><a class="el" href="since_2_16.html#_since_2_16000061">Since glibmm 2.16:</a></b></dt><dd></dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a6bb470935903b3745b2c8bcca1f40536"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="elRef" href="file:///C:/msys/1.0/local/share/doc/libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt;void, bool, guint64, guint64, guint64&gt; <a class="el" href="classGio_1_1File.html#a6bb470935903b3745b2c8bcca1f40536">Gio::File::SlotFileMeasureProgress</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This slot type is used by <a class="el" href="classGio_1_1File.html#a27d273c8119ef09426405e35f75e533e" title="Recursively measures the disk usage of the file. ">measure_disk_usage()</a> to make periodic progress reports when measuring the amount of disk spaced used by a directory. </p>
<p>These calls are made on a best-effort basis and not all types of GFile will support them. At the minimum, however, one call will always be made immediately.</p>
<p>In the case that there is no support, <em>reporting</em> will be set to false (and the other values undefined) and no further calls will be made. Otherwise, the <em>reporting</em> will be true and the other values all-zeros during the first (immediate) call. In this way, you can know which type of progress UI to show without a delay.</p>
<p>For <a class="el" href="classGio_1_1File.html#a27d273c8119ef09426405e35f75e533e" title="Recursively measures the disk usage of the file. ">measure_disk_usage()</a> the callback is made directly. For <a class="el" href="classGio_1_1File.html#a85ebd8baacbbdf12f1b34fca92b4c8f2" title="Recursively measures the disk usage of the file. ">measure_disk_usage_async()</a> the callback is made via the default main context of the calling thread (ie: the same way that the final async result would be reported).</p>
<p><em>current_size</em> is in the same units as requested by the operation (see FILE_DISK_USAGE_APPARENT_SIZE).</p>
<p>The frequency of the updates is implementation defined, but is ideally about once every 200ms.</p>
<p>The last progress callback may or may not be equal to the final result. Always check the async result to get the final value.</p>
<p>For instance, void on_file_measure_progress(bool reporting, guint64 current_size, guint64 num_dirs, guint64 num_files);</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reporting</td><td>true if more reports will come. </td></tr>
    <tr><td class="paramname">current_size</td><td>The current cumulative size measurement. </td></tr>
    <tr><td class="paramname">num_dirs</td><td>The number of directories visited so far. </td></tr>
    <tr><td class="paramname">num_files</td><td>The number of non-directory files encountered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_38"><dt><b><a class="el" href="since_2_38.html#_since_2_38000017">Since glibmm 2.38:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ac5ff32ee99845479d138eee49d92e59c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="elRef" href="file:///C:/msys/1.0/local/share/doc/libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt;void, goffset, goffset&gt; <a class="el" href="classGio_1_1File.html#ac5ff32ee99845479d138eee49d92e59c">Gio::File::SlotFileProgress</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A signal handler would be, for instance: void on_file_progress(goffset current_num_bytes, goffset total_num_bytes);. </p>

</div>
</div>
<a class="anchor" id="add182d22071784fc345adc757b3d687b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="elRef" href="file:///C:/msys/1.0/local/share/doc/libsigc++-2.0/reference/html/classsigc_1_1slot.html">sigc::slot</a>&lt;bool, const char*, goffset&gt; <a class="el" href="classGio_1_1File.html#add182d22071784fc345adc757b3d687b">Gio::File::SlotReadMore</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A signal handler would be, for instance: bool on_read_more(const char* file_contents, goffset file_size);. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="abb3b1f0b8e19505b34ae084c518d20fc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Gio::File::File </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>You should derive from this class to use it. </p>

</div>
</div>
<a class="anchor" id="a91341a5c27005398bef11c6b232f2ec8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Gio::File::File </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGio_1_1File.html">File</a>&amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5cdc62e6bba80b07800d0a40ffc81e8a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Gio::File::~File </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aa9352e68c93431dd16b8ac587703772f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Gio::File::add_interface </td>
          <td>(</td>
          <td class="paramtype">GType&#160;</td>
          <td class="paramname"><em>gtype_implementer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a91c93ee71eee738690cb551d11df9528"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a>&gt; Gio::File::append_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets an output stream for appending data to the file. </p>
<p>If the file doesn't already exist it is created.</p>
<p>By default files created are generally readable by everyone, but if you pass FILE_CREATE_PRIVATE in <em>flags</em> the file will be made readable only to the current user, to the level that is supported on the target filesystem.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>Some filesystems don't allow all filenames, and may throw a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with INVALID_FILENAME. If the file is a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with IS_DIRECTORY will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>A set of FileCreateFlags. </td></tr>
    <tr><td class="paramname">cancellable</td><td>Optional <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file. ">FileOutputStream</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a8db337b93f3b9b9a6e163477391e6c89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a>&gt; Gio::File::append_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets an output stream for appending data to the file. </p>
<p>If the file doesn't already exist it is created.</p>
<p>By default files created are generally readable by everyone, but if you pass FILE_CREATE_PRIVATE in <em>flags</em> the file will be made readable only to the current user, to the level that is supported on the target filesystem.</p>
<p>Some filesystems don't allow all filenames, and may throw a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with INVALID_FILENAME. If the file is a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with IS_DIRECTORY will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>A set of FileCreateFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file. ">FileOutputStream</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a1e3dfb193e8f2ab69e24c4370de5335a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::append_to_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously opens the file for appending. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a91c93ee71eee738690cb551d11df9528" title="Gets an output stream for appending data to the file. ">append_to()</a> which is the synchronous version of this call.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#ab95fdc72631ad9a07a94eac0bac50090" title="Finishes an asynchronous file append operation started with g_file_append_to_async(). ">append_to_finish()</a> to get the result of the operation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">flags</td><td>a set of FileCreateFlags. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abff3163e9bf8d8208cd0c0e568b777de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::append_to_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously opens the file for appending. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a91c93ee71eee738690cb551d11df9528" title="Gets an output stream for appending data to the file. ">append_to()</a> which is the synchronous version of this call.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#ab95fdc72631ad9a07a94eac0bac50090" title="Finishes an asynchronous file append operation started with g_file_append_to_async(). ">append_to_finish()</a> to get the result of the operation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">flags</td><td>a set of FileCreateFlags. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab95fdc72631ad9a07a94eac0bac50090"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a>&gt; Gio::File::append_to_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finishes an asynchronous file append operation started with g_file_append_to_async(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td><a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A valid <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file. ">FileOutputStream</a> or <code>nullptr</code> on error. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="af9e906ed93069e6adb6d87dae158cad9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGio_1_1File.html#ac5ff32ee99845479d138eee49d92e59c">SlotFileProgress</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga08edc09a45449b136b27493647d4ecbea74324723d31670f9d554d43d4d21cba9">FILE_COPY_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the file source to the location specified by destination. </p>
<p>Can not handle recursive copies of directories. If the flag FILE_COPY_OVERWRITE is specified an already existing destination file is overwritten. If the flag FILE_COPY_NOFOLLOW_SYMLINKS is specified then symlinks will be copied as symlinks, otherwise the target of the source symlink will be copied.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>The operation can be monitored via the <em>slot</em> callback.</p>
<p>If the source file does not exist then a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with NOT_FOUND will be thrown, independent on the status of the destination.</p>
<p>If FILE_COPY_OVERWRITE is not specified and the target exists, then a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with EXISTS will be thrown.</p>
<p>If trying to overwrite a file over a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with IS_DIRECTORY will be thrown. If trying to overwrite a directory with a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with WOULD_MERGE will be thrown.</p>
<p>If the source is a directory and the target does not exist, or FILE_COPY_OVERWRITE is specified and the target is a file, then a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with WOULD_RECURSE will be thrown.</p>
<p>If you are interested in copying the <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">Gio::File</a> object itself (not the on-disk file), see <a class="el" href="classGio_1_1File.html#a9ea238062cdc317ae982ffae5c226c9b" title="Duplicates a File handle. ">File::dup()</a>. </p>

</div>
</div>
<a class="anchor" id="a1d8159b5b377db174b376b3c09deb7c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGio_1_1File.html#ac5ff32ee99845479d138eee49d92e59c">SlotFileProgress</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga08edc09a45449b136b27493647d4ecbea74324723d31670f9d554d43d4d21cba9">FILE_COPY_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the file source to the location specified by destination. </p>
<p>Can not handle recursive copies of directories. If the flag FILE_COPY_OVERWRITE is specified an already existing destination file is overwritten. If the flag FILE_COPY_NOFOLLOW_SYMLINKS is specified then symlinks will be copied as symlinks, otherwise the target of the source symlink will be copied.</p>
<p>The operation can be monitored via the <em>slot</em> callback.</p>
<p>If the source file does not exist then a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with NOT_FOUND will be thrown, independent on the status of the destination.</p>
<p>If FILE_COPY_OVERWRITE is not specified and the target exists, then a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with EXISTS will be thrown.</p>
<p>If trying to overwrite a file over a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with IS_DIRECTORY will be thrown. If trying to overwrite a directory with a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with WOULD_MERGE will be thrown.</p>
<p>If the source is a directory and the target does not exist, or FILE_COPY_OVERWRITE is specified and the target is a file, then a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with WOULD_RECURSE will be thrown.</p>
<p>If you are interested in copying the <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">Gio::File</a> object itself (not the on-disk file), see <a class="el" href="classGio_1_1File.html#a9ea238062cdc317ae982ffae5c226c9b" title="Duplicates a File handle. ">File::dup()</a>. </p>

</div>
</div>
<a class="anchor" id="a7a6b45bed32567031bc7b48273ad4079"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga08edc09a45449b136b27493647d4ecbea74324723d31670f9d554d43d4d21cba9">FILE_COPY_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the file source to the location specified by destination. </p>
<p>Can not handle recursive copies of directories. If the flag FILE_COPY_OVERWRITE is specified an already existing destination file is overwritten. If the flag FILE_COPY_NOFOLLOW_SYMLINKS is specified then symlinks will be copied as symlinks, otherwise the target of the source symlink will be copied.</p>
<p>If the source file does not exist then a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with NOT_FOUND will be thrown, independent on the status of the destination.</p>
<p>If FILE_COPY_OVERWRITE is not specified and the target exists, then a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with EXISTS will be thrown.</p>
<p>If trying to overwrite a file over a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with IS_DIRECTORY will be thrown. If trying to overwrite a directory with a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with WOULD_MERGE will be thrown.</p>
<p>If the source is a directory and the target does not exist, or FILE_COPY_OVERWRITE is specified and the target is a file, then a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with WOULD_RECURSE will be thrown.</p>
<p>If you are interested in copying the <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">Gio::File</a> object itself (not the on-disk file), see <a class="el" href="classGio_1_1File.html#a9ea238062cdc317ae982ffae5c226c9b" title="Duplicates a File handle. ">File::dup()</a>. </p>

</div>
</div>
<a class="anchor" id="a1785b7a4780d5d4ba5ae651350e34398"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::copy_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGio_1_1File.html#ac5ff32ee99845479d138eee49d92e59c">SlotFileProgress</a>&amp;&#160;</td>
          <td class="paramname"><em>slot_progress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot_ready</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga08edc09a45449b136b27493647d4ecbea74324723d31670f9d554d43d4d21cba9">FILE_COPY_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the file to the location specified by <em>destination</em> asynchronously. </p>
<p>For details of the behaviour, see <a class="el" href="classGio_1_1File.html#af9e906ed93069e6adb6d87dae158cad9" title="Copies the file source to the location specified by destination. ">copy()</a>.</p>
<p>When the operation is finished, <em>slot_ready</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#ab16cd89db6cd5bb0c8dfdd4b635002d7" title="Finishes copying the file started with g_file_copy_async(). ">copy_finish()</a> to get the result of the operation.</p>
<p>The function specified by <em>slot_progress</em> will be called just like in <a class="el" href="classGio_1_1File.html#af9e906ed93069e6adb6d87dae158cad9" title="Copies the file source to the location specified by destination. ">copy()</a>, however the callback will run in the main loop, not in the thread that is doing the I/O operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>Destination <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> </td></tr>
    <tr><td class="paramname">slot_progress</td><td>The callback slot to be called with progress information </td></tr>
    <tr><td class="paramname">slot_ready</td><td>A SlotAsyncReady to call when the request is satisfied </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation </td></tr>
    <tr><td class="paramname">flags</td><td>Set of FileCopyFlags </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5b8ae7393c73a9a1d383a82d61f4ac30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::copy_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot_ready</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga08edc09a45449b136b27493647d4ecbea74324723d31670f9d554d43d4d21cba9">FILE_COPY_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the file to the location specified by <em>destination</em> asynchronously. </p>
<p>For details of the behaviour, see <a class="el" href="classGio_1_1File.html#af9e906ed93069e6adb6d87dae158cad9" title="Copies the file source to the location specified by destination. ">copy()</a>.</p>
<p>When the operation is finished, <em>slot_ready</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#ab16cd89db6cd5bb0c8dfdd4b635002d7" title="Finishes copying the file started with g_file_copy_async(). ">copy_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>Destination <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> </td></tr>
    <tr><td class="paramname">slot_ready</td><td>A SlotAsyncReady to call when the request is satisfied </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation </td></tr>
    <tr><td class="paramname">flags</td><td>Set of FileCopyFlags </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac2b1a85f29bbbe15998c090b3794cbf5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::copy_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGio_1_1File.html#ac5ff32ee99845479d138eee49d92e59c">SlotFileProgress</a>&amp;&#160;</td>
          <td class="paramname"><em>slot_progress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot_ready</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga08edc09a45449b136b27493647d4ecbea74324723d31670f9d554d43d4d21cba9">FILE_COPY_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the file to the location specified by <em>destination</em> asynchronously. </p>
<p>For details of the behaviour, see <a class="el" href="classGio_1_1File.html#af9e906ed93069e6adb6d87dae158cad9" title="Copies the file source to the location specified by destination. ">copy()</a>.</p>
<p>When the operation is finished, <em>slot_ready</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#ab16cd89db6cd5bb0c8dfdd4b635002d7" title="Finishes copying the file started with g_file_copy_async(). ">copy_finish()</a> to get the result of the operation.</p>
<p>The function specified by <em>slot_progress</em> will be called just like in <a class="el" href="classGio_1_1File.html#af9e906ed93069e6adb6d87dae158cad9" title="Copies the file source to the location specified by destination. ">copy()</a>, however the callback will run in the main loop, not in the thread that is doing the I/O operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>Destination <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> </td></tr>
    <tr><td class="paramname">slot_progress</td><td>The callback slot to be called with progress information </td></tr>
    <tr><td class="paramname">slot_ready</td><td>A SlotAsyncReady to call when the request is satisfied </td></tr>
    <tr><td class="paramname">flags</td><td>Set of FileCopyFlags </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad538a383b8761d04bd36ed1aa1071e50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::copy_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot_ready</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga08edc09a45449b136b27493647d4ecbea74324723d31670f9d554d43d4d21cba9">FILE_COPY_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the file to the location specified by <em>destination</em> asynchronously. </p>
<p>For details of the behaviour, see <a class="el" href="classGio_1_1File.html#af9e906ed93069e6adb6d87dae158cad9" title="Copies the file source to the location specified by destination. ">copy()</a>.</p>
<p>When the operation is finished, <em>slot_ready</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#ab16cd89db6cd5bb0c8dfdd4b635002d7" title="Finishes copying the file started with g_file_copy_async(). ">copy_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>Destination <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> </td></tr>
    <tr><td class="paramname">slot_ready</td><td>A SlotAsyncReady to call when the request is satisfied </td></tr>
    <tr><td class="paramname">flags</td><td>Set of FileCopyFlags </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a90726dcf94248d2fddf2e4c8584b7bf0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::copy_attributes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga08edc09a45449b136b27493647d4ecbea74324723d31670f9d554d43d4d21cba9">FILE_COPY_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the file attributes from <em>source</em> to <em>destination</em>. </p>
<p>Normally only a subset of the file attributes are copied, those that are copies in a normal file copy operation (which for instance does not include e.g. mtime). However if FILE_COPY_ALL_METADATA is specified in <em>flags</em>, then all the metadata that is possible to copy is copied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>A <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> to copy attributes to. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileMonitorFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the attributes were copied successfully, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a05c1101ede98028c9234486eb0434250"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::copy_attributes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga08edc09a45449b136b27493647d4ecbea74324723d31670f9d554d43d4d21cba9">FILE_COPY_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the file attributes from <em>source</em> to <em>destination</em>. </p>
<p>Normally only a subset of the file attributes are copied, those that are copies in a normal file copy operation (which for instance does not include e.g. mtime). However if FILE_COPY_ALL_METADATA is specified in <em>flags</em>, then all the metadata that is possible to copy is copied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>A <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> to copy attributes to. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileMonitorFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the attributes were copied successfully, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ab16cd89db6cd5bb0c8dfdd4b635002d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::copy_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finishes copying the file started with g_file_copy_async(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>true</code> on success, <code>false</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a86258e11b2884422819d051c3cfd07a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a>&gt; Gio::File::create_file </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new file and returns an output stream for writing to it. </p>
<p>The file must not already exist.</p>
<p>By default files created are generally readable by everyone, but if you pass FILE_CREATE_PRIVATE in <em>flags</em> the file will be made readable only to the current user, to the level that is supported on the target filesystem.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>If a file with this name already exists a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with EXISTS will be thrown. If the file is a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with IS_DIRECTORY will be thrown.</p>
<p>Some filesystems don't allow all filenames, and may throw a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with INVALID_FILENAME, and if the name is to longa <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with FILENAME_TOO_LONG will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">flags</td><td>a set of FileCreateFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file. ">FileOutputStream</a> for the newly created file. </dd></dl>

</div>
</div>
<a class="anchor" id="a5cf2b17b953ccfefb1d13c39bd1be72c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a>&gt; Gio::File::create_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new file and returns an output stream for writing to it. </p>
<p>The file must not already exist.</p>
<p>By default files created are generally readable by everyone, but if you pass FILE_CREATE_PRIVATE in <em>flags</em> the file will be made readable only to the current user, to the level that is supported on the target filesystem.</p>
<p>If a file with this name already exists a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with EXISTS will be thrown. If the file is a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with IS_DIRECTORY will be thrown.</p>
<p>Some filesystems don't allow all filenames, and may throw a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with INVALID_FILENAME, and if the name is to longa <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with FILENAME_TOO_LONG will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>a set of FileCreateFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file. ">FileOutputStream</a> for the newly created file. </dd></dl>

</div>
</div>
<a class="anchor" id="ae0c42446d37aa466173965b7db1a2053"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::create_file_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously creates a new file and returns an output stream for writing to it. </p>
<p>The file must not already exist. For more details, see <a class="el" href="classGio_1_1File.html#a86258e11b2884422819d051c3cfd07a2" title="Creates a new file and returns an output stream for writing to it. ">create_file()</a> which is the synchronous version of this call.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a128001018104d45b158a27003c0c2638" title="Finishes an asynchronous file create operation started with g_file_create_async(). ">create_file_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">flags</td><td>a set of FileCreateFlags. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3fe6ed015f3d2bb72aa7aceed8dc7ca1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::create_file_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously creates a new file and returns an output stream for writing to it. </p>
<p>The file must not already exist. For more details, see <a class="el" href="classGio_1_1File.html#a86258e11b2884422819d051c3cfd07a2" title="Creates a new file and returns an output stream for writing to it. ">create_file()</a> which is the synchronous version of this call.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a128001018104d45b158a27003c0c2638" title="Finishes an asynchronous file create operation started with g_file_create_async(). ">create_file_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">flags</td><td>a set of FileCreateFlags. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a128001018104d45b158a27003c0c2638"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a>&gt; Gio::File::create_file_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finishes an asynchronous file create operation started with g_file_create_async(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file. ">FileOutputStream</a> or <code>nullptr</code> on error. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="ad5ec69c5360219bccb794bab6a128e88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileIOStream.html">FileIOStream</a>&gt; Gio::File::create_file_readwrite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new file and returns a stream for reading and writing to it. </p>
<p>The file must not already exist.</p>
<p>By default files created are generally readable by everyone, but if you pass FILE_CREATE_PRIVATE in <em>flags</em> the file will be made readable only to the current user, to the level that is supported on the target filesystem.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>If a file with this name already exists a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with EXISTS will be thrown. If the file is a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with IS_DIRECTORY will be thrown.</p>
<p>Some filesystems don't allow all filenames, and may throw a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with INVALID_FILENAME, and if the name is to longa <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with FILENAME_TOO_LONG will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on.</p>
<p>Note that in many non-local file cases read and write streams are not supported, so make sure you really need to do read and write streaming, rather than just opening for reading or writing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">flags</td><td>a set of FileCreateFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file. ">FileOutputStream</a> for the newly created file. </dd></dl>

</div>
</div>
<a class="anchor" id="acf5673ceb9095405e458b5035b0986b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileIOStream.html">FileIOStream</a>&gt; Gio::File::create_file_readwrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new file and returns a stream for reading and writing to it. </p>
<p>The file must not already exist.</p>
<p>By default files created are generally readable by everyone, but if you pass FILE_CREATE_PRIVATE in <em>flags</em> the file will be made readable only to the current user, to the level that is supported on the target filesystem.</p>
<p>If a file with this name already exists a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with EXISTS will be thrown. If the file is a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with IS_DIRECTORY will be thrown.</p>
<p>Some filesystems don't allow all filenames, and may throw a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with INVALID_FILENAME, and if the name is to longa <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with FILENAME_TOO_LONG will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on.</p>
<p>Note that in many non-local file cases read and write streams are not supported, so make sure you really need to do read and write streaming, rather than just opening for reading or writing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>a set of FileCreateFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file. ">FileOutputStream</a> for the newly created file. </dd></dl>

</div>
</div>
<a class="anchor" id="a4c27a2460468aab1d3c3665234c24a56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::create_file_readwrite_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously creates a new file and returns a stream for reading and writing to it. </p>
<p>The file must not already exist.</p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#ad5ec69c5360219bccb794bab6a128e88" title="Creates a new file and returns a stream for reading and writing to it. ">create_file_readwrite()</a> which is the synchronous version of this call.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a339d08bf6cafea58d9d0b0675e741d25" title="Finishes an asynchronous file create operation started with g_file_create_readwrite_async(). ">create_file_readwrite_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">flags</td><td>a set of FileCreateFlags. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request.</td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000065">Since glibmm 2.24:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a5a5989cfdee54778de733a529c24607b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::create_file_readwrite_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously creates a new file and returns a stream for reading and writing to it. </p>
<p>The file must not already exist.</p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#ad5ec69c5360219bccb794bab6a128e88" title="Creates a new file and returns a stream for reading and writing to it. ">create_file_readwrite()</a> which is the synchronous version of this call.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a339d08bf6cafea58d9d0b0675e741d25" title="Finishes an asynchronous file create operation started with g_file_create_readwrite_async(). ">create_file_readwrite_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">flags</td><td>a set of FileCreateFlags. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request.</td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000066">Since glibmm 2.24:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a339d08bf6cafea58d9d0b0675e741d25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileIOStream.html">FileIOStream</a>&gt; Gio::File::create_file_readwrite_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finishes an asynchronous file create operation started with g_file_create_readwrite_async(). </p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000033">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileIOStream.html" title="FileIOStream provides input streams that take their content from a file. ">FileIOStream</a> or <code>nullptr</code> on error. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="ab311a1c606b3907865fc8aecd4691de8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1File.html">File</a>&gt; Gio::File::create_for_commandline_arg </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> for a given argument from the command line. </p>
<p>The value of <em>arg</em> can be either a URI, an absolute path or a relative path resolved relative to the current working directory. This operation never fails, but the returned object might not support any I/O operation if arg points to a malformed path.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>A string containing a relative or absolute path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new instantiation of an appropriate <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">Gio::File</a> class. </dd></dl>

</div>
</div>
<a class="anchor" id="a7532baa6ce71fe27cfd1e9bba91a3536"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1File.html">File</a>&gt; Gio::File::create_for_parse_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>parse_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1b1a4553b226689d50b9525488223e25"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1File.html">File</a>&gt; Gio::File::create_for_path </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> for a given path. </p>
<p>This operation never fails, but the returned object might not support any I/O operation if path is malformed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>A string containing a relative or absolute path. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new instantiation of an appropriate <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">Gio::File</a> class. </dd></dl>

</div>
</div>
<a class="anchor" id="a412b6b55f37f69bd4fb8fbd24d4967be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1File.html">File</a>&gt; Gio::File::create_for_uri </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>uri</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> for a given URI. </p>
<p>This operation never fails, but the returned object might not support any I/O operation if path is malformed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uri</td><td>A string containing a URI. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new instantiation of an appropriate <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">Gio::File</a> class. </dd></dl>

</div>
</div>
<a class="anchor" id="a9ea238062cdc317ae982ffae5c226c9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1File.html">File</a>&gt; Gio::File::dup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicates a <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> handle. </p>
<p>This operation does not duplicate the actual file or directory represented by the <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a>; see g_file_copy() if attempting to copy a file.</p>
<p>This call does no blocking I/O.</p>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> that is a duplicate of the given <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a8a8223e3b661f03c7a60ac0f003b916e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::eject_mountable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44a1599c4ebeb5c0c6e9c312a4b9e4231b6">MOUNT_UNMOUNT_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts an asynchronous eject on a mountable. </p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a6a5124de7c55e9dc5e85ffcb9d3dd14f" title="Finishes an asynchronous eject operation started by g_file_eject_mountable_with_operation(). ">eject_mountable_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad8422a939a634d2248ef6d8658f0fdad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::eject_mountable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44a1599c4ebeb5c0c6e9c312a4b9e4231b6">MOUNT_UNMOUNT_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts an asynchronous eject on a mountable. </p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a6a5124de7c55e9dc5e85ffcb9d3dd14f" title="Finishes an asynchronous eject operation started by g_file_eject_mountable_with_operation(). ">eject_mountable_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeb28fd505cab23a82c68ff00445b12e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::eject_mountable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44a1599c4ebeb5c0c6e9c312a4b9e4231b6">MOUNT_UNMOUNT_NONE</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts an asynchronous eject on a mountable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>Flags affecting the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1c103886296fd1ea1107906deebec8a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::eject_mountable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>mount_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44a1599c4ebeb5c0c6e9c312a4b9e4231b6">MOUNT_UNMOUNT_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts an asynchronous eject on a mountable. </p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a6a5124de7c55e9dc5e85ffcb9d3dd14f" title="Finishes an asynchronous eject operation started by g_file_eject_mountable_with_operation(). ">eject_mountable_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">mount_operation</td><td>A <a class="el" href="classGio_1_1MountOperation.html" title="Authentication methods for mountable locations. ">MountOperation</a> </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000076">Since glibmm 2.24:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ab6c75952828023d27d109a3a23fafc00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::eject_mountable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>mount_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44a1599c4ebeb5c0c6e9c312a4b9e4231b6">MOUNT_UNMOUNT_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts an asynchronous eject on a mountable. </p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a6a5124de7c55e9dc5e85ffcb9d3dd14f" title="Finishes an asynchronous eject operation started by g_file_eject_mountable_with_operation(). ">eject_mountable_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">mount_operation</td><td>A <a class="el" href="classGio_1_1MountOperation.html" title="Authentication methods for mountable locations. ">MountOperation</a> </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000077">Since glibmm 2.24:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ab7aea22f6cb30b3f2be43682ddd543d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::eject_mountable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>mount_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44a1599c4ebeb5c0c6e9c312a4b9e4231b6">MOUNT_UNMOUNT_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts an asynchronous eject on a mountable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mount_operation</td><td>A <a class="el" href="classGio_1_1MountOperation.html" title="Authentication methods for mountable locations. ">MountOperation</a> </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000078">Since glibmm 2.24:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a6a5124de7c55e9dc5e85ffcb9d3dd14f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::eject_mountable_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finishes an asynchronous eject operation started by g_file_eject_mountable_with_operation(). </p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000038">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <em>file</em> was ejected successfully. <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a68c3afcddc0d4860aa2afb4bf715bb20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileEnumerator.html">FileEnumerator</a>&gt; Gio::File::enumerate_children </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>attributes</em> = <code>&quot;*&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0a4e412b5c20ae24607975e36b1d2142c9">FILE_QUERY_INFO_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the requested information about the files in a directory. </p>
<p>The result is a <a class="el" href="classGio_1_1FileEnumerator.html" title="Enumerated Files Routines. ">FileEnumerator</a> object that will give out <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes. ">FileInfo</a> objects for all the files in the directory.</p>
<p>The <em>attribute</em> value is a string that specifies the file attributes that should be gathered. It is not an error if its not possible to read a particular requested attribute from a file, it just won't be set. <em>attribute</em> should be a comma-separated list of attribute or attribute wildcards. The wildcard "*" means all attributes, and a wildcard like "standard::*" means all attributes in the standard namespace. An example attribute query be "standard::*,owner::user". The standard attributes are availible as defines, like FILE_ATTRIBUTE_STANDARD_NAME.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>If the file does not exist, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with NOT_FOUND will be thrown. If the file is not a directory, a <a class="el" href="classGlib_1_1FileError.html" title="Exception class for file-related errors. ">Glib::FileError</a> with NOTDIR will be thrown. Other errors are possible too.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
    <tr><td class="paramname">attributes</td><td>An attribute query string. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileQueryInfoFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileEnumerator.html" title="Enumerated Files Routines. ">FileEnumerator</a> if successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ac0e293d607499b223f4892fb290ab2d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileEnumerator.html">FileEnumerator</a>&gt; Gio::File::enumerate_children </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>attributes</em> = <code>&quot;*&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0a4e412b5c20ae24607975e36b1d2142c9">FILE_QUERY_INFO_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the requested information about the files in a directory. </p>
<p>The result is a <a class="el" href="classGio_1_1FileEnumerator.html" title="Enumerated Files Routines. ">FileEnumerator</a> object that will give out <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes. ">FileInfo</a> objects for all the files in the directory.</p>
<p>The <em>attribute</em> value is a string that specifies the file attributes that should be gathered. It is not an error if its not possible to read a particular requested attribute from a file, it just won't be set. <em>attribute</em> should be a comma-separated list of attribute or attribute wildcards. The wildcard "*" means all attributes, and a wildcard like "standard::*" means all attributes in the standard namespace. An example attribute query be "standard::*,owner::user". The standard attributes are availible as defines, like FILE_ATTRIBUTE_STANDARD_NAME.</p>
<p>If the file does not exist, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with NOT_FOUND will be thrown. If the file is not a directory, a <a class="el" href="classGlib_1_1FileError.html" title="Exception class for file-related errors. ">Glib::FileError</a> with NOTDIR will be thrown. Other errors are possible too.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attributes</td><td>An attribute query string. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileQueryInfoFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileEnumerator.html" title="Enumerated Files Routines. ">FileEnumerator</a> if successful. </dd></dl>

</div>
</div>
<a class="anchor" id="a1ead7237b7057d9b15cf5f3065988131"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::enumerate_children_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>attributes</em> = <code>&quot;*&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0a4e412b5c20ae24607975e36b1d2142c9">FILE_QUERY_INFO_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously gets the requested information about the files in a directory. </p>
<p>The result is a GFileEnumerator object that will give out GFileInfo objects for all the files in the directory.</p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a68c3afcddc0d4860aa2afb4bf715bb20" title="Gets the requested information about the files in a directory. ">enumerate_children()</a> which is the synchronous version of this call. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#acdabb80157c69c01479e0b89821c1299" title="Finishes an async enumerate children operation. ">enumerate_children_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">attributes</td><td>An attribute query string. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileQueryInfoFlags. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5b5470cf1c97754a12169201665f1202"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::enumerate_children_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>attributes</em> = <code>&quot;*&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0a4e412b5c20ae24607975e36b1d2142c9">FILE_QUERY_INFO_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously gets the requested information about the files in a directory. </p>
<p>The result is a GFileEnumerator object that will give out GFileInfo objects for all the files in the directory.</p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a68c3afcddc0d4860aa2afb4bf715bb20" title="Gets the requested information about the files in a directory. ">enumerate_children()</a> which is the synchronous version of this call. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#acdabb80157c69c01479e0b89821c1299" title="Finishes an async enumerate children operation. ">enumerate_children_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">attributes</td><td>An attribute query string. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileQueryInfoFlags. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acdabb80157c69c01479e0b89821c1299"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileEnumerator.html">FileEnumerator</a>&gt; Gio::File::enumerate_children_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finishes an async enumerate children operation. </p>
<p>See g_file_enumerate_children_async().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileEnumerator.html" title="Enumerated Files Routines. ">FileEnumerator</a> or <code>nullptr</code> if an error occurred. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="a8877115c870ea8f58b03d1d3c01a83e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; const <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks equality of two given Files. </p>
<p>Note that two Files that differ can still refer to the same file on the filesystem due to various forms of filename aliasing.</p>
<p>This call does no blocking I/O. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The other <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>* this</em> and <em>other</em> are equal. <code>false</code> if either is not a <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a45b881926b8d58c49d3baa1f51f2ee5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Mount.html">Mount</a>&gt; Gio::File::find_enclosing_mount </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a <a class="el" href="classGio_1_1Mount.html" title="The Mount interface represents user-visible mounts. ">Mount</a> for the <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a>. </p>
<p>If the FileIface for <em>file</em> does not have a mount (e.g. possibly a remote share), a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> will be thrown with NOT_FOUND and <code>nullptr</code> will be returned.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> will be thrown with CANCELLED.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1Mount.html" title="The Mount interface represents user-visible mounts. ">Mount</a> where the <em>file</em> is located or <code>nullptr</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a6eb675267c7ea1c2a0d40e2e754d8333"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Mount.html">Mount</a>&gt; Gio::File::find_enclosing_mount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1File.html#a6eb675267c7ea1c2a0d40e2e754d8333" title="A find_enclosing_mount() convenience overload. ">find_enclosing_mount()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="a78c95d4fa47157f7757b686677dec018"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::find_enclosing_mount_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously gets the mount for the file. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a6eb675267c7ea1c2a0d40e2e754d8333" title="A find_enclosing_mount() convenience overload. ">find_enclosing_mount()</a> which is the synchronous version of this call.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#ad4b415b02053e16a92cabb6a48368733" title="Finishes an asynchronous find mount request. ">find_enclosing_mount_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a67458be57c5687e7469bc26e2594f4be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::find_enclosing_mount_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously gets the mount for the file. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a6eb675267c7ea1c2a0d40e2e754d8333" title="A find_enclosing_mount() convenience overload. ">find_enclosing_mount()</a> which is the synchronous version of this call.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#ad4b415b02053e16a92cabb6a48368733" title="Finishes an asynchronous find mount request. ">find_enclosing_mount_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad4b415b02053e16a92cabb6a48368733"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1Mount.html">Mount</a>&gt; Gio::File::find_enclosing_mount_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finishes an asynchronous find mount request. </p>
<p>See g_file_find_enclosing_mount_async().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classGio_1_1Mount.html" title="The Mount interface represents user-visible mounts. ">Mount</a> for given <em>file</em> or <code>nullptr</code> on error. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="ac731bed45bb7fcfd411eb69c49d3b883"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> Gio::File::get_basename </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the base name (the last component of the path) for a given <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a>. </p>
<p>If called for the top level of a system (such as the filesystem root or a uri like sftp://host/) it will return a single directory separator (and on Windows, possibly a drive letter).</p>
<p>The base name is a byte string (not UTF-8). It has no defined encoding or rules other than it may not contain zero bytes. If you want to use filenames in a user interface you should use the display name that you can get by requesting the FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME attribute with g_file_query_info().</p>
<p>This call does no blocking I/O.</p>
<dl class="section return"><dt>Returns</dt><dd>String containing the <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a>'s base name, or <code>nullptr</code> if given <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> is invalid. The returned string should be freed with Glib::free() when no longer needed. </dd></dl>

</div>
</div>
<a class="anchor" id="a53c533d6bbeaaadd1b5592cf1e5ef93c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1File.html">File</a>&gt; Gio::File::get_child </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a child of <em>file</em> with basename equal to <em>name</em>. </p>
<p>Note that the file with that specific name might not exist, but you can still have a <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> that points to it. You can use this for instance to create that file.</p>
<p>This call does no blocking I/O.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>String containing the child's basename. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> to a child specified by <em>name</em>. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="a479cfd632af30b29e125f904f809ed71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1File.html">File</a>&gt; Gio::File::get_child_for_display_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>display_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the child of <em>file</em> for a given <em>display_name</em> (i.e. a UTF-8 version of the name). </p>
<p>If this function fails, it returns <code>nullptr</code> and <em>error</em> will be set. This is very useful when constructing a <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> for a new file and the user entered the filename in the user interface, for instance when you select a directory and type a filename in the file selector.</p>
<p>This call does no blocking I/O.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">display_name</td><td>String to a possible child. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> to the specified child, or <code>nullptr</code> if the display name couldn't be converted. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="af39bbd5013b2dd675911df322e12ff94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1File.html">File</a>&gt; Gio::File::get_parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the parent directory for the <em>file</em>. </p>
<p>If the <em>file</em> represents the root directory of the file system, then <code>nullptr</code> will be returned.</p>
<p>This call does no blocking I/O.</p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> structure to the parent of the given <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> or <code>nullptr</code> if there is no parent. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="aea4a78163e3085a35cbaacde9a3a7628"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a> Gio::File::get_parse_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the parse name of the <em>file</em>. </p>
<p>A parse name is a UTF-8 string that describes the file such that one can get the <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> back using g_file_parse_name().</p>
<p>This is generally used to show the <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> as a nice full-pathname kind of string in a user interface, like in a location entry.</p>
<p>For local files with names that can safely be converted to UTF-8 the pathname is used, otherwise the IRI is used (a form of URI that allows UTF-8 characters unescaped).</p>
<p>This call does no blocking I/O.</p>
<dl class="section return"><dt>Returns</dt><dd>A string containing the <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a>'s parse name. The returned string should be freed with Glib::free() when no longer needed. </dd></dl>

</div>
</div>
<a class="anchor" id="a7b3edc7946b681b6db2cdcdad08d2b00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> Gio::File::get_path </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the local pathname for <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a>, if one exists. </p>
<p>If non-<code>nullptr</code>, this is guaranteed to be an absolute, canonical path. It might contain symlinks.</p>
<p>This call does no blocking I/O.</p>
<dl class="section return"><dt>Returns</dt><dd>String containing the <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a>'s path, or <code>nullptr</code> if no such path exists. The returned string should be freed with Glib::free() when no longer needed. </dd></dl>

</div>
</div>
<a class="anchor" id="a464248111fa2bc5df89c620354eb99bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> Gio::File::get_relative_path </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; const <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>descendant</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the path for <em>descendant</em> relative to <em>parent</em>. </p>
<p>This call does no blocking I/O.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">descendant</td><td>Input <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>String with the relative path from <em>descendant</em> to <em>parent</em>, or <code>nullptr</code> if <em>descendant</em> doesn't have <em>parent</em> as prefix. The returned string should be freed with Glib::free() when no longer needed. </dd></dl>

</div>
</div>
<a class="anchor" id="a9a1cbe348685c278bb7df93ee8018442"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static GType Gio::File::get_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the GType for this class, for use with the underlying GObject type system. </p>

</div>
</div>
<a class="anchor" id="a2d1313e4a4eb5de034b693ec1cc9fba0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> Gio::File::get_uri </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the URI for the <em>file</em>. </p>
<p>This call does no blocking I/O.</p>
<dl class="section return"><dt>Returns</dt><dd>A string containing the <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a>'s URI. The returned string should be freed with Glib::free() when no longer needed. </dd></dl>

</div>
</div>
<a class="anchor" id="aeecec6962f955bd72ac5595be37db7a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> Gio::File::get_uri_scheme </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the URI scheme for a <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a>. </p>
<p>RFC 3986 decodes the scheme as:</p>
<p>[C example ellipted] Common schemes include "file", "http", "ftp", etc.</p>
<p>This call does no blocking I/O.</p>
<dl class="section return"><dt>Returns</dt><dd>A string containing the URI scheme for the given <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a>. The returned string should be freed with Glib::free() when no longer needed. </dd></dl>

</div>
</div>
<a class="anchor" id="a96552cfbaf2e5fa3659a1568db8cca91"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GFile* Gio::File::gobj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides access to the underlying C GObject. </p>

</div>
</div>
<a class="anchor" id="a5437bc648d8b73451e8bee0bc902cfc0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const GFile* Gio::File::gobj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides access to the underlying C GObject. </p>

</div>
</div>
<a class="anchor" id="ae0b0d16b849b2f92699ad57ee7c935d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::has_parent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <em>file</em> has a parent, and optionally, if it is <em>parent</em>. </p>
<p>If <em>parent</em> is <code>nullptr</code> then this function returns <code>true</code> if <em>file</em> has any parent at all. If <em>parent</em> is non-<code>nullptr</code> then <code>true</code> is only returned if <em>file</em> is an immediate child of <em>parent</em>.</p>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000063">Since glibmm 2.24:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>The parent to check for, or <code>nullptr</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>file</em> is an immediate child of <em>parent</em> (or any parent in the case that <em>parent</em> is <code>nullptr</code>). </dd></dl>

</div>
</div>
<a class="anchor" id="aa1daee0498c403e83ac509e6157edd1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::has_parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the file has any parent at all. </p>
<dl class="section return"><dt>Returns</dt><dd>true if the file is a child of any parent.</dd></dl>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000064">Since glibmm 2.24:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a4c40ec88dfc4333f19e939d26a1e0332"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::has_prefix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; const <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>prefix</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether <em>file</em> has the prefix specified by <em>prefix</em>. </p>
<p>In other words, if the names of initial elements of <em>file's</em> pathname match <em>prefix</em>. Only full pathname elements are matched, so a path like /foo is not considered a prefix of /foobar, only of /foo/bar.</p>
<p>A <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> is not a prefix of itself. If you want to check for equality, use g_file_equal().</p>
<p>This call does no I/O, as it works purely on names. As such it can sometimes return <code>false</code> even if <em>file</em> is inside a <em>prefix</em> (from a filesystem point of view), because the prefix of <em>file</em> is an alias of <em>prefix</em>.</p>
<p>Virtual: prefix_matches</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>Input <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <em>files's</em> parent, grandparent, etc is <em>prefix</em>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a90d71529e5b51b9ff73914eaf90be0f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::has_uri_scheme </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>uri_scheme</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> has a given URI scheme. </p>
<p>This call does no blocking I/O.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uri_scheme</td><td>A string containing a URI scheme. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a>'s backend supports the given URI scheme, <code>false</code> if URI scheme is <code>nullptr</code>, not supported, or <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> is invalid. </dd></dl>

</div>
</div>
<a class="anchor" id="a0320bac72ecc9ced1f894f1af696856f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">guint Gio::File::hash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a hash value for a <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a>. </p>
<p>This call does no blocking I/O.</p>
<p>Virtual: hash</p>
<dl class="section return"><dt>Returns</dt><dd>0 if <em>file</em> is not a valid <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a>, otherwise an integer that can be used as hash value for the <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a>. This function is intended for easily hashing a <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> to add to a HashTable or similar data structure. </dd></dl>

</div>
</div>
<a class="anchor" id="aaa3b910bc9f240d4ebd0efc70979f163"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::is_native </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks to see if a file is native to the platform. </p>
<p>A native file s one expressed in the platform-native filename format, e.g. "C:\\Windows" or "/usr/bin/". This does not mean the file is local, as it might be on a locally mounted remote filesystem.</p>
<p>On some systems non-native files may be available using the native filesystem via a userspace filesystem (FUSE), in these cases this call will return <code>false</code>, but g_file_get_path() will still return a native path.</p>
<p>This call does no blocking I/O.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>file</em> is native. </dd></dl>

</div>
</div>
<a class="anchor" id="ac53be228d732b34e062a2a57814cdf15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::load_contents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp;&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>etag_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads the content of the file into memory, returning the size of the data. </p>
<p>The data is always zero terminated, but this is not included in the resultant <em>length</em>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> exception with CANCELLED will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td>A cancellable object. </td></tr>
    <tr><td class="paramname">contents</td><td>A location to place the contents of the file. </td></tr>
    <tr><td class="paramname">length</td><td>A location to place the length of the contents of the file. </td></tr>
    <tr><td class="paramname">etag_out</td><td>A location to place the current entity tag for the file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ada7c826a417f88b405244c8dc39ae1ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::load_contents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp;&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads the content of the file into memory, returning the size of the data. </p>
<p>The data is always zero terminated, but this is not included in the resultant <em>length</em>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> exception with CANCELLED will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td>A cancellable object. </td></tr>
    <tr><td class="paramname">contents</td><td>A location to place the contents of the file. </td></tr>
    <tr><td class="paramname">length</td><td>A location to place the length of the contents of the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000042">Since glibmm 2.22:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a77f7781b0ba65bc4e7e613b80b353fd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::load_contents </td>
          <td>(</td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp;&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>etag_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads the content of the file into memory, returning the size of the data. </p>
<p>The data is always zero terminated, but this is not included in the resultant <em>length</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">contents</td><td>A location to place the contents of the file. </td></tr>
    <tr><td class="paramname">length</td><td>A location to place the length of the contents of the file. </td></tr>
    <tr><td class="paramname">etag_out</td><td>A location to place the current entity tag for the file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a40f3ce7cf905144bac7218f9988d2d35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::load_contents </td>
          <td>(</td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp;&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads the content of the file into memory, returning the size of the data. </p>
<p>The data is always zero terminated, but this is not included in the resultant <em>length</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">contents</td><td>A location to place the contents of the file. </td></tr>
    <tr><td class="paramname">length</td><td>A location to place the length of the contents of the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000043">Since glibmm 2.22:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ad0e02ebffbaa13036e4636d2118f71a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::load_contents_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts an asynchronous load of the file's contents. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#ac53be228d732b34e062a2a57814cdf15" title="Loads the content of the file into memory, returning the size of the data. ">load_contents()</a> which is the synchronous version of this call.</p>
<p>When the load operation has completed, the <em>slot</em> will be called. To finish the operation, call <a class="el" href="classGio_1_1File.html#a5fd15277ab90bcc57db088be04cac457" title="Finishes an asynchronous load of the file&#39;s contents. ">load_contents_finish()</a> with the <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a> provided to the <em>slot</em>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6af7ec98d5543bce07b917b65d7276ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::load_contents_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts an asynchronous load of the file's contents. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#ac53be228d732b34e062a2a57814cdf15" title="Loads the content of the file into memory, returning the size of the data. ">load_contents()</a> which is the synchronous version of this call.</p>
<p>When the load operation has completed, the <em>slot</em> will be called. To finish the operation, call <a class="el" href="classGio_1_1File.html#a5fd15277ab90bcc57db088be04cac457" title="Finishes an asynchronous load of the file&#39;s contents. ">load_contents_finish()</a> with the <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a> provided to the <em>slot</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5fd15277ab90bcc57db088be04cac457"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::load_contents_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp;&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>etag_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finishes an asynchronous load of the <em>file's</em> contents. </p>
<p>The contents are placed in <em>contents</em>, and <em>length</em> is set to the size of the <em>contents</em> string. If <em>etag_out</em> is present, it will be set to the new entity tag for the <em>file</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
    <tr><td class="paramname">contents</td><td>A location to place the contents of the file. </td></tr>
    <tr><td class="paramname">length</td><td>A location to place the length of the contents of the file. </td></tr>
    <tr><td class="paramname">etag_out</td><td>A location to place the current entity tag for the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the load was successful. If <code>false</code> and <em>error</em> is present, it will be set appropriately. </dd></dl>

</div>
</div>
<a class="anchor" id="aee93c7e24e8391615f9f263584fb02bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::load_contents_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp;&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finishes an asynchronous load of the <em>file's</em> contents. </p>
<p>The contents are placed in <em>contents</em>, and <em>length</em> is set to the size of the <em>contents</em> string. If <em>etag_out</em> is present, it will be set to the new entity tag for the <em>file</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
    <tr><td class="paramname">contents</td><td>A location to place the contents of the file. </td></tr>
    <tr><td class="paramname">length</td><td>A location to place the length of the contents of the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the load was successful. If <code>false</code> and <em>error</em> is present, it will be set appropriately. </dd></dl>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000044">Since glibmm 2.22:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a0e8d95fcdf7c2aa38f54e90a22d3ab6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::load_partial_contents_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGio_1_1File.html#add182d22071784fc345adc757b3d687b">SlotReadMore</a>&amp;&#160;</td>
          <td class="paramname"><em>slot_read_more</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot_async_ready</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the partial contents of a file. </p>
<p>The <em>slot_read_more</em> callback slot should be used to stop reading from the file when appropriate. This operation can be finished by <a class="el" href="classGio_1_1File.html#a4b323508401d2e6fd2b3ad659f9bb5eb" title="Finishes an asynchronous partial load operation that was started with load_partial_contents_async(). ">load_partial_contents_finish()</a>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a4b323508401d2e6fd2b3ad659f9bb5eb" title="Finishes an asynchronous partial load operation that was started with load_partial_contents_async(). ">load_partial_contents_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot_read_more</td><td>A callback to receive partial data and to specify whether further data should be read. </td></tr>
    <tr><td class="paramname">slot_async_ready</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a362d71932c0ba8797a8c47b77df1b6d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::load_partial_contents_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGio_1_1File.html#add182d22071784fc345adc757b3d687b">SlotReadMore</a>&amp;&#160;</td>
          <td class="paramname"><em>slot_read_more</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot_async_ready</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the partial contents of a file. </p>
<p>The <em>slot_read_more</em> callback slot should be used to stop reading from the file when appropriate. This operation can be finished by <a class="el" href="classGio_1_1File.html#a4b323508401d2e6fd2b3ad659f9bb5eb" title="Finishes an asynchronous partial load operation that was started with load_partial_contents_async(). ">load_partial_contents_finish()</a>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a4b323508401d2e6fd2b3ad659f9bb5eb" title="Finishes an asynchronous partial load operation that was started with load_partial_contents_async(). ">load_partial_contents_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot_read_more</td><td>A callback to receive partial data and to specify whether further data should be read. </td></tr>
    <tr><td class="paramname">slot_async_ready</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4b323508401d2e6fd2b3ad659f9bb5eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::load_partial_contents_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp;&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>etag_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finishes an asynchronous partial load operation that was started with <a class="el" href="classGio_1_1File.html#a0e8d95fcdf7c2aa38f54e90a22d3ab6f" title="Reads the partial contents of a file. ">load_partial_contents_async()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
    <tr><td class="paramname">contents</td><td>A location to place the contents of the file. </td></tr>
    <tr><td class="paramname">length</td><td>A location to place the length of the contents of the file. </td></tr>
    <tr><td class="paramname">etag_out</td><td>A location to place the current entity tag for the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the load was successful. If <code>false</code> and <em>error</em> is present, it will be set appropriately. </dd></dl>

</div>
</div>
<a class="anchor" id="ae3a59c3831feeadea9bd0709617d2db9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::load_partial_contents_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp;&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finishes an asynchronous partial load operation that was started with <a class="el" href="classGio_1_1File.html#a0e8d95fcdf7c2aa38f54e90a22d3ab6f" title="Reads the partial contents of a file. ">load_partial_contents_async()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
    <tr><td class="paramname">contents</td><td>A location to place the contents of the file. </td></tr>
    <tr><td class="paramname">length</td><td>A location to place the length of the contents of the file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the load was successful. If <code>false</code> and <em>error</em> is present, it will be set appropriately. </dd></dl>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000045">Since glibmm 2.22:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="abfa05e23e95e77cabac289ab4e294a58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::make_directory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a directory. </p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> will be thrown with CANCELLED.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on successful creation, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aa1e9aa5f58a76a8562fd00a13434f554"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::make_directory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1File.html#aa1e9aa5f58a76a8562fd00a13434f554" title="A make_directory() convenience overload. ">make_directory()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="a60cf2bf09420aec99766fa132d8ae0a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::make_directory_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot_ready</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously creates a directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot_ready</td><td>A SlotAsyncReady to call when the request is satisfied </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request </td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_38"><dt><b><a class="el" href="since_2_38.html#_since_2_38000014">Since glibmm 2.38:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ad7facff532924459948de0031396f9b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::make_directory_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot_ready</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously creates a directory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot_ready</td><td>A SlotAsyncReady to call when the request is satisfied </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request </td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_38"><dt><b><a class="el" href="since_2_38.html#_since_2_38000015">Since glibmm 2.38:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a0758295d049fe070dd235786775f777e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::make_directory_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finishes an asynchronous directory creation, started with g_file_make_directory_async(). </p>
<p>Virtual: make_directory_finish </p><dl class="since_2_38"><dt><b><a class="el" href="since_2_38.html#_since_2_38000016">Since glibmm 2.38:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on successful directory creation, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="afb0b5b094339057b4b15952eb73e08d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::make_directory_with_parents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a directory and any parent directories that may not exist similar to 'mkdir -p'. </p>
<p>If the file system does not support creating directories, this function will fail, setting <em>error</em> to IO_ERROR_NOT_SUPPORTED. If the directory itself already exists, this function will fail setting <em>error</em> to IO_ERROR_EXISTS, unlike the similar Glib::mkdir_with_parents().</p>
<p>For a local <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> the newly created directories will have the default (current) ownership and permissions of the current process.</p>
<p>If <em>cancellable</em> is not <code>nullptr</code>, then the operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, the error IO_ERROR_CANCELLED will be returned.</p>
<dl class="since_2_18"><dt><b><a class="el" href="since_2_18.html#_since_2_18000018">Since glibmm 2.18:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td>Optional <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object, <code>nullptr</code> to ignore. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if all directories have been successfully created, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a874a487551d49ca62b31a3e5cf32fee6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::make_directory_with_parents </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1File.html#a874a487551d49ca62b31a3e5cf32fee6" title="A make_directory_with_parents() convenience overload. ">make_directory_with_parents()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="a2709318e1f24dfd0cd498d28f5e1b8fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::make_symbolic_link </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>symlink_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a symbolic link. </p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> will be thrown with CANCELLED.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">symlink_value</td><td>A string with the value of the new symlink. </td></tr>
    <tr><td class="paramname">cancellable</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on the creation of a new symlink, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a8a9a3d060c2675ff9ac1c758f0b2c024"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::make_symbolic_link </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>symlink_value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1File.html#a2709318e1f24dfd0cd498d28f5e1b8fe" title="Creates a symbolic link. ">make_symbolic_link()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="a27d273c8119ef09426405e35f75e533e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::measure_disk_usage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGio_1_1File.html#a6bb470935903b3745b2c8bcca1f40536">SlotFileMeasureProgress</a>&amp;&#160;</td>
          <td class="paramname"><em>slot_progress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">guint64 &amp;&#160;</td>
          <td class="paramname"><em>disk_usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">guint64 &amp;&#160;</td>
          <td class="paramname"><em>num_dirs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">guint64 &amp;&#160;</td>
          <td class="paramname"><em>num_files</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga3d27573e797e8e78e7b71705ad015ced">FileMeasureFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga3d27573e797e8e78e7b71705ad015ceda96dacae2624b3093efe929aed02cbca3">FILE_MEASURE_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursively measures the disk usage of the file. </p>
<p>This is essentially an analog of the '<code>du</code>' command, but it also reports the number of directories and non-directory files encountered (including things like symbolic links).</p>
<p>By default, errors are only reported against the toplevel file itself. Errors found while recursing are silently ignored, unless FILE_DISK_USAGE_REPORT_ALL_ERRORS is given in <em>flags</em>.</p>
<p>The returned size, <em>disk_usage</em>, is in bytes and should be formatted with g_format_size() in order to get something reasonable for showing in a user interface.</p>
<p><em>slot_progress</em> can be given to request periodic progress updates while scanning. See the documentation for SlotFileMeasureProgress for information about when and how the callback will be invoked.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation </td></tr>
    <tr><td class="paramname">slot_progress</td><td>A SlotFileMeasureProgress to call periodically while scanning. </td></tr>
    <tr><td class="paramname">disk_usage</td><td>The number of bytes of disk space used. </td></tr>
    <tr><td class="paramname">num_dirs</td><td>The number of directories encountered. </td></tr>
    <tr><td class="paramname">num_files</td><td>The number of non-directories encountered. </td></tr>
    <tr><td class="paramname">flags</td><td>Set of FileMeasureFlags. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a85ebd8baacbbdf12f1b34fca92b4c8f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::measure_disk_usage_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot_ready</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGio_1_1File.html#a6bb470935903b3745b2c8bcca1f40536">SlotFileMeasureProgress</a>&amp;&#160;</td>
          <td class="paramname"><em>slot_progress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga3d27573e797e8e78e7b71705ad015ced">FileMeasureFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga3d27573e797e8e78e7b71705ad015ceda96dacae2624b3093efe929aed02cbca3">FILE_MEASURE_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recursively measures the disk usage of the file. </p>
<p>This is the asynchronous version of <a class="el" href="classGio_1_1File.html#a27d273c8119ef09426405e35f75e533e" title="Recursively measures the disk usage of the file. ">measure_disk_usage()</a>. See there for more information.</p>
<p>When the operation is finished, <em>slot_ready</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a5463283f6a20c51d4db7943190350d26" title="Collects the results from an earlier call to g_file_measure_disk_usage_async(). ">measure_disk_usage_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot_ready</td><td>A SlotAsyncReady to call when the request is satisfied </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation </td></tr>
    <tr><td class="paramname">slot_progress</td><td>The callback slot to be called with progress information </td></tr>
    <tr><td class="paramname">flags</td><td>Set of FileMeasureFlags </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5463283f6a20c51d4db7943190350d26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::measure_disk_usage_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">guint64 &amp;&#160;</td>
          <td class="paramname"><em>disk_usage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">guint64 &amp;&#160;</td>
          <td class="paramname"><em>num_dirs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">guint64 &amp;&#160;</td>
          <td class="paramname"><em>num_files</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collects the results from an earlier call to g_file_measure_disk_usage_async(). </p>
<p>See g_file_measure_disk_usage() for more information.</p>
<dl class="since_2_38"><dt><b><a class="el" href="since_2_38.html#_since_2_38000018">Since glibmm 2.38:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>The <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a> passed to your SlotAsyncReady. </td></tr>
    <tr><td class="paramname">disk_usage</td><td>The number of bytes of disk space used. </td></tr>
    <tr><td class="paramname">num_dirs</td><td>The number of directories encountered. </td></tr>
    <tr><td class="paramname">num_files</td><td>The number of non-directories encountered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if successful, with the out parameters set. <code>false</code> otherwise, with <em>error</em> set. </dd></dl>

</div>
</div>
<a class="anchor" id="a88aacee7bb6f6d968b4383311a9dd002"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileMonitor.html">FileMonitor</a>&gt; Gio::File::monitor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga469f795e9a4dddb2421c0e5568be6649">FileMonitorFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga469f795e9a4dddb2421c0e5568be6649adedf14a2a5916e81bc91e6174b400290">FILE_MONITOR_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains a file monitor for the given file. </p>
<p>If no file notification mechanism exists, then regular polling of the file is used.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileMonitorFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileMonitor.html" title="Monitors a file or directory for changes. ">FileMonitor</a> for the file.</dd></dl>
<dl class="since_2_18"><dt><b><a class="el" href="since_2_18.html#_since_2_18000019">Since glibmm 2.18:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a50896969a9de87f810f0bf5e2d3335bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileMonitor.html">FileMonitor</a>&gt; Gio::File::monitor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga469f795e9a4dddb2421c0e5568be6649">FileMonitorFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga469f795e9a4dddb2421c0e5568be6649adedf14a2a5916e81bc91e6174b400290">FILE_MONITOR_NONE</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains a file monitor for the given file. </p>
<p>If no file notification mechanism exists, then regular polling of the file is used.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>A set of FileMonitorFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileMonitor.html" title="Monitors a file or directory for changes. ">FileMonitor</a> for the file.</dd></dl>
<dl class="since_2_18"><dt><b><a class="el" href="since_2_18.html#_since_2_18000020">Since glibmm 2.18:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="aa0fa22ffba0ff50779e49ff9d12344e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileMonitor.html">FileMonitor</a>&gt; Gio::File::monitor_directory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga469f795e9a4dddb2421c0e5568be6649">FileMonitorFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga469f795e9a4dddb2421c0e5568be6649adedf14a2a5916e81bc91e6174b400290">FILE_MONITOR_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains a directory monitor for the given file. </p>
<p>This may fail if directory monitoring is not supported.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileMonitorFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileMonitor.html" title="Monitors a file or directory for changes. ">FileMonitor</a> for the file. </dd></dl>

</div>
</div>
<a class="anchor" id="a12d36689c1024ff9fc8819f619910a92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileMonitor.html">FileMonitor</a>&gt; Gio::File::monitor_directory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga469f795e9a4dddb2421c0e5568be6649">FileMonitorFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga469f795e9a4dddb2421c0e5568be6649adedf14a2a5916e81bc91e6174b400290">FILE_MONITOR_NONE</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains a directory monitor for the given file. </p>
<p>This may fail if directory monitoring is not supported.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>A set of FileMonitorFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileMonitor.html" title="Monitors a file or directory for changes. ">FileMonitor</a> for the file. </dd></dl>

</div>
</div>
<a class="anchor" id="ab8e14809f330ddd58e628c96921cd987"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileMonitor.html">FileMonitor</a>&gt; Gio::File::monitor_file </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga469f795e9a4dddb2421c0e5568be6649">FileMonitorFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga469f795e9a4dddb2421c0e5568be6649adedf14a2a5916e81bc91e6174b400290">FILE_MONITOR_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains a file monitor for the given file. </p>
<p>If no file notification mechanism exists, then regular polling of the file is used.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileMonitorFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileMonitor.html" title="Monitors a file or directory for changes. ">FileMonitor</a> for the file. </dd></dl>

</div>
</div>
<a class="anchor" id="aa410183ed3b4a745093383d038d271b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileMonitor.html">FileMonitor</a>&gt; Gio::File::monitor_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga469f795e9a4dddb2421c0e5568be6649">FileMonitorFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga469f795e9a4dddb2421c0e5568be6649adedf14a2a5916e81bc91e6174b400290">FILE_MONITOR_NONE</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtains a file monitor for the given file. </p>
<p>If no file notification mechanism exists, then regular polling of the file is used.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>A set of FileMonitorFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileMonitor.html" title="Monitors a file or directory for changes. ">FileMonitor</a> for the file. </dd></dl>

</div>
</div>
<a class="anchor" id="a144aa2de6b696da90a6baffbe959d732"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::mount_enclosing_volume </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>mount_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga5484bace25c932fd4c7354259e138814">MountMountFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga5484bace25c932fd4c7354259e138814a73c8f98eedd8a952ae25a55533dc145d">MOUNT_MOUNT_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts a <em>mount_operation</em>, mounting the volume that contains the file. </p>
<p>When this operation has completed, <em>slot</em> will be called with, and the operation can be finalized with <a class="el" href="classGio_1_1File.html#aefd44b1b3467bcc474b345ff98b4aa6d" title="Finishes a mount operation started by g_file_mount_enclosing_volume(). ">mount_enclosing_volume_finish()</a>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mount_operation</td><td>A <a class="el" href="classGio_1_1MountOperation.html" title="Authentication methods for mountable locations. ">MountOperation</a>. </td></tr>
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a70fd22116d9c8682433c4bb8cbd764c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::mount_enclosing_volume </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>mount_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga5484bace25c932fd4c7354259e138814">MountMountFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga5484bace25c932fd4c7354259e138814a73c8f98eedd8a952ae25a55533dc145d">MOUNT_MOUNT_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts a <em>mount_operation</em>, mounting the volume that contains the file. </p>
<p>When this operation has completed, <em>slot</em> will be called with, and the operation can be finalized with <a class="el" href="classGio_1_1File.html#aefd44b1b3467bcc474b345ff98b4aa6d" title="Finishes a mount operation started by g_file_mount_enclosing_volume(). ">mount_enclosing_volume_finish()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mount_operation</td><td>A <a class="el" href="classGio_1_1MountOperation.html" title="Authentication methods for mountable locations. ">MountOperation</a>. </td></tr>
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2172cdcdb683630b719c521bf00b1eb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::mount_enclosing_volume </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga5484bace25c932fd4c7354259e138814">MountMountFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga5484bace25c932fd4c7354259e138814a73c8f98eedd8a952ae25a55533dc145d">MOUNT_MOUNT_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts a <em>mount_operation</em>, mounting the volume that contains the file. </p>
<p>When this operation has completed, <em>slot</em> will be called with, and the operation can be finalized with <a class="el" href="classGio_1_1File.html#aefd44b1b3467bcc474b345ff98b4aa6d" title="Finishes a mount operation started by g_file_mount_enclosing_volume(). ">mount_enclosing_volume_finish()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a20f8f18876102a5efaa0536bfa71d71c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::mount_enclosing_volume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga5484bace25c932fd4c7354259e138814">MountMountFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga5484bace25c932fd4c7354259e138814a73c8f98eedd8a952ae25a55533dc145d">MOUNT_MOUNT_NONE</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts a <em>mount_operation</em>, mounting the volume that contains the file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>Flags affecting the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aefd44b1b3467bcc474b345ff98b4aa6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::mount_enclosing_volume_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finishes a mount operation started by g_file_mount_enclosing_volume(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if successful. If an error has occurred, this function will return <code>false</code> and set <em>error</em> appropriately if present. </dd></dl>

</div>
</div>
<a class="anchor" id="a40c88a403f5d01d722b5900545b6a4fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::mount_mountable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>mount_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga5484bace25c932fd4c7354259e138814">MountMountFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga5484bace25c932fd4c7354259e138814a73c8f98eedd8a952ae25a55533dc145d">MOUNT_MOUNT_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mounts a file of type FILE_TYPE_MOUNTABLE. </p>
<p>Using <em>mount_operation</em>, you can request callbacks when, for instance, passwords are needed during authentication.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#ae15d36a7969c55122b9f85a1690a46e8" title="Finishes a mount operation. ">mount_mountable_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mount_operation</td><td>A <a class="el" href="classGio_1_1MountOperation.html" title="Authentication methods for mountable locations. ">MountOperation</a>. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac3c29682ef5a50de73dc2c3c3333301c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::mount_mountable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>mount_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga5484bace25c932fd4c7354259e138814">MountMountFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga5484bace25c932fd4c7354259e138814a73c8f98eedd8a952ae25a55533dc145d">MOUNT_MOUNT_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mounts a file of type FILE_TYPE_MOUNTABLE. </p>
<p>Using <em>mount_operation</em>, you can request callbacks when, for instance, passwords are needed during authentication.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#ae15d36a7969c55122b9f85a1690a46e8" title="Finishes a mount operation. ">mount_mountable_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mount_operation</td><td>A <a class="el" href="classGio_1_1MountOperation.html" title="Authentication methods for mountable locations. ">MountOperation</a>. </td></tr>
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a049e06c3d95b49ad4bff1837ef6d8677"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::mount_mountable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga5484bace25c932fd4c7354259e138814">MountMountFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga5484bace25c932fd4c7354259e138814a73c8f98eedd8a952ae25a55533dc145d">MOUNT_MOUNT_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mounts a file of type FILE_TYPE_MOUNTABLE without user interaction. </p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#ae15d36a7969c55122b9f85a1690a46e8" title="Finishes a mount operation. ">mount_mountable_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8501fa88f4aaa8d52c001596960a4572"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::mount_mountable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga5484bace25c932fd4c7354259e138814">MountMountFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga5484bace25c932fd4c7354259e138814a73c8f98eedd8a952ae25a55533dc145d">MOUNT_MOUNT_NONE</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mounts a file of type FILE_TYPE_MOUNTABLE without user interaction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>Flags affecting the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae15d36a7969c55122b9f85a1690a46e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1File.html">File</a>&gt; Gio::File::mount_mountable_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finishes a mount operation. </p>
<p>See g_file_mount_mountable() for details.</p>
<p>Finish an asynchronous mount operation that was started with g_file_mount_mountable().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> or <code>nullptr</code> on error. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="a51c0d55880178c37dee578fdc723b0f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::move </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGio_1_1File.html#ac5ff32ee99845479d138eee49d92e59c">SlotFileProgress</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga08edc09a45449b136b27493647d4ecbea74324723d31670f9d554d43d4d21cba9">FILE_COPY_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to move the file or directory source to the location specified by destination. </p>
<p>If native move operations are supported then this is used, otherwise a copy and delete fallback is used. The native implementation may support moving directories (for instance on moves inside the same filesystem), but the fallback code does not.</p>
<p>If the flag FILE_COPY_OVERWRITE is specified an already existing destination file is overwritten.</p>
<p>If the flag FILE_COPY_NOFOLLOW_SYMLINKS is specified then symlinks will be copied as symlinks, otherwise the target of the source symlink will be copied.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>The operation can be monitored via the <em>slot</em> callback. If the source file does not exist then a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with NOT_FOUND will be thrown, independent on the status of the destination.</p>
<p>If G_FILE_COPY_OVERWRITE is not specified and the target exists, then a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with EXISTS will be thrown.</p>
<p>If trying to overwrite a file over a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with IS_DIRECTORY will be thrown. If trying to overwrite a directory with a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with WOULD_MERGE will be thrown.</p>
<p>If the source is a directory and the target does not exist, or FILE_COPY_OVERWRITE is specified and the target is a file, then a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with WOULD_RECURSE may be thrown (if the native move operation isn't available). </p>

</div>
</div>
<a class="anchor" id="adfb2d8bfed1cb7af50e5e5795ebea732"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::move </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGio_1_1File.html#ac5ff32ee99845479d138eee49d92e59c">SlotFileProgress</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga08edc09a45449b136b27493647d4ecbea74324723d31670f9d554d43d4d21cba9">FILE_COPY_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aba1fab56c3a8bea0b7e4d7f7324c5320"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::move </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">File</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga08edc09a45449b136b27493647d4ecbe">FileCopyFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga08edc09a45449b136b27493647d4ecbea74324723d31670f9d554d43d4d21cba9">FILE_COPY_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a128757d6cf7b152c82bb378a095003ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileIOStream.html">FileIOStream</a>&gt; Gio::File::open_readwrite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens an existing file for reading and writing. </p>
<p>The result is a <a class="el" href="classGio_1_1FileIOStream.html" title="FileIOStream provides input streams that take their content from a file. ">FileIOStream</a> that can be used to read and write the contents of the file.</p>
<p>If <em>cancellable</em> is not <code>nullptr</code>, then the operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, the error IO_ERROR_CANCELLED will be returned.</p>
<p>If the file does not exist, the IO_ERROR_NOT_FOUND error will be returned. If the file is a directory, the IO_ERROR_IS_DIRECTORY error will be returned. Other errors are possible too, and depend on what kind of filesystem the file is on. Note that in many non-local file cases read and write streams are not supported, so make sure you really need to do read and write streaming, rather than just opening for reading or writing.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000034">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classGio_1_1FileIOStream.html" title="FileIOStream provides input streams that take their content from a file. ">FileIOStream</a> or <code>nullptr</code> on error. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="a456f74951f371ef5cca4282751efc66a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileIOStream.html">FileIOStream</a>&gt; Gio::File::open_readwrite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1File.html#a456f74951f371ef5cca4282751efc66a" title="A open_readwrite() convenience overload. ">open_readwrite()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="a73d95a731716c7ffaa86c3af90afe8d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::open_readwrite_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens an existing file for reading and writing. </p>
<p>The result is a <a class="el" href="classGio_1_1FileIOStream.html" title="FileIOStream provides input streams that take their content from a file. ">FileIOStream</a> that can be used to read and write the contents of the file.</p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a456f74951f371ef5cca4282751efc66a" title="A open_readwrite() convenience overload. ">open_readwrite()</a> which is the synchronous version of this call. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a5fdcb54ece686c870eac69c6f93aed75" title="Finishes an asynchronous file read operation started with g_file_open_readwrite_async(). ">open_readwrite_finish()</a> to get the result of the operation. If the file does not exist, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with NOT_FOUND will be thrown. If the file is a directory, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with IS_DIRECTORY will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on.</p>
<p>Note that in many non-local file cases read and write streams are not supported, so make sure you really need to do read and write streaming, rather than just opening for reading or writing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request.</td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000067">Since glibmm 2.24:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a405af7082f531a7a39f3e7a453ab6267"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::open_readwrite_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens an existing file for reading and writing. </p>
<p>The result is a <a class="el" href="classGio_1_1FileIOStream.html" title="FileIOStream provides input streams that take their content from a file. ">FileIOStream</a> that can be used to read and write the contents of the file.</p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a456f74951f371ef5cca4282751efc66a" title="A open_readwrite() convenience overload. ">open_readwrite()</a> which is the synchronous version of this call. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a5fdcb54ece686c870eac69c6f93aed75" title="Finishes an asynchronous file read operation started with g_file_open_readwrite_async(). ">open_readwrite_finish()</a> to get the result of the operation. If the file does not exist, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with NOT_FOUND will be thrown. If the file is a directory, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with IS_DIRECTORY will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on.</p>
<p>Note that in many non-local file cases read and write streams are not supported, so make sure you really need to do read and write streaming, rather than just opening for reading or writing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request.</td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000068">Since glibmm 2.24:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a5fdcb54ece686c870eac69c6f93aed75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileIOStream.html">FileIOStream</a>&gt; Gio::File::open_readwrite_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finishes an asynchronous file read operation started with g_file_open_readwrite_async(). </p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000035">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileIOStream.html" title="FileIOStream provides input streams that take their content from a file. ">FileIOStream</a> or <code>nullptr</code> on error. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="af4d8c21aa35f4703e0b46b04ae2f5b82"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGio_1_1File.html">File</a>&amp; Gio::File::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGio_1_1File.html">File</a>&amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8e81dd0bab13e56ed98456f6a53591ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::poll_mountable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Polls a file of type Mountable. </p>
<p>Using <em>start_operation</em>, you can request callbacks when, for instance, passwords are needed during authentication.</p>
<p>When this operation has completed, <em>slot</em> will be called and the operation can be finalized with <a class="el" href="classGio_1_1File.html#a195990af8825745d0d26147174824565" title="Finishes an stop operation, see g_file_stop_mountable() for details. ">stop_mountable_finish()</a>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback to call when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000083">Since glibmm 2.24:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a2025339de9d7ed9b62300cad1a8e8fd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::poll_mountable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Polls a file of type Mountable. </p>
<p>Using <em>start_operation</em>, you can request callbacks when, for instance, passwords are needed during authentication.</p>
<p>When this operation has completed, <em>slot</em> will be called and the operation can be finalized with <a class="el" href="classGio_1_1File.html#a195990af8825745d0d26147174824565" title="Finishes an stop operation, see g_file_stop_mountable() for details. ">stop_mountable_finish()</a>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback to call when the request is satisfied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000084">Since glibmm 2.24:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a2da5ec13a4a32f229ca97cce8961e637"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::poll_mountable_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finishes a poll operation. </p>
<p>See g_file_poll_mountable() for details.</p>
<p>Finish an asynchronous poll operation that was polled with g_file_poll_mountable().</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000041">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the operation finished successfully. <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a753546465735b25633b003333b66d05c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1AppInfo.html">AppInfo</a>&gt; Gio::File::query_default_handler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the <a class="el" href="classGio_1_1AppInfo.html" title="Application information, to describe applications installed on the system, and launch them...">AppInfo</a> that is registered as the default application to handle the file specified by <em>file</em>. </p>
<p>If <em>cancellable</em> is not <code>nullptr</code>, then the operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, the error IO_ERROR_CANCELLED will be returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td>Optional <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object, <code>nullptr</code> to ignore. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1AppInfo.html" title="Application information, to describe applications installed on the system, and launch them...">AppInfo</a> if the handle was found, <code>nullptr</code> if there were errors. When you are done with it, release it with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="a0c0fd0ece2570b6704889df5ee43c283"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1AppInfo.html">AppInfo</a>&gt; Gio::File::query_default_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1File.html#a0c0fd0ece2570b6704889df5ee43c283" title="A query_default_handler() convenience overload. ">query_default_handler()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="ad8b0a75e0afdb5f6874ea5e304d55ea8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::query_exists </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function to check if a particular file exists. </p>
<p>This is implemented using <a class="el" href="classGio_1_1File.html#adb25ffdbe571d33e89c9503fe9a20dcd" title="Gets the requested information about the file. ">query_info()</a> and as such does blocking I/O.</p>
<p>Note that in many cases it is racy to first check for file existence and then execute something based on the outcome of that, because the file might have been created or removed in between the operations. The general approach to handling that is to not check, but just do the operation and handle the errors as they come.</p>
<p>As an example of race-free checking, take the case of reading a file, and if it doesn't exist, creating it. There are two racy versions: read it, and on error create it; and: check if it exists, if not create it. These can both result in two processes creating the file (with perhaps a partially written file as the result). The correct approach is to always try to create the file with File::create() which will either atomically create the file or fail with a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> exception with EXISTS.</p>
<p>However, in many cases an existence check is useful in a user interface, for instance to make a menu item sensitive/insensitive, so that you don't have to fool users that something is possible and then just show and error dialog. If you do this, you should make sure to also handle the errors that can happen due to races when you execute the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td>Optional <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object, <code>nullptr</code> to ignore. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the file exists (and can be detected without error), <code>false</code> otherwise (or if cancelled). </dd></dl>

</div>
</div>
<a class="anchor" id="ab4cfdbf4fedacd364e40a72c71ab341a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::query_exists </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1File.html#ad8b0a75e0afdb5f6874ea5e304d55ea8" title="Utility function to check if a particular file exists. ">query_exists()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="aa27c5b271c8f7667ce117cfc6118262e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__giommEnums.html#ga7dcba95023d74c47bba3fd0a07f8824c">FileType</a> Gio::File::query_file_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function to inspect the FileType of a file. </p>
<p>This is implemented using g_file_query_info() and as such does blocking I/O.</p>
<p>The primary use case of this method is to check if a file is a regular file, directory, or symlink.</p>
<dl class="since_2_18"><dt><b><a class="el" href="since_2_18.html#_since_2_18000016">Since glibmm 2.18:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>A set of FileQueryInfoFlags passed to g_file_query_info(). </td></tr>
    <tr><td class="paramname">cancellable</td><td>Optional <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object, <code>nullptr</code> to ignore. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The FileType of the file and FILE_TYPE_UNKNOWN if the file does not exist. </dd></dl>

</div>
</div>
<a class="anchor" id="a691a9de5512b870bf358a9b0d292e146"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__giommEnums.html#ga7dcba95023d74c47bba3fd0a07f8824c">FileType</a> Gio::File::query_file_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0a4e412b5c20ae24607975e36b1d2142c9">FILE_QUERY_INFO_NONE</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function to inspect the FileType of a file. </p>
<p>This is implemented using <a class="el" href="classGio_1_1File.html#adb25ffdbe571d33e89c9503fe9a20dcd" title="Gets the requested information about the file. ">query_info()</a> and as such does blocking I/O.</p>
<p>The primary use case of this method is to check if a file is a regular file, directory, or symlink.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>a set of FileQueryInfoFlags passed to <a class="el" href="classGio_1_1File.html#adb25ffdbe571d33e89c9503fe9a20dcd" title="Gets the requested information about the file. ">query_info()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The FileType of the file, or FILE_TYPE_UNKNOWN if the file does not exist.</dd></dl>
<dl class="since_2_18"><dt><b><a class="el" href="since_2_18.html#_since_2_18000017">Since glibmm 2.18:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a40486bc2f0c8758ef8a705b6b8b57e57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileInfo.html">FileInfo</a>&gt; Gio::File::query_filesystem_info </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>attributes</em> = <code>&quot;*&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="classGio_1_1File.html#adb25ffdbe571d33e89c9503fe9a20dcd" title="Gets the requested information about the file. ">query_info()</a>, but obtains information about the filesystem the file is on, rather than the file itself. </p>
<p>For instance the amount of space availible and the type of the filesystem.</p>
<p>The <em>attribute</em> value is a string that specifies the file attributes that should be gathered. It is not an error if its not possible to read a particular requested attribute from a file, it just won't be set. <em>attribute</em> should be a comma-separated list of attribute or attribute wildcards. The wildcard "*" means all attributes, and a wildcard like "fs:*" means all attributes in the fs namespace. The standard namespace for filesystem attributes is "fs". Common attributes of interest are FILE_ATTRIBUTE_FILESYSTEM_SIZE (the total size of the filesystem in bytes), FILE_ATTRIBUTE_FILESYSTEM_FREE (number of bytes availible), and FILE_ATTRIBUTE_FILESYSTEM_TYPE (type of the filesystem).</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>If the file does not exist, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with NOT_FOUND will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
    <tr><td class="paramname">attributes</td><td>An attribute query string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes. ">FileInfo</a> or an empty RefPtr if there was an error. </dd></dl>

</div>
</div>
<a class="anchor" id="ac737012f8df97d90e2447d94d30b817d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileInfo.html">FileInfo</a>&gt; Gio::File::query_filesystem_info </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>attributes</em> = <code>&quot;*&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="classGio_1_1File.html#adb25ffdbe571d33e89c9503fe9a20dcd" title="Gets the requested information about the file. ">query_info()</a>, but obtains information about the filesystem the file is on, rather than the file itself. </p>
<p>For instance the amount of space availible and the type of the filesystem.</p>
<p>The <em>attribute</em> value is a string that specifies the file attributes that should be gathered. It is not an error if its not possible to read a particular requested attribute from a file, it just won't be set. <em>attribute</em> should be a comma-separated list of attribute or attribute wildcards. The wildcard "*" means all attributes, and a wildcard like "fs:*" means all attributes in the fs namespace. The standard namespace for filesystem attributes is "fs". Common attributes of interest are FILE_ATTRIBUTE_FILESYSTEM_SIZE (the total size of the filesystem in bytes), FILE_ATTRIBUTE_FILESYSTEM_FREE (number of bytes availible), and FILE_ATTRIBUTE_FILESYSTEM_TYPE (type of the filesystem).</p>
<p>If the file does not exist, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with NOT_FOUND will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attributes</td><td>An attribute query string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes. ">FileInfo</a> or an empty RefPtr if there was an error. </dd></dl>

</div>
</div>
<a class="anchor" id="a39184ff9c9437259df4b9a9e2f283a0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::query_filesystem_info_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>attributes</em> = <code>&quot;*&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously gets the requested information about the filesystem that the file is on. </p>
<p>The result is a <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes. ">FileInfo</a> object that contains key-value attributes (such as type or size for the file).</p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a40486bc2f0c8758ef8a705b6b8b57e57" title="Similar to query_info(), but obtains information about the filesystem the file is on...">query_filesystem_info()</a> which is the synchronous version of this call.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#af986512a5b8cb8acf75afd7206b09be1" title="Finishes an asynchronous filesystem info query. ">query_filesystem_info_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">attributes</td><td>An attribute query string. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4557ab16a50337f73d8a4649cf60fe70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::query_filesystem_info_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>attributes</em> = <code>&quot;*&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously gets the requested information about the filesystem that the file is on. </p>
<p>The result is a <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes. ">FileInfo</a> object that contains key-value attributes (such as type or size for the file).</p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a40486bc2f0c8758ef8a705b6b8b57e57" title="Similar to query_info(), but obtains information about the filesystem the file is on...">query_filesystem_info()</a> which is the synchronous version of this call.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#af986512a5b8cb8acf75afd7206b09be1" title="Finishes an asynchronous filesystem info query. ">query_filesystem_info_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">attributes</td><td>An attribute query string. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af986512a5b8cb8acf75afd7206b09be1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileInfo.html">FileInfo</a>&gt; Gio::File::query_filesystem_info_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finishes an asynchronous filesystem info query. </p>
<p>See g_file_query_filesystem_info_async().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes. ">FileInfo</a> for given <em>file</em> or <code>nullptr</code> on error. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="adb25ffdbe571d33e89c9503fe9a20dcd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileInfo.html">FileInfo</a>&gt; Gio::File::query_info </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>attributes</em> = <code>&quot;*&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0a4e412b5c20ae24607975e36b1d2142c9">FILE_QUERY_INFO_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the requested information about the file. </p>
<p>The result is a <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes. ">FileInfo</a> object that contains key-value attributes (such as the type or size of the file).</p>
<p>The <em>attribute</em> value is a string that specifies the file attributes that should be gathered. It is not an error if it's not possible to read a particular requested attribute from a file - it just won't be set. <em>attribute</em> should be a comma-separated list of attribute or attribute wildcards. The wildcard "*" means all attributes, and a wildcard like "standard::*" means all attributes in the standard namespace. An example attribute query be "standard::*,owner::user". The standard attributes are available as defines, like G_FILE_ATTRIBUTE_STANDARD_NAME.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>For symlinks, normally the information about the target of the symlink is returned, rather than information about the symlink itself. However if you pass FILE_QUERY_INFO_NOFOLLOW_SYMLINKS in <em>flags</em> the information about the symlink itself will be returned. Also, for symlinks that point to non-existing files the information about the symlink itself will be returned.</p>
<p>If the file does not exist, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with NOT_FOUND will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
    <tr><td class="paramname">attributes</td><td>An attribute query string. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileQueryInfoFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes. ">FileInfo</a> for the file, or an empty RefPtr on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a4e4b9c07ade255b12e2b43c38c3aba90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileInfo.html">FileInfo</a>&gt; Gio::File::query_info </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>attributes</em> = <code>&quot;*&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0a4e412b5c20ae24607975e36b1d2142c9">FILE_QUERY_INFO_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the requested information about the file. </p>
<p>The result is a <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes. ">FileInfo</a> object that contains key-value attributes (such as the type or size of the file).</p>
<p>The <em>attribute</em> value is a string that specifies the file attributes that should be gathered. It is not an error if it's not possible to read a particular requested attribute from a file - it just won't be set. <em>attribute</em> should be a comma-separated list of attribute or attribute wildcards. The wildcard "*" means all attributes, and a wildcard like "standard::*" means all attributes in the standard namespace. An example attribute query be "standard::*,owner::user". The standard attributes are available as defines, like G_FILE_ATTRIBUTE_STANDARD_NAME.</p>
<p>For symlinks, normally the information about the target of the symlink is returned, rather than information about the symlink itself. However if you pass FILE_QUERY_INFO_NOFOLLOW_SYMLINKS in <em>flags</em> the information about the symlink itself will be returned. Also, for symlinks that point to non-existing files the information about the symlink itself will be returned.</p>
<p>If the file does not exist, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with NOT_FOUND will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attributes</td><td>An attribute query string. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileQueryInfoFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes. ">FileInfo</a> for the file, or an empty RefPtr on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a7bd60e7864f8954c35e3b0891058e61c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::query_info_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>attributes</em> = <code>&quot;*&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0a4e412b5c20ae24607975e36b1d2142c9">FILE_QUERY_INFO_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously gets the requested information about specified file. </p>
<p>The result is a <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes. ">FileInfo</a> object that contains key-value attributes (such as type or size for the file).</p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#adb25ffdbe571d33e89c9503fe9a20dcd" title="Gets the requested information about the file. ">query_info()</a> which is the synchronous version of this call. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a33eadfff77c93a77ecde795307728e52" title="Finishes an asynchronous file info query. ">query_info_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">attributes</td><td>An attribute query string. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileQueryInfoFlags. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afcad69d782a971802a8aa85125ac2c8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::query_info_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>attributes</em> = <code>&quot;*&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0a4e412b5c20ae24607975e36b1d2142c9">FILE_QUERY_INFO_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously gets the requested information about specified file. </p>
<p>The result is a <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes. ">FileInfo</a> object that contains key-value attributes (such as type or size for the file).</p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#adb25ffdbe571d33e89c9503fe9a20dcd" title="Gets the requested information about the file. ">query_info()</a> which is the synchronous version of this call. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a33eadfff77c93a77ecde795307728e52" title="Finishes an asynchronous file info query. ">query_info_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">attributes</td><td>An attribute query string. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileQueryInfoFlags. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a33eadfff77c93a77ecde795307728e52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileInfo.html">FileInfo</a>&gt; Gio::File::query_info_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finishes an asynchronous file info query. </p>
<p>See g_file_query_info_async().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes. ">FileInfo</a> for given <em>file</em> or <code>nullptr</code> on error. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="a4a543339b58cff6a7e5ddd840df0e69e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileAttributeInfoList.html">FileAttributeInfoList</a>&gt; Gio::File::query_settable_attributes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the list of settable attributes for the file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td>Optional <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object, <code>nullptr</code> to ignore. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileAttributeInfoList.html" title="Key-Value paired file attributes. ">FileAttributeInfoList</a> describing the settable attributes. When you are done with it, release it with g_file_attribute_info_list_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="a1ae03d0652bcfbad2f47409b8f815bc4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileAttributeInfoList.html">FileAttributeInfoList</a>&gt; Gio::File::query_settable_attributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1File.html#a1ae03d0652bcfbad2f47409b8f815bc4" title="A query_settable_attributes() convenience overload. ">query_settable_attributes()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="af5c7463b92e2887597486e7b195ca12f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileAttributeInfoList.html">FileAttributeInfoList</a>&gt; Gio::File::query_writable_namespaces </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the list of attribute namespaces where new attributes can be created by a user. </p>
<p>An example of this is extended attributes (in the "xattr" namespace).</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> will be thrown with CANCELLED.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileAttributeInfoList.html" title="Key-Value paired file attributes. ">FileAttributeInfoList</a> describing the writable namespaces. When you are done with it, release it with g_file_attribute_info_list_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="aa0278acd7d09ed292359004defb742b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileAttributeInfoList.html">FileAttributeInfoList</a>&gt; Gio::File::query_writable_namespaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1File.html#aa0278acd7d09ed292359004defb742b0" title="A query_writable_namespaces() convenience overload. ">query_writable_namespaces()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="a3ef959c7ad7096846f26eb8b282e3c68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileInputStream.html">FileInputStream</a>&gt; Gio::File::read </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens a file for reading. </p>
<p>The result is a <a class="el" href="classGio_1_1FileInputStream.html" title="FileInputStream provides input streams that take their content from a file. ">FileInputStream</a> that can be used to read the contents of the file.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> will be thrown with CANCELLED.</p>
<p>If the file does not exist, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with NOT_FOUND will be thrown. If the file is a directory, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with IS_DIRECTORY will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classGio_1_1FileInputStream.html" title="FileInputStream provides input streams that take their content from a file. ">FileInputStream</a> or <code>nullptr</code> on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a0395b3b0b8cec5dc1fd9953e52e5fbc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileInputStream.html">FileInputStream</a>&gt; Gio::File::read </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1File.html#a0395b3b0b8cec5dc1fd9953e52e5fbc1" title="A read() convenience overload. ">read()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="a2826eed0b1e76c3771f6ad5f5b993991"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::read_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously opens the file for reading. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a0395b3b0b8cec5dc1fd9953e52e5fbc1" title="A read() convenience overload. ">read()</a> which is the synchronous version of this call. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a3e71d2cd04c5c9c17a51fe8f1dc87c78" title="Finishes an asynchronous file read operation started with g_file_read_async(). ">read_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab451a182a647408e697c9115e66f6194"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::read_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously opens the file for reading. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a0395b3b0b8cec5dc1fd9953e52e5fbc1" title="A read() convenience overload. ">read()</a> which is the synchronous version of this call. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a3e71d2cd04c5c9c17a51fe8f1dc87c78" title="Finishes an asynchronous file read operation started with g_file_read_async(). ">read_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3e71d2cd04c5c9c17a51fe8f1dc87c78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileInputStream.html">FileInputStream</a>&gt; Gio::File::read_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finishes an asynchronous file read operation started with g_file_read_async(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileInputStream.html" title="FileInputStream provides input streams that take their content from a file. ">FileInputStream</a> or <code>nullptr</code> on error. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="aded971b0cf84801f6684ad4bd5dc66c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::remove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes a file. </p>
<p>If the file is a directory, it will only be deleted if it is empty. The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGlib_1_1FileError.html" title="Exception class for file-related errors. ">Glib::FileError</a> with ERROR_CANCELLED will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the file was deleted. <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a14f34508dea523cbf889b7193e513ca4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::remove </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1File.html#a14f34508dea523cbf889b7193e513ca4" title="A remove() convenience overload. ">remove()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="ad8499cabde1f50f1cbd5d928d63e73fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::remove_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot_ready</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously delete a file. </p>
<p>If the file is a directory, it will only be deleted if it is empty. This has the same semantics as g_unlink().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot_ready</td><td>A SlotAsyncReady to call when the request is satisfied </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request </td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_34"><dt><b><a class="el" href="since_2_34.html#_since_2_34000054">Since glibmm 2.34:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a21198001203267126de9a24a8e91b0d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::remove_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot_ready</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously delete a file. </p>
<p>If the file is a directory, it will only be deleted if it is empty. This has the same semantics as g_unlink().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot_ready</td><td>A SlotAsyncReady to call when the request is satisfied </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request </td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_34"><dt><b><a class="el" href="since_2_34.html#_since_2_34000055">Since glibmm 2.34:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a0240c85a3ec46e107666e65da9b92c54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::remove_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finishes deleting a file started with g_file_delete_async(). </p>
<p>Virtual: delete_file_finish </p><dl class="since_2_34"><dt><b><a class="el" href="since_2_34.html#_since_2_34000056">Since glibmm 2.34:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the file was deleted. <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ad7cf0360096504e40f799fde5cc8e9de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a>&gt; Gio::File::replace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>etag</em> = <code><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an output stream for overwriting the file, possibly creating a backup copy of the file first. </p>
<p>This will try to replace the file in the safest way possible so that any errors during the writing will not affect an already existing copy of the file. For instance, for local files it may write to a temporary file and then atomically rename over the destination when the stream is closed.</p>
<p>By default files created are generally readable by everyone, but if you pass FILE_CREATE_PRIVATE in <em>flags</em> the file will be made readable only to the current user, to the level that is supported on the target filesystem.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>If you pass in an etag value, then this value is compared to the current entity tag of the file, and if they differ a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with WRONG_ETAG will be thrown. This generally means that the file has been changed since you last read it. You can get the new etag from <a class="el" href="classGio_1_1FileOutputStream.html#a8e29de4e67428a79b41180ca27af0a3d" title="Gets the entity tag for the file when it has been written. ">FileOutputStream::get_etag()</a> after you've finished writing and closed the <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file. ">FileOutputStream</a>. When you load a new file you can use <a class="el" href="classGio_1_1FileInputStream.html#ae9cf87761484839f4ea53bc33064f189" title="Queries a file input stream the given attributes. ">FileInputStream::query_info()</a> to get the etag of the file.</p>
<p>If <em>make_backup</em> is true, this function will attempt to make a backup of the current file before overwriting it. If this fails aa <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANT_CREATE_BACKUP will be thrown. If you want to replace anyway, try again with <em>make_backup</em> set to false.</p>
<p>If the file is a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with IS_DIRECTORY will be thrown, and if the file is some other form of non-regular file then aa <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with NOT_REGULAR_FILE will be thrown. Some file systems don't allow all file names, and may throw a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with INVALID_FILENAME, and if the name is to longa <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with FILENAME_TOO_LONG will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">etag</td><td>An optional entity tag for the current Glib::File. </td></tr>
    <tr><td class="paramname">make_backup</td><td><code>true</code> if a backup should be created. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileCreateFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file. ">FileOutputStream</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="acf55f9291659566f6fd36271801b013b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a>&gt; Gio::File::replace </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>etag</em> = <code><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an output stream for overwriting the file, possibly creating a backup copy of the file first. </p>
<p>This will try to replace the file in the safest way possible so that any errors during the writing will not affect an already existing copy of the file. For instance, for local files it may write to a temporary file and then atomically rename over the destination when the stream is closed.</p>
<p>By default files created are generally readable by everyone, but if you pass FILE_CREATE_PRIVATE in <em>flags</em> the file will be made readable only to the current user, to the level that is supported on the target filesystem.</p>
<p>If you pass in an etag value, then this value is compared to the current entity tag of the file, and if they differ a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with WRONG_ETAG will be thrown. This generally means that the file has been changed since you last read it. You can get the new etag from <a class="el" href="classGio_1_1FileOutputStream.html#a8e29de4e67428a79b41180ca27af0a3d" title="Gets the entity tag for the file when it has been written. ">FileOutputStream::get_etag()</a> after you've finished writing and closed the <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file. ">FileOutputStream</a>. When you load a new file you can use <a class="el" href="classGio_1_1FileInputStream.html#ae9cf87761484839f4ea53bc33064f189" title="Queries a file input stream the given attributes. ">FileInputStream::query_info()</a> to get the etag of the file.</p>
<p>If <em>make_backup</em> is true, this function will attempt to make a backup of the current file before overwriting it. If this fails aa <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANT_CREATE_BACKUP will be thrown. If you want to replace anyway, try again with <em>make_backup</em> set to false.</p>
<p>If the file is a directory a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with IS_DIRECTORY will be thrown, and if the file is some other form of non-regular file then aa <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with NOT_REGULAR_FILE will be thrown. Some file systems don't allow all file names, and may throw a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with INVALID_FILENAME, and if the name is to longa <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with FILENAME_TOO_LONG will be thrown. Other errors are possible too, and depend on what kind of filesystem the file is on.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">etag</td><td>An optional entity tag for the current Glib::File. </td></tr>
    <tr><td class="paramname">make_backup</td><td><code>true</code> if a backup should be created. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileCreateFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file. ">FileOutputStream</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ad777cdaa404a6a668ee8d520299687ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::replace_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>etag</em> = <code><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asyncronously overwrites the file, replacing the contents, possibly creating a backup copy of the file first. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#ad7cf0360096504e40f799fde5cc8e9de" title="Returns an output stream for overwriting the file, possibly creating a backup copy of the file first...">replace()</a> which is the synchronous version of this call. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a4e5fe0438c73500d3d6ec7d0d4b39daa" title="Finishes an asynchronous file replace operation started with g_file_replace_async(). ">replace_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">etag</td><td>An entity tag for the current <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">Gio::File</a>. </td></tr>
    <tr><td class="paramname">make_backup</td><td>true if a backup of the existing file should be made. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileCreateFlags. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae51e51a2e3a45da4324230b4d5401a58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::replace_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>etag</em> = <code><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asyncronously overwrites the file, replacing the contents, possibly creating a backup copy of the file first. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#ad7cf0360096504e40f799fde5cc8e9de" title="Returns an output stream for overwriting the file, possibly creating a backup copy of the file first...">replace()</a> which is the synchronous version of this call. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a4e5fe0438c73500d3d6ec7d0d4b39daa" title="Finishes an asynchronous file replace operation started with g_file_replace_async(). ">replace_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">etag</td><td>An entity tag for the current <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">Gio::File</a>. </td></tr>
    <tr><td class="paramname">make_backup</td><td>true if a backup of the existing file should be made. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileCreateFlags. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af10deca1d5c5d1f650d3b182624330dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::replace_contents </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>etag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>new_etag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the contents of the file with <em>contents</em> of <em>length</em> bytes. </p>
<p>If <em>etag</em> is specified (not an empty string) any existing file must have that etag, or a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with WRONG_ETAG will be thrown.</p>
<p>If <em>make_backup</em> is <code>true</code>, this function will attempt to make a backup of the file.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>The returned <em>new_etag</em> can be used to verify that the file hasn't changed the next time it is saved over. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">contents</td><td>A string containing the new contents for the file. </td></tr>
    <tr><td class="paramname">length</td><td>The length of <em>contents</em> in bytes. </td></tr>
    <tr><td class="paramname">etag</td><td>The old entity tag for the document. </td></tr>
    <tr><td class="paramname">make_backup</td><td><code>true</code> if a backup should be created. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileCreateFlags. </td></tr>
    <tr><td class="paramname">new_etag</td><td>A location to a new entity tag for the document. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae7febf1f0f3b4b9efca9fae469082846"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::replace_contents </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>etag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>new_etag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the contents of the file with <em>contents</em> of <em>length</em> bytes. </p>
<p>If <em>etag</em> is specified (not an empty string) any existing file must have that etag, or a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with WRONG_ETAG will be thrown.</p>
<p>If <em>make_backup</em> is <code>true</code>, this function will attempt to make a backup of the file.</p>
<p>The returned <em>new_etag</em> can be used to verify that the file hasn't changed the next time it is saved over. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">contents</td><td>A string containing the new contents for the file. </td></tr>
    <tr><td class="paramname">length</td><td>The length of <em>contents</em> in bytes. </td></tr>
    <tr><td class="paramname">etag</td><td>The old entity tag for the document. </td></tr>
    <tr><td class="paramname">make_backup</td><td><code>true</code> if a backup should be created. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileCreateFlags. </td></tr>
    <tr><td class="paramname">new_etag</td><td>A location to a new entity tag for the document. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a23126b43cd262b63c0e458c3a4d0b65c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::replace_contents </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>etag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>new_etag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the contents of the file with <em>contents</em>. </p>
<p>If <em>etag</em> is specified (not an empty string) any existing file must have that etag, or a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with WRONG_ETAG will be thrown.</p>
<p>If <em>make_backup</em> is <code>true</code>, this function will attempt to make a backup of the file.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>The returned <em>new_etag</em> can be used to verify that the file hasn't changed the next time it is saved over. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">contents</td><td>A string containing the new contents for the file. </td></tr>
    <tr><td class="paramname">etag</td><td>The old entity tag for the document. </td></tr>
    <tr><td class="paramname">make_backup</td><td><code>true</code> if a backup should be created. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileCreateFlags. </td></tr>
    <tr><td class="paramname">new_etag</td><td>A location to a new entity tag for the document. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaf33a17461ff4f70fed06818e364f617"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::replace_contents </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>etag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>new_etag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces the contents of the file with <em>contents</em>. </p>
<p>If <em>etag</em> is specified (not an empty string) any existing file must have that etag, or a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with WRONG_ETAG will be thrown.</p>
<p>If <em>make_backup</em> is <code>true</code>, this function will attempt to make a backup of the file.</p>
<p>The returned <em>new_etag</em> can be used to verify that the file hasn't changed the next time it is saved over. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">contents</td><td>A string containing the new contents for the file. </td></tr>
    <tr><td class="paramname">etag</td><td>The old entity tag for the document. </td></tr>
    <tr><td class="paramname">make_backup</td><td><code>true</code> if a backup should be created. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileCreateFlags. </td></tr>
    <tr><td class="paramname">new_etag</td><td>A location to a new entity tag for the document. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad33b24a7942429157f47379f4353378c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::replace_contents_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>etag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts an asynchronous replacement of the file with the given <em>contents</em> of <em>length</em> bytes. </p>
<p><em>etag</em> will replace the document's current entity tag.</p>
<p>When this operation has completed, <em>slot</em> will be called and the operation can be finalized with <a class="el" href="classGio_1_1File.html#afbe0e644bafcb88ce52b62de803167cd" title="Finishes an asynchronous replace of the given file . ">replace_contents_finish()</a>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>If <em>make_backup</em> is true, this function will attempt to make a backup of the file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback to call when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
    <tr><td class="paramname">contents</td><td>String of contents to replace the file with. </td></tr>
    <tr><td class="paramname">length</td><td>The length of <em>contents</em> in bytes. </td></tr>
    <tr><td class="paramname">etag</td><td>a new entity tag for the file. </td></tr>
    <tr><td class="paramname">make_backup</td><td>true if a backup should be created. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileCreateFlags. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9a1c445e84124e16294974a73f2f1bbb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::replace_contents_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>etag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts an asynchronous replacement of the file with the given <em>contents</em> of <em>length</em> bytes. </p>
<p><em>etag</em> will replace the document's current entity tag.</p>
<p>When this operation has completed, <em>slot</em> will be called and the operation can be finalized with <a class="el" href="classGio_1_1File.html#afbe0e644bafcb88ce52b62de803167cd" title="Finishes an asynchronous replace of the given file . ">replace_contents_finish()</a>.</p>
<p>If <em>make_backup</em> is true, this function will attempt to make a backup of the file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback to call when the request is satisfied. </td></tr>
    <tr><td class="paramname">contents</td><td>String of contents to replace the file with. </td></tr>
    <tr><td class="paramname">length</td><td>The length of <em>contents</em> in bytes. </td></tr>
    <tr><td class="paramname">etag</td><td>a new entity tag for the file. </td></tr>
    <tr><td class="paramname">make_backup</td><td>true if a backup should be created. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileCreateFlags. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a380d6ce6362fc05e0e18ff1b881ceac7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::replace_contents_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>etag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts an asynchronous replacement of the file with the given <em>contents</em> of <em>length</em> bytes. </p>
<p><em>etag</em> will replace the document's current entity tag.</p>
<p>When this operation has completed, <em>slot</em> will be called and the operation can be finalized with <a class="el" href="classGio_1_1File.html#afbe0e644bafcb88ce52b62de803167cd" title="Finishes an asynchronous replace of the given file . ">replace_contents_finish()</a>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>If <em>make_backup</em> is true, this function will attempt to make a backup of the file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback to call when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
    <tr><td class="paramname">contents</td><td>String of contents to replace the file with. </td></tr>
    <tr><td class="paramname">etag</td><td>a new entity tag for the file. </td></tr>
    <tr><td class="paramname">make_backup</td><td>true if a backup should be created. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileCreateFlags. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6fc86aab90620881899a701c2b2775cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::replace_contents_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>etag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts an asynchronous replacement of the file with the given <em>contents</em>. </p>
<p><em>etag</em> will replace the document's current entity tag.</p>
<p>When this operation has completed, <em>slot</em> will be called and the operation can be finalized with <a class="el" href="classGio_1_1File.html#afbe0e644bafcb88ce52b62de803167cd" title="Finishes an asynchronous replace of the given file . ">replace_contents_finish()</a>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>If <em>make_backup</em> is true, this function will attempt to make a backup of the file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback to call when the request is satisfied. </td></tr>
    <tr><td class="paramname">contents</td><td>String of contents to replace the file with. </td></tr>
    <tr><td class="paramname">etag</td><td>a new entity tag for the file. </td></tr>
    <tr><td class="paramname">make_backup</td><td>true if a backup should be created. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileCreateFlags. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4e6caba24b605600338ffdab6901620e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::replace_contents_bytes_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; const <a class="el" href="classGlib_1_1Bytes.html">Glib::Bytes</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>etag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classGio_1_1File.html#ad33b24a7942429157f47379f4353378c" title="Starts an asynchronous replacement of the file with the given contents of length bytes. ">replace_contents_async()</a> but takes a Gio::Bytes input instead. </p>
<p>When this operation has completed, <em>slot</em> will be called and the operation can be finalized with <a class="el" href="classGio_1_1File.html#afbe0e644bafcb88ce52b62de803167cd" title="Finishes an asynchronous replace of the given file . ">replace_contents_finish()</a>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>If <em>make_backup</em> is true, this function will attempt to make a backup of the file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback to call when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
    <tr><td class="paramname">contents</td><td>Bytes of contents to replace the file with. </td></tr>
    <tr><td class="paramname">etag</td><td>a new entity tag for the file. </td></tr>
    <tr><td class="paramname">make_backup</td><td>true if a backup should be created. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileCreateFlags. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afa8e166a3ffdd266eff7fab5b24154bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::replace_contents_bytes_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; const <a class="el" href="classGlib_1_1Bytes.html">Glib::Bytes</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>contents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>etag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classGio_1_1File.html#ad33b24a7942429157f47379f4353378c" title="Starts an asynchronous replacement of the file with the given contents of length bytes. ">replace_contents_async()</a> but takes a Gio::Bytes input instead. </p>
<p>When this operation has completed, <em>slot</em> will be called and the operation can be finalized with <a class="el" href="classGio_1_1File.html#afbe0e644bafcb88ce52b62de803167cd" title="Finishes an asynchronous replace of the given file . ">replace_contents_finish()</a>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>If <em>make_backup</em> is true, this function will attempt to make a backup of the file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback to call when the request is satisfied. </td></tr>
    <tr><td class="paramname">contents</td><td>Bytes of contents to replace the file with. </td></tr>
    <tr><td class="paramname">etag</td><td>a new entity tag for the file. </td></tr>
    <tr><td class="paramname">make_backup</td><td>true if a backup should be created. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileCreateFlags. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afbe0e644bafcb88ce52b62de803167cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::replace_contents_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>new_etag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finishes an asynchronous replace of the given file . </p>
<p>See <a class="el" href="classGio_1_1File.html#ad33b24a7942429157f47379f4353378c" title="Starts an asynchronous replacement of the file with the given contents of length bytes. ">replace_contents_async()</a>. Sets <em>new_etag</em> to the new entity tag for the document. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
    <tr><td class="paramname">new_etag</td><td>A location of a new entity tag for the document. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af0372ffd3f535f39b7e48c0483e4c1f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::replace_contents_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finishes an asynchronous replace of the given file . </p>
<p>See <a class="el" href="classGio_1_1File.html#ad33b24a7942429157f47379f4353378c" title="Starts an asynchronous replacement of the file with the given contents of length bytes. ">replace_contents_async()</a>. Sets <em>new_etag</em> to the new entity tag for the document. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. for the document. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4e5fe0438c73500d3d6ec7d0d4b39daa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileOutputStream.html">FileOutputStream</a>&gt; Gio::File::replace_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finishes an asynchronous file replace operation started with g_file_replace_async(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file. ">FileOutputStream</a>, or <code>nullptr</code> on error. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="af483e2ddc29cbb6cd1ad751403247bad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileIOStream.html">FileIOStream</a>&gt; Gio::File::replace_readwrite </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>etag</em> = <code><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an output stream for overwriting the file in readwrite mode, possibly creating a backup copy of the file first. </p>
<p>If the file doesn't exist, it will be created.</p>
<p>For details about the behaviour, see <a class="el" href="classGio_1_1File.html#ad7cf0360096504e40f799fde5cc8e9de" title="Returns an output stream for overwriting the file, possibly creating a backup copy of the file first...">replace()</a> which does the same thing but returns an output stream only.</p>
<p>Note that in many non-local file cases read and write streams are not supported, so make sure you really need to do read and write streaming, rather than just opening for reading or writing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">etag</td><td>An optional entity tag for the current Glib::File. </td></tr>
    <tr><td class="paramname">make_backup</td><td><code>true</code> if a backup should be created. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileCreateFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file. ">FileOutputStream</a>.</dd></dl>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000069">Since glibmm 2.24:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a0c4aa84e74b27a67bce6b5fdccb91449"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileIOStream.html">FileIOStream</a>&gt; Gio::File::replace_readwrite </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>etag</em> = <code><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an output stream for overwriting the file in readwrite mode, possibly creating a backup copy of the file first. </p>
<p>If the file doesn't exist, it will be created.</p>
<p>For details about the behaviour, see <a class="el" href="classGio_1_1File.html#ad7cf0360096504e40f799fde5cc8e9de" title="Returns an output stream for overwriting the file, possibly creating a backup copy of the file first...">replace()</a> which does the same thing but returns an output stream only.</p>
<p>Note that in many non-local file cases read and write streams are not supported, so make sure you really need to do read and write streaming, rather than just opening for reading or writing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">etag</td><td>An optional entity tag for the current Glib::File. </td></tr>
    <tr><td class="paramname">make_backup</td><td><code>true</code> if a backup should be created. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileCreateFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileOutputStream.html" title="FileOutputStream provides output streams that write their content to a file. ">FileOutputStream</a>.</dd></dl>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000070">Since glibmm 2.24:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="af5ebbb5e33c0afd302add9863f2d8c24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::replace_readwrite_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>etag</em> = <code><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asyncronously overwrites the file in read-write mode, replacing the contents, possibly creating a backup copy of the file first. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#af483e2ddc29cbb6cd1ad751403247bad" title="Returns an output stream for overwriting the file in readwrite mode, possibly creating a backup copy ...">replace_readwrite()</a> which is the synchronous version of this call.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a47d246b8ff87be3aaef635ac123d1e44" title="Finishes an asynchronous file replace operation started with g_file_replace_readwrite_async(). ">replace_readwrite_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">etag</td><td>An entity tag for the current <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">Gio::File</a>. </td></tr>
    <tr><td class="paramname">make_backup</td><td>true if a backup of the existing file should be made. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileCreateFlags. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request.</td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000071">Since glibmm 2.24:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a38b7d1782f03a4d6a4dbf3be16321324"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::replace_readwrite_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>etag</em> = <code><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>make_backup</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga500a44e123fd4c578f8af9ddef2f7601">FileCreateFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga500a44e123fd4c578f8af9ddef2f7601a823486fdb9088ef7b93e208bc6b62e88">FILE_CREATE_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asyncronously overwrites the file in read-write mode, replacing the contents, possibly creating a backup copy of the file first. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#af483e2ddc29cbb6cd1ad751403247bad" title="Returns an output stream for overwriting the file in readwrite mode, possibly creating a backup copy ...">replace_readwrite()</a> which is the synchronous version of this call. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a47d246b8ff87be3aaef635ac123d1e44" title="Finishes an asynchronous file replace operation started with g_file_replace_readwrite_async(). ">replace_readwrite_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">etag</td><td>An entity tag for the current <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">Gio::File</a>. </td></tr>
    <tr><td class="paramname">make_backup</td><td>true if a backup of the existing file should be made. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileCreateFlags. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request.</td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000072">Since glibmm 2.24:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a47d246b8ff87be3aaef635ac123d1e44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1FileIOStream.html">FileIOStream</a>&gt; Gio::File::replace_readwrite_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finishes an asynchronous file replace operation started with g_file_replace_readwrite_async(). </p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000036">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1FileIOStream.html" title="FileIOStream provides input streams that take their content from a file. ">FileIOStream</a>, or <code>nullptr</code> on error. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="ac5e286d421c7236df39881f8ce0a4e03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1File.html">File</a>&gt; Gio::File::resolve_relative_path </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>relative_path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolves a relative path for <em>file</em> to an absolute path. </p>
<p>This call does no blocking I/O.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">relative_path</td><td>A given relative path string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> to the resolved path. <code>nullptr</code> if <em>relative_path</em> is <code>nullptr</code> or if <em>file</em> is invalid. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="a4f4373b8694c346a6908195f1f2644f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::set_attribute_byte_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_BYTE_STRING to <em>value</em>. </p>
<p>If <em>attribute</em> is of a different type, this operation will fail, returning <code>false</code>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> will be thrown with CANCELLED.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attribute</td><td>A string containing the attribute's name. </td></tr>
    <tr><td class="paramname">value</td><td>A string containing the attribute's new value. </td></tr>
    <tr><td class="paramname">flags</td><td>A FileQueryInfoFlags. </td></tr>
    <tr><td class="paramname">cancellable</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <em>attribute</em> was successfully set to <em>value</em> in the <em>file</em>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a09f574259052186e1b516bdcbe696710"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::set_attribute_byte_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1File.html#a4f4373b8694c346a6908195f1f2644f3" title="Sets attribute of type FILE_ATTRIBUTE_TYPE_BYTE_STRING to value. ">set_attribute_byte_string()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="ab0290ecba7b06ccf7736e2292708667e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::set_attribute_int32 </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint32&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_INT32 to <em>value</em>. </p>
<p>If <em>attribute</em> is of a different type, this operation will fail.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> will be thrown with CANCELLED.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attribute</td><td>A string containing the attribute's name. </td></tr>
    <tr><td class="paramname">value</td><td>A #gint32 containing the attribute's new value. </td></tr>
    <tr><td class="paramname">flags</td><td>A FileQueryInfoFlags. </td></tr>
    <tr><td class="paramname">cancellable</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <em>attribute</em> was successfully set to <em>value</em> in the <em>file</em>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a4a707084a3c0a963548a21d17d0ec0b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::set_attribute_int32 </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint32&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1File.html#ab0290ecba7b06ccf7736e2292708667e" title="Sets attribute of type FILE_ATTRIBUTE_TYPE_INT32 to value. ">set_attribute_int32()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="a111d73a2d003e5a5a4c5f86c7c3d2fb7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::set_attribute_int64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint64&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_INT64 to <em>value</em>. </p>
<p>If <em>attribute</em> is of a different type, this operation will fail.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> will be thrown with CANCELLED.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attribute</td><td>A string containing the attribute's name. </td></tr>
    <tr><td class="paramname">value</td><td>A #guint64 containing the attribute's new value. </td></tr>
    <tr><td class="paramname">flags</td><td>A FileQueryInfoFlags. </td></tr>
    <tr><td class="paramname">cancellable</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <em>attribute</em> was successfully set, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a4477b0063110951b26c855696ec34802"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::set_attribute_int64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gint64&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1File.html#a111d73a2d003e5a5a4c5f86c7c3d2fb7" title="Sets attribute of type FILE_ATTRIBUTE_TYPE_INT64 to value. ">set_attribute_int64()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="a5ce5f43fd5e2836ac1989a54d3233ff6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::set_attribute_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_STRING to <em>value</em>. </p>
<p>If <em>attribute</em> is of a different type, this operation will fail.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> will be thrown with CANCELLED.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attribute</td><td>A string containing the attribute's name. </td></tr>
    <tr><td class="paramname">value</td><td>A string containing the attribute's value. </td></tr>
    <tr><td class="paramname">flags</td><td>FileQueryInfoFlags. </td></tr>
    <tr><td class="paramname">cancellable</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <em>attribute</em> was successfully set, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a75fa7e1a44e97a910d232f2b4ab4bfdd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::set_attribute_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1File.html#a5ce5f43fd5e2836ac1989a54d3233ff6" title="Sets attribute of type FILE_ATTRIBUTE_TYPE_STRING to value. ">set_attribute_string()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="ae53b0f4d2214e050a290c8e35cac0f27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::set_attribute_uint32 </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">guint32&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_UINT32 to <em>value</em>. </p>
<p>If <em>attribute</em> is of a different type, this operation will fail.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> will be thrown with CANCELLED.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attribute</td><td>A string containing the attribute's name. </td></tr>
    <tr><td class="paramname">value</td><td>A #guint32 containing the attribute's new value. </td></tr>
    <tr><td class="paramname">flags</td><td>A FileQueryInfoFlags. </td></tr>
    <tr><td class="paramname">cancellable</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <em>attribute</em> was successfully set to <em>value</em> in the <em>file</em>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a7f769f140143f2e96a7587a10b6792a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::set_attribute_uint32 </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">guint32&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1File.html#ae53b0f4d2214e050a290c8e35cac0f27" title="Sets attribute of type FILE_ATTRIBUTE_TYPE_UINT32 to value. ">set_attribute_uint32()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="a48638081fd7af772a39af59a558b17f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::set_attribute_uint64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">guint64&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets <em>attribute</em> of type FILE_ATTRIBUTE_TYPE_UINT64 to <em>value</em>. </p>
<p>If <em>attribute</em> is of a different type, this operation will fail.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> will be thrown with CANCELLED.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attribute</td><td>A string containing the attribute's name. </td></tr>
    <tr><td class="paramname">value</td><td>A #guint64 containing the attribute's new value. </td></tr>
    <tr><td class="paramname">flags</td><td>A FileQueryInfoFlags. </td></tr>
    <tr><td class="paramname">cancellable</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the <em>attribute</em> was successfully set to <em>value</em> in the <em>file</em>, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a4aa77b3580df88cfd3d7231af78155c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::set_attribute_uint64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">guint64&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1File.html#a48638081fd7af772a39af59a558b17f7" title="Sets attribute of type FILE_ATTRIBUTE_TYPE_UINT64 to value. ">set_attribute_uint64()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="a14165fba9bf7d91448c3207407ae50c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::set_attributes_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0a4e412b5c20ae24607975e36b1d2142c9">FILE_QUERY_INFO_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously sets the attributes of file with info. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a69d9e40a85b96809abc5189b34e8d9b7" title="Tries to set all attributes in the FileInfo on the target values, not stopping on the first error...">set_attributes_from_info()</a> which is the synchronous version of this call. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#aefd45aed7b975b6e204e67927de2817a">set_attributes_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>A <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes. ">FileInfo</a>. </td></tr>
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileQueryInfoFlags. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a61317a1980318537aa8ada7bb8cc2390"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::set_attributes_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0a4e412b5c20ae24607975e36b1d2142c9">FILE_QUERY_INFO_NONE</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously sets the attributes of file with info. </p>
<p>For more details, see <a class="el" href="classGio_1_1File.html#a69d9e40a85b96809abc5189b34e8d9b7" title="Tries to set all attributes in the FileInfo on the target values, not stopping on the first error...">set_attributes_from_info()</a> which is the synchronous version of this call. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#aefd45aed7b975b6e204e67927de2817a">set_attributes_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>A <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes. ">FileInfo</a>. </td></tr>
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileQueryInfoFlags. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aefd45aed7b975b6e204e67927de2817a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::set_attributes_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a69d9e40a85b96809abc5189b34e8d9b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::set_attributes_from_info </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0a4e412b5c20ae24607975e36b1d2142c9">FILE_QUERY_INFO_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to set all attributes in the <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes. ">FileInfo</a> on the target values, not stopping on the first error. </p>
<p>If there is any error during this operation then a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> will be thrown. <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Error</a> on particular fields are flagged by setting the "status" field in the attribute value to FILE_ATTRIBUTE_STATUS_ERROR_SETTING, which means you can also detect further errors.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>A <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes. ">FileInfo</a>. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileQueryInfoFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if there was any error, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ae9f6975ffef28f0d7145601a99de0903"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::set_attributes_from_info </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1FileInfo.html">FileInfo</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga2cb7bdea61353f0999607785abd032c0">FileQueryInfoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga2cb7bdea61353f0999607785abd032c0a4e412b5c20ae24607975e36b1d2142c9">FILE_QUERY_INFO_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to set all attributes in the <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes. ">FileInfo</a> on the target values, not stopping on the first error. </p>
<p>If there is any error during this operation then a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> will be thrown. <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Error</a> on particular fields are flagged by setting the "status" field in the attribute value to FILE_ATTRIBUTE_STATUS_ERROR_SETTING, which means you can also detect further errors.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>A <a class="el" href="classGio_1_1FileInfo.html" title="FileInfo implements methods for getting information that all files should contain, and allows for manipulation of extended attributes. ">FileInfo</a>. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of FileQueryInfoFlags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if there was any error, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a3dd75810d7c9ebafac398288f5afc018"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1File.html">File</a>&gt; Gio::File::set_display_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>display_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Renames <em>file</em> to the specified display name. </p>
<p>The display name is converted from UTF8 to the correct encoding for the target filesystem if possible and the <em>file</em> is renamed to this.</p>
<p>If you want to implement a rename operation in the user interface the edit name (FILE_ATTRIBUTE_STANDARD_EDIT_NAME) should be used as the initial value in the rename widget, and then the result after editing should be passed to g_file_set_display_name().</p>
<p>On success the resulting converted filename is returned.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> will be thrown with CANCELLED.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">display_name</td><td>A string. </td></tr>
    <tr><td class="paramname">cancellable</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> specifying what <em>file</em> was renamed to, or <code>nullptr</code> if there was an error. </dd></dl>

</div>
</div>
<a class="anchor" id="a8c2aa80b2d0ecdd22f0222c8ce42d177"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1File.html">File</a>&gt; Gio::File::set_display_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>display_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1File.html#a3dd75810d7c9ebafac398288f5afc018" title="Renames file to the specified display name. ">set_display_name()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="a0ac539d7758b9c0de809f8c83e0bba79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::set_display_name_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>display_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously sets the display name for a given <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">Gio::File</a>. </p>
<p>For the synchronous version of this function, see <a class="el" href="classGio_1_1File.html#a3dd75810d7c9ebafac398288f5afc018" title="Renames file to the specified display name. ">set_display_name()</a>. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a2abb19573076b426434f7d8d2d5a0cdb" title="Finishes setting a display name started with g_file_set_display_name_async(). ">set_display_name_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">display_name</td><td>A string. </td></tr>
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a74d219d321dca3d438f876256dee82d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::set_display_name_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>display_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously sets the display name for a given <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">Gio::File</a>. </p>
<p>For the synchronous version of this function, see <a class="el" href="classGio_1_1File.html#a3dd75810d7c9ebafac398288f5afc018" title="Renames file to the specified display name. ">set_display_name()</a>. When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a2abb19573076b426434f7d8d2d5a0cdb" title="Finishes setting a display name started with g_file_set_display_name_async(). ">set_display_name_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">display_name</td><td>A string. </td></tr>
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2abb19573076b426434f7d8d2d5a0cdb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGio_1_1File.html">File</a>&gt; Gio::File::set_display_name_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finishes setting a display name started with g_file_set_display_name_async(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGio_1_1File.html" title="File and directory handling. ">File</a> or <code>nullptr</code> on error. Free the returned object with Glib::object_unref(). </dd></dl>

</div>
</div>
<a class="anchor" id="aa4438daeeb2171e3065bb677b6768721"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::start_mountable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>start_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gab628e70b1d028b3bc9b02b0d3b8acf2d">DriveStartFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#gab628e70b1d028b3bc9b02b0d3b8acf2da9fe888bc06249b6238868b8fffa4c9cd">DRIVE_START_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts a file of type Mountable. </p>
<p>Using <em>start_operation</em>, you can request callbacks when, for instance, passwords are needed during authentication.</p>
<p>When this operation has completed, <em>slot</em> will be called and the operation can be finalized with <a class="el" href="classGio_1_1File.html#af11e51943807876180474b39d2e521ac" title="Finishes a start operation. ">start_mountable_finish()</a>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback to call when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
    <tr><td class="paramname">start_operation</td><td>A <a class="el" href="classGio_1_1MountOperation.html" title="Authentication methods for mountable locations. ">MountOperation</a>, or <code>nullptr</code> to avoid user interaction. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000079">Since glibmm 2.24:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ad629eaf059b2e05b1f9bfc10c5732974"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::start_mountable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>start_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#gab628e70b1d028b3bc9b02b0d3b8acf2d">DriveStartFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#gab628e70b1d028b3bc9b02b0d3b8acf2da9fe888bc06249b6238868b8fffa4c9cd">DRIVE_START_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts a file of type Mountable. </p>
<p>Using <em>start_operation</em>, you can request callbacks when, for instance, passwords are needed during authentication.</p>
<p>When this operation has completed, <em>slot</em> will be called and the operation can be finalized with <a class="el" href="classGio_1_1File.html#af11e51943807876180474b39d2e521ac" title="Finishes a start operation. ">start_mountable_finish()</a>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback to call when the request is satisfied. </td></tr>
    <tr><td class="paramname">start_operation</td><td>A <a class="el" href="classGio_1_1MountOperation.html" title="Authentication methods for mountable locations. ">MountOperation</a>, or <code>nullptr</code> to avoid user interaction. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000080">Since glibmm 2.24:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="af11e51943807876180474b39d2e521ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::start_mountable_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finishes a start operation. </p>
<p>See g_file_start_mountable() for details.</p>
<p>Finish an asynchronous start operation that was started with g_file_start_mountable().</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000039">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the operation finished successfully. <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ac101831f87245a881c338014f15d38d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::stop_mountable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>start_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44a1599c4ebeb5c0c6e9c312a4b9e4231b6">MOUNT_UNMOUNT_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops a file of type Mountable. </p>
<p>Using <em>start_operation</em>, you can request callbacks when, for instance, passwords are needed during authentication.</p>
<p>When this operation has completed, <em>slot</em> will be called and the operation can be finalized with <a class="el" href="classGio_1_1File.html#a195990af8825745d0d26147174824565" title="Finishes an stop operation, see g_file_stop_mountable() for details. ">stop_mountable_finish()</a>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback to call when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
    <tr><td class="paramname">start_operation</td><td>A <a class="el" href="classGio_1_1MountOperation.html" title="Authentication methods for mountable locations. ">MountOperation</a>, or <code>nullptr</code> to avoid user interaction. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000081">Since glibmm 2.24:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a5ccfb3006c2bc69a32e5055939b462d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::stop_mountable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>start_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44a1599c4ebeb5c0c6e9c312a4b9e4231b6">MOUNT_UNMOUNT_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stops a file of type Mountable. </p>
<p>Using <em>start_operation</em>, you can request callbacks when, for instance, passwords are needed during authentication.</p>
<p>When this operation has completed, <em>slot</em> will be called and the operation can be finalized with <a class="el" href="classGio_1_1File.html#a195990af8825745d0d26147174824565" title="Finishes an stop operation, see g_file_stop_mountable() for details. ">stop_mountable_finish()</a>.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback to call when the request is satisfied. </td></tr>
    <tr><td class="paramname">start_operation</td><td>A <a class="el" href="classGio_1_1MountOperation.html" title="Authentication methods for mountable locations. ">MountOperation</a>, or <code>nullptr</code> to avoid user interaction. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation</td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000082">Since glibmm 2.24:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a195990af8825745d0d26147174824565"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::stop_mountable_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finishes an stop operation, see g_file_stop_mountable() for details. </p>
<p>Finish an asynchronous stop operation that was started with g_file_stop_mountable().</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000040">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the operation finished successfully. <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ab666a9ec3922903646504f4080758522"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::supports_thread_contexts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <em>file</em> supports [thread-default contexts][g-main-context-push-thread-default-context]. </p>
<p>If this returns <code>false</code>, you cannot perform asynchronous operations on <em>file</em> in a thread that has a thread-default context.</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000046">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Whether or not <em>file</em> supports thread-default contexts. </dd></dl>

</div>
</div>
<a class="anchor" id="acae5ecd962e832cf8d538877f4118da8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::trash </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends <em>file</em> to the "Trashcan", if possible. </p>
<p>This is similar to deleting it, but the user can recover it before emptying the trashcan. Not all file systems support trashing, so this call can throw a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with NOT_SUPPORTED.</p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> will be thrown with CANCELLED.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cancellable</td><td><a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on successful trash, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a1925736f9af338eaf9942468b4d6d65e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::trash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classGio_1_1File.html#a1925736f9af338eaf9942468b4d6d65e" title="A trash() convenience overload. ">trash()</a> convenience overload. </p>

</div>
</div>
<a class="anchor" id="afab15e7d88376d144253bce7bfba2730"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::trash_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot_ready</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously sends the file to the Trash location, if possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot_ready</td><td>A SlotAsyncReady to call when the request is satisfied </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request </td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_38"><dt><b><a class="el" href="since_2_38.html#_since_2_38000011">Since glibmm 2.38:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a5cb6f01422a66c141ba721fc8790f10a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::trash_async </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot_ready</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>io_priority</em> = <code><a class="el" href="namespaceGlib.html#a0c450f82b9e34689e2dda2038ba7834fa597ed3aa6067516c9c752896f3816b5e">Glib::PRIORITY_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously sends the file to the Trash location, if possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot_ready</td><td>A SlotAsyncReady to call when the request is satisfied </td></tr>
    <tr><td class="paramname">io_priority</td><td>The I/O priority of the request </td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_38"><dt><b><a class="el" href="since_2_38.html#_since_2_38000012">Since glibmm 2.38:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a7ee78bd712cb24661335cee8e3d29344"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::trash_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finishes an asynchronous file trashing operation, started with g_file_trash_async(). </p>
<p>Virtual: trash_finish </p><dl class="since_2_38"><dt><b><a class="el" href="since_2_38.html#_since_2_38000013">Since glibmm 2.38:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> on successful trash, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a5b687c8f19411e955bb069c469be92b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::unmount_mountable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44a1599c4ebeb5c0c6e9c312a4b9e4231b6">MOUNT_UNMOUNT_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unmounts a file of type FILE_TYPE_MOUNTABLE. </p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a51458cf04ad25e4a784a3ebcb906155d" title="Finishes an unmount operation, see g_file_unmount_mountable_with_operation() for details. ">unmount_mountable_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab6c8e9ef0e5d83a271c8307b18e779d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::unmount_mountable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44a1599c4ebeb5c0c6e9c312a4b9e4231b6">MOUNT_UNMOUNT_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unmounts a file of type FILE_TYPE_MOUNTABLE. </p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a51458cf04ad25e4a784a3ebcb906155d" title="Finishes an unmount operation, see g_file_unmount_mountable_with_operation() for details. ">unmount_mountable_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a95f3e87e198493f4332a08aa79f6ebd3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::unmount_mountable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44a1599c4ebeb5c0c6e9c312a4b9e4231b6">MOUNT_UNMOUNT_NONE</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unmounts a file of type FILE_TYPE_MOUNTABLE. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>Flags affecting the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a13f7cceb9754a7498789593dd58d818c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::unmount_mountable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1Cancellable.html">Cancellable</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>cancellable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>mount_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44a1599c4ebeb5c0c6e9c312a4b9e4231b6">MOUNT_UNMOUNT_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unmounts a file of type FILE_TYPE_MOUNTABLE. </p>
<p>The operation can be cancelled by triggering the cancellable object from another thread. If the operation was cancelled, a <a class="el" href="classGio_1_1Error.html" title="Exception class for giomm errors. ">Gio::Error</a> with CANCELLED will be thrown.</p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a51458cf04ad25e4a784a3ebcb906155d" title="Finishes an unmount operation, see g_file_unmount_mountable_with_operation() for details. ">unmount_mountable_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">cancellable</td><td>A <a class="el" href="classGio_1_1Cancellable.html" title="Allows actions to be cancelled. ">Cancellable</a> object which can be used to cancel the operation. </td></tr>
    <tr><td class="paramname">mount_operation</td><td>A <a class="el" href="classGio_1_1MountOperation.html" title="Authentication methods for mountable locations. ">MountOperation</a> </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000073">Since glibmm 2.24:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ad82d5b087fef21cbadcb9407d7f43223"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::unmount_mountable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceGio.html#aecaa02709f9ab83fa2b36d2571665cbe">SlotAsyncReady</a>&amp;&#160;</td>
          <td class="paramname"><em>slot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>mount_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44a1599c4ebeb5c0c6e9c312a4b9e4231b6">MOUNT_UNMOUNT_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unmounts a file of type FILE_TYPE_MOUNTABLE. </p>
<p>When the operation is finished, <em>slot</em> will be called. You can then call <a class="el" href="classGio_1_1File.html#a51458cf04ad25e4a784a3ebcb906155d" title="Finishes an unmount operation, see g_file_unmount_mountable_with_operation() for details. ">unmount_mountable_finish()</a> to get the result of the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slot</td><td>A callback slot which will be called when the request is satisfied. </td></tr>
    <tr><td class="paramname">mount_operation</td><td>A <a class="el" href="classGio_1_1MountOperation.html" title="Authentication methods for mountable locations. ">MountOperation</a> </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000074">Since glibmm 2.24:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="ae322b2d5f8f1d95023831c3964c9b015"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gio::File::unmount_mountable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1MountOperation.html">MountOperation</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>mount_operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__giommEnums.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44">MountUnmountFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceGio.html#ga9fa1b6a8eabf8f88e4cf6d611a4cff44a1599c4ebeb5c0c6e9c312a4b9e4231b6">MOUNT_UNMOUNT_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unmounts a file of type FILE_TYPE_MOUNTABLE. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mount_operation</td><td>A <a class="el" href="classGio_1_1MountOperation.html" title="Authentication methods for mountable locations. ">MountOperation</a> </td></tr>
    <tr><td class="paramname">flags</td><td>Flags affecting the operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000075">Since glibmm 2.24:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a51458cf04ad25e4a784a3ebcb906155d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gio::File::unmount_mountable_finish </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1AsyncResult.html">AsyncResult</a> &gt;&amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finishes an unmount operation, see g_file_unmount_mountable_with_operation() for details. </p>
<p>Finish an asynchronous unmount operation that was started with g_file_unmount_mountable_with_operation().</p>
<dl class="since_2_22"><dt><b><a class="el" href="since_2_22.html#_since_2_22000037">Since glibmm 2.22:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>A <a class="el" href="classGio_1_1AsyncResult.html" title="Provides a base class for implementing asynchronous function results. ">AsyncResult</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the operation finished successfully. <code>false</code> otherwise. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a69670cdc7cf63783d6f9370dcbd7cc3d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGio_1_1File.html">Gio::File</a> &gt; wrap </td>
          <td>(</td>
          <td class="paramtype">GFile *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>take_copy</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A <a class="el" href="namespaceGlib.html#a671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>The C instance. </td></tr>
    <tr><td class="paramname">take_copy</td><td>False if the result should take ownership of the C instance. True if it should take a new copy or ref. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A C++ instance that wraps this C instance. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Mar 31 2016 11:46:40 for glibmm by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
