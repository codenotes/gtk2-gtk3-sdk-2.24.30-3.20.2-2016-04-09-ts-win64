<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>glibmm: Glib::Regex Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">glibmm
   &#160;<span id="projectnumber">2.48.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceGlib.html">Glib</a></li><li class="navelem"><a class="el" href="classGlib_1_1Regex.html">Regex</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classGlib_1_1Regex-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Glib::Regex Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Perl-compatible regular expressions - matches strings against regular expressions.  
 <a href="classGlib_1_1Regex.html#details">More...</a></p>

<p><code>#include &lt;glibmm/regex.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6099ec7a4be34e4fec017a9d18eeb7f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#a6099ec7a4be34e4fec017a9d18eeb7f4">reference</a> () const </td></tr>
<tr class="memdesc:a6099ec7a4be34e4fec017a9d18eeb7f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the reference count for this object.  <a href="#a6099ec7a4be34e4fec017a9d18eeb7f4">More...</a><br /></td></tr>
<tr class="separator:a6099ec7a4be34e4fec017a9d18eeb7f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a661a9b85f52dbaaa68a6495ace7df50a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#a661a9b85f52dbaaa68a6495ace7df50a">unreference</a> () const </td></tr>
<tr class="memdesc:a661a9b85f52dbaaa68a6495ace7df50a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement the reference count for this object.  <a href="#a661a9b85f52dbaaa68a6495ace7df50a">More...</a><br /></td></tr>
<tr class="separator:a661a9b85f52dbaaa68a6495ace7df50a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640d1c5b6bc6ff05461dbf11b97e4477"><td class="memItemLeft" align="right" valign="top">GRegex*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#a640d1c5b6bc6ff05461dbf11b97e4477">gobj</a> ()</td></tr>
<tr class="memdesc:a640d1c5b6bc6ff05461dbf11b97e4477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C instance.  <a href="#a640d1c5b6bc6ff05461dbf11b97e4477">More...</a><br /></td></tr>
<tr class="separator:a640d1c5b6bc6ff05461dbf11b97e4477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c9e3ee8fd94e728128ff8eacb138c1"><td class="memItemLeft" align="right" valign="top">const GRegex*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#ae5c9e3ee8fd94e728128ff8eacb138c1">gobj</a> () const </td></tr>
<tr class="memdesc:ae5c9e3ee8fd94e728128ff8eacb138c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C instance.  <a href="#ae5c9e3ee8fd94e728128ff8eacb138c1">More...</a><br /></td></tr>
<tr class="separator:ae5c9e3ee8fd94e728128ff8eacb138c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6766b1090ea2e97757a5585aca14f926"><td class="memItemLeft" align="right" valign="top">GRegex*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#a6766b1090ea2e97757a5585aca14f926">gobj_copy</a> () const </td></tr>
<tr class="memdesc:a6766b1090ea2e97757a5585aca14f926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs.  <a href="#a6766b1090ea2e97757a5585aca14f926">More...</a><br /></td></tr>
<tr class="separator:a6766b1090ea2e97757a5585aca14f926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae302567d5aa9648f216b349be26375"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#aaae302567d5aa9648f216b349be26375">Regex</a> ()=delete</td></tr>
<tr class="separator:aaae302567d5aa9648f216b349be26375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb85b2ec990227be37232a50e3e135d2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#acb85b2ec990227be37232a50e3e135d2">Regex</a> (const <a class="el" href="classGlib_1_1Regex.html">Regex</a>&amp;)=delete</td></tr>
<tr class="separator:acb85b2ec990227be37232a50e3e135d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47a67fd6307c5e635d87c19d1c56b122"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1Regex.html">Regex</a>&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#a47a67fd6307c5e635d87c19d1c56b122">operator=</a> (const <a class="el" href="classGlib_1_1Regex.html">Regex</a>&amp;)=delete</td></tr>
<tr class="separator:a47a67fd6307c5e635d87c19d1c56b122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802f0517b6bb5d72e55bc1dcaa8174a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#a802f0517b6bb5d72e55bc1dcaa8174a5">get_pattern</a> () const </td></tr>
<tr class="memdesc:a802f0517b6bb5d72e55bc1dcaa8174a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the pattern string associated with <em>regex</em>, i.e. a copy of the string passed to g_regex_new().  <a href="#a802f0517b6bb5d72e55bc1dcaa8174a5">More...</a><br /></td></tr>
<tr class="separator:a802f0517b6bb5d72e55bc1dcaa8174a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7123b6f880561ff94134c808a254387"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#ac7123b6f880561ff94134c808a254387">get_max_backref</a> () const </td></tr>
<tr class="memdesc:ac7123b6f880561ff94134c808a254387"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of the highest back reference in the pattern, or 0 if the pattern does not contain back references.  <a href="#ac7123b6f880561ff94134c808a254387">More...</a><br /></td></tr>
<tr class="separator:ac7123b6f880561ff94134c808a254387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a891b0f5b73a2beb390330778a0114c94"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#a891b0f5b73a2beb390330778a0114c94">get_capture_count</a> () const </td></tr>
<tr class="memdesc:a891b0f5b73a2beb390330778a0114c94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of capturing subpatterns in the pattern.  <a href="#a891b0f5b73a2beb390330778a0114c94">More...</a><br /></td></tr>
<tr class="separator:a891b0f5b73a2beb390330778a0114c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaef8a96694c134997528e20af58f672"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#acaef8a96694c134997528e20af58f672">get_has_cr_or_lf</a> () const </td></tr>
<tr class="memdesc:acaef8a96694c134997528e20af58f672"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the pattern contains explicit CR or LF references.  <a href="#acaef8a96694c134997528e20af58f672">More...</a><br /></td></tr>
<tr class="separator:acaef8a96694c134997528e20af58f672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e9f0256d613e009055fc5ab4a77b074"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#a7e9f0256d613e009055fc5ab4a77b074">get_max_lookbehind</a> () const </td></tr>
<tr class="memdesc:a7e9f0256d613e009055fc5ab4a77b074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of characters in the longest lookbehind assertion in the pattern.  <a href="#a7e9f0256d613e009055fc5ab4a77b074">More...</a><br /></td></tr>
<tr class="separator:a7e9f0256d613e009055fc5ab4a77b074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a033e3e0480fc5904d307f06a35e3240b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#a033e3e0480fc5904d307f06a35e3240b">get_string_number</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; name) const </td></tr>
<tr class="memdesc:a033e3e0480fc5904d307f06a35e3240b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the number of the subexpression named <em>name</em>.  <a href="#a033e3e0480fc5904d307f06a35e3240b">More...</a><br /></td></tr>
<tr class="separator:a033e3e0480fc5904d307f06a35e3240b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac785eb93ccc7e89901467763e1592ed0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__glibmmEnums.html#gaaaedee3e1374af9f1d66ccd34252a68d">RegexCompileFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#ac785eb93ccc7e89901467763e1592ed0">get_compile_flags</a> () const </td></tr>
<tr class="memdesc:ac785eb93ccc7e89901467763e1592ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the compile options that <em>regex</em> was created with.  <a href="#ac785eb93ccc7e89901467763e1592ed0">More...</a><br /></td></tr>
<tr class="separator:ac785eb93ccc7e89901467763e1592ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81f29d12b42f6315195a329805869594"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#a81f29d12b42f6315195a329805869594">get_match_flags</a> () const </td></tr>
<tr class="memdesc:a81f29d12b42f6315195a329805869594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the match options that <em>regex</em> was created with.  <a href="#a81f29d12b42f6315195a329805869594">More...</a><br /></td></tr>
<tr class="separator:a81f29d12b42f6315195a329805869594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a55ce94fcdf6b24cc8d6cc2ba77ebf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#a52a55ce94fcdf6b24cc8d6cc2ba77ebf">match</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">string</a>, <a class="el" href="classGlib_1_1MatchInfo.html">Glib::MatchInfo</a>&amp; match_info, <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> match_options=static_cast&lt; <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> &gt;(0))</td></tr>
<tr class="memdesc:a52a55ce94fcdf6b24cc8d6cc2ba77ebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scans for a match in string for the pattern in <em>regex</em>.  <a href="#a52a55ce94fcdf6b24cc8d6cc2ba77ebf">More...</a><br /></td></tr>
<tr class="separator:a52a55ce94fcdf6b24cc8d6cc2ba77ebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad19516ab8cbcad727a159160a50bf26e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#ad19516ab8cbcad727a159160a50bf26e">match</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">string</a>, <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> match_options=static_cast&lt; <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> &gt;(0))</td></tr>
<tr class="memdesc:ad19516ab8cbcad727a159160a50bf26e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classGlib_1_1Regex.html#a52a55ce94fcdf6b24cc8d6cc2ba77ebf" title="Scans for a match in string for the pattern in regex. ">match()</a> method not requiring a <a class="el" href="classGlib_1_1MatchInfo.html" title="MatchInfo - MatchInfo is used to retrieve information about the regular expression match which create...">Glib::MatchInfo</a>.  <a href="#ad19516ab8cbcad727a159160a50bf26e">More...</a><br /></td></tr>
<tr class="separator:ad19516ab8cbcad727a159160a50bf26e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db06bc90254899673d1899a01f16652"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#a0db06bc90254899673d1899a01f16652">match</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">string</a>, int start_position, <a class="el" href="classGlib_1_1MatchInfo.html">Glib::MatchInfo</a>&amp; match_info, <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> match_options=static_cast&lt; <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> &gt;(0))</td></tr>
<tr class="memdesc:a0db06bc90254899673d1899a01f16652"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classGlib_1_1Regex.html#a52a55ce94fcdf6b24cc8d6cc2ba77ebf" title="Scans for a match in string for the pattern in regex. ">match()</a> method with a start position and a <a class="el" href="classGlib_1_1MatchInfo.html" title="MatchInfo - MatchInfo is used to retrieve information about the regular expression match which create...">Glib::MatchInfo</a>.  <a href="#a0db06bc90254899673d1899a01f16652">More...</a><br /></td></tr>
<tr class="separator:a0db06bc90254899673d1899a01f16652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723e145e1ed53d0c8c272386ec1bfbf6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#a723e145e1ed53d0c8c272386ec1bfbf6">match</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">string</a>, gssize string_len, int start_position, <a class="el" href="classGlib_1_1MatchInfo.html">Glib::MatchInfo</a>&amp; match_info, <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> match_options=static_cast&lt; <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> &gt;(0))</td></tr>
<tr class="memdesc:a723e145e1ed53d0c8c272386ec1bfbf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scans for a match in string for the pattern in <em>regex</em>.  <a href="#a723e145e1ed53d0c8c272386ec1bfbf6">More...</a><br /></td></tr>
<tr class="separator:a723e145e1ed53d0c8c272386ec1bfbf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbbd6f902b679b6b34554099a2ef67ef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#acbbd6f902b679b6b34554099a2ef67ef">match</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">string</a>, int start_position, <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> match_options)</td></tr>
<tr class="memdesc:acbbd6f902b679b6b34554099a2ef67ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classGlib_1_1Regex.html#a52a55ce94fcdf6b24cc8d6cc2ba77ebf" title="Scans for a match in string for the pattern in regex. ">match()</a> method with a start position not requiring a <a class="el" href="classGlib_1_1MatchInfo.html" title="MatchInfo - MatchInfo is used to retrieve information about the regular expression match which create...">Glib::MatchInfo</a>.  <a href="#acbbd6f902b679b6b34554099a2ef67ef">More...</a><br /></td></tr>
<tr class="separator:acbbd6f902b679b6b34554099a2ef67ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e0224ad096ba88c94e6e648a619f163"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#a6e0224ad096ba88c94e6e648a619f163">match</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">string</a>, gssize string_len, int start_position, <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> match_options)</td></tr>
<tr class="memdesc:a6e0224ad096ba88c94e6e648a619f163"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classGlib_1_1Regex.html#a52a55ce94fcdf6b24cc8d6cc2ba77ebf" title="Scans for a match in string for the pattern in regex. ">match()</a> method with a string length and start position not requiring a <a class="el" href="classGlib_1_1MatchInfo.html" title="MatchInfo - MatchInfo is used to retrieve information about the regular expression match which create...">Glib::MatchInfo</a>.  <a href="#a6e0224ad096ba88c94e6e648a619f163">More...</a><br /></td></tr>
<tr class="separator:a6e0224ad096ba88c94e6e648a619f163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d1e01c383fbf2d8646d3deaf50148f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#ac5d1e01c383fbf2d8646d3deaf50148f">match_all</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">string</a>, <a class="el" href="classGlib_1_1MatchInfo.html">Glib::MatchInfo</a>&amp; match_info, <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> match_options=static_cast&lt; <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> &gt;(0))</td></tr>
<tr class="memdesc:ac5d1e01c383fbf2d8646d3deaf50148f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Using the standard algorithm for regular expression matching only the longest match in the string is retrieved.  <a href="#ac5d1e01c383fbf2d8646d3deaf50148f">More...</a><br /></td></tr>
<tr class="separator:ac5d1e01c383fbf2d8646d3deaf50148f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2a2daa7f18c41ca37080cdd4842fae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#a8e2a2daa7f18c41ca37080cdd4842fae">match_all</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">string</a>, <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> match_options=static_cast&lt; <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> &gt;(0))</td></tr>
<tr class="memdesc:a8e2a2daa7f18c41ca37080cdd4842fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classGlib_1_1Regex.html#ac5d1e01c383fbf2d8646d3deaf50148f" title="Using the standard algorithm for regular expression matching only the longest match in the string is ...">match_all()</a> method not requiring a <a class="el" href="classGlib_1_1MatchInfo.html" title="MatchInfo - MatchInfo is used to retrieve information about the regular expression match which create...">Glib::MatchInfo</a>.  <a href="#a8e2a2daa7f18c41ca37080cdd4842fae">More...</a><br /></td></tr>
<tr class="separator:a8e2a2daa7f18c41ca37080cdd4842fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa28e51fff3244cb499d89ef0919d8ec3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#aa28e51fff3244cb499d89ef0919d8ec3">match_all</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">string</a>, int start_position, <a class="el" href="classGlib_1_1MatchInfo.html">Glib::MatchInfo</a>&amp; match_info, <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> match_options=static_cast&lt; <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> &gt;(0))</td></tr>
<tr class="memdesc:aa28e51fff3244cb499d89ef0919d8ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classGlib_1_1Regex.html#ac5d1e01c383fbf2d8646d3deaf50148f" title="Using the standard algorithm for regular expression matching only the longest match in the string is ...">match_all()</a> method with a start positon and a <a class="el" href="classGlib_1_1MatchInfo.html" title="MatchInfo - MatchInfo is used to retrieve information about the regular expression match which create...">Glib::MatchInfo</a>.  <a href="#aa28e51fff3244cb499d89ef0919d8ec3">More...</a><br /></td></tr>
<tr class="separator:aa28e51fff3244cb499d89ef0919d8ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bd99c4fe2a912d0e6dd56ddaf16f9e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#a3bd99c4fe2a912d0e6dd56ddaf16f9e0">match_all</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">string</a>, gssize string_len, int start_position, <a class="el" href="classGlib_1_1MatchInfo.html">Glib::MatchInfo</a>&amp; match_info, <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> match_options=static_cast&lt; <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> &gt;(0))</td></tr>
<tr class="memdesc:a3bd99c4fe2a912d0e6dd56ddaf16f9e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Using the standard algorithm for regular expression matching only the longest match in the string is retrieved, it is not possible to obtain all the available matches.  <a href="#a3bd99c4fe2a912d0e6dd56ddaf16f9e0">More...</a><br /></td></tr>
<tr class="separator:a3bd99c4fe2a912d0e6dd56ddaf16f9e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf0dc5f15631c6a090c5724bfa71f4bf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#adf0dc5f15631c6a090c5724bfa71f4bf">match_all</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">string</a>, int start_position, <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> match_options)</td></tr>
<tr class="memdesc:adf0dc5f15631c6a090c5724bfa71f4bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classGlib_1_1Regex.html#ac5d1e01c383fbf2d8646d3deaf50148f" title="Using the standard algorithm for regular expression matching only the longest match in the string is ...">match_all()</a> method with a start position not requiring a <a class="el" href="classGlib_1_1MatchInfo.html" title="MatchInfo - MatchInfo is used to retrieve information about the regular expression match which create...">Glib::MatchInfo</a>.  <a href="#adf0dc5f15631c6a090c5724bfa71f4bf">More...</a><br /></td></tr>
<tr class="separator:adf0dc5f15631c6a090c5724bfa71f4bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e393570c407f42cbf4e223fab19f499"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#a2e393570c407f42cbf4e223fab19f499">match_all</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">string</a>, gssize string_len, int start_position, <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> match_options)</td></tr>
<tr class="memdesc:a2e393570c407f42cbf4e223fab19f499"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classGlib_1_1Regex.html#ac5d1e01c383fbf2d8646d3deaf50148f" title="Using the standard algorithm for regular expression matching only the longest match in the string is ...">match_all()</a> method with a start position and a string length not requiring a <a class="el" href="classGlib_1_1MatchInfo.html" title="MatchInfo - MatchInfo is used to retrieve information about the regular expression match which create...">Glib::MatchInfo</a>.  <a href="#a2e393570c407f42cbf4e223fab19f499">More...</a><br /></td></tr>
<tr class="separator:a2e393570c407f42cbf4e223fab19f499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a447bbb8dc8ca457d1c1a4ab0740ced7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ContHandles.html#ga66b4a4b57f64be3fdc1972d8bf93723a">Glib::StringArrayHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#a447bbb8dc8ca457d1c1a4ab0740ced7e">split</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">string</a>, <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> match_options=static_cast&lt; <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> &gt;(0))</td></tr>
<tr class="memdesc:a447bbb8dc8ca457d1c1a4ab0740ced7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Breaks the string on the pattern, and returns an array of the tokens.  <a href="#a447bbb8dc8ca457d1c1a4ab0740ced7e">More...</a><br /></td></tr>
<tr class="separator:a447bbb8dc8ca457d1c1a4ab0740ced7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace0220e0ed2d7bd7771030e360e5141f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ContHandles.html#ga66b4a4b57f64be3fdc1972d8bf93723a">Glib::StringArrayHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#ace0220e0ed2d7bd7771030e360e5141f">split</a> (const gchar*<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">string</a>, gssize string_len, int start_position, <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> match_options=static_cast&lt; <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> &gt;(0), int max_tokens=0) const </td></tr>
<tr class="memdesc:ace0220e0ed2d7bd7771030e360e5141f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Breaks the string on the pattern, and returns an array of the tokens.  <a href="#ace0220e0ed2d7bd7771030e360e5141f">More...</a><br /></td></tr>
<tr class="separator:ace0220e0ed2d7bd7771030e360e5141f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f2f68542607519a358dd0ada1b5e3d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ContHandles.html#ga66b4a4b57f64be3fdc1972d8bf93723a">Glib::StringArrayHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#a3f2f68542607519a358dd0ada1b5e3d5">split</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">string</a>, int start_position, <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> match_options, int max_tokens) const </td></tr>
<tr class="separator:a3f2f68542607519a358dd0ada1b5e3d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f40c233d33361814252f8bfb00a716"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#ae9f40c233d33361814252f8bfb00a716">replace</a> (const gchar*<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">string</a>, gssize string_len, int start_position, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; replacement, <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> match_options=static_cast&lt; <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> &gt;(0))</td></tr>
<tr class="memdesc:ae9f40c233d33361814252f8bfb00a716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all occurrences of the pattern in <em>regex</em> with the replacement text.  <a href="#ae9f40c233d33361814252f8bfb00a716">More...</a><br /></td></tr>
<tr class="separator:ae9f40c233d33361814252f8bfb00a716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add3848dcec1b22547ab57fddbfdaec1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#add3848dcec1b22547ab57fddbfdaec1d">replace</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">string</a>, int start_position, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; replacement, <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> match_options)</td></tr>
<tr class="separator:add3848dcec1b22547ab57fddbfdaec1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bccbbffa1c84249b35201ee6e6f39c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#a4bccbbffa1c84249b35201ee6e6f39c9">replace_literal</a> (const gchar*<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">string</a>, gssize string_len, int start_position, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; replacement, <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> match_options=static_cast&lt; <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> &gt;(0))</td></tr>
<tr class="memdesc:a4bccbbffa1c84249b35201ee6e6f39c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all occurrences of the pattern in <em>regex</em> with the replacement text.  <a href="#a4bccbbffa1c84249b35201ee6e6f39c9">More...</a><br /></td></tr>
<tr class="separator:a4bccbbffa1c84249b35201ee6e6f39c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6660f8fcf2ec8a6e90a7ecc85ced0e2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#a6660f8fcf2ec8a6e90a7ecc85ced0e2a">replace_literal</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">string</a>, int start_position, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; replacement, <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> match_options)</td></tr>
<tr class="separator:a6660f8fcf2ec8a6e90a7ecc85ced0e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a2cf889ebf233c5d467b3816c8d533"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#ac5a2cf889ebf233c5d467b3816c8d533">replace_eval</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">string</a>, gssize string_len, int start_position, <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> match_options, GRegexEvalCallback eval, gpointer user_data)</td></tr>
<tr class="memdesc:ac5a2cf889ebf233c5d467b3816c8d533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces occurrences of the pattern in regex with the output of <em>eval</em> for that occurrence.  <a href="#ac5a2cf889ebf233c5d467b3816c8d533">More...</a><br /></td></tr>
<tr class="separator:ac5a2cf889ebf233c5d467b3816c8d533"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a09d723a3b495453399d9f685b528727a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGlib_1_1Regex.html">Glib::Regex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#a09d723a3b495453399d9f685b528727a">create</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; pattern, <a class="el" href="group__glibmmEnums.html#gaaaedee3e1374af9f1d66ccd34252a68d">RegexCompileFlags</a> compile_options=static_cast&lt; <a class="el" href="group__glibmmEnums.html#gaaaedee3e1374af9f1d66ccd34252a68d">RegexCompileFlags</a> &gt;(0), <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> match_options=static_cast&lt; <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> &gt;(0))</td></tr>
<tr class="separator:a09d723a3b495453399d9f685b528727a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc2c9b4f7d042a125d0d65fb16b71ff1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#abc2c9b4f7d042a125d0d65fb16b71ff1">escape_string</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">string</a>)</td></tr>
<tr class="separator:abc2c9b4f7d042a125d0d65fb16b71ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74905e31f14819b84c9e9cb53c79ca6c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#a74905e31f14819b84c9e9cb53c79ca6c">match_simple</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; pattern, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">string</a>, <a class="el" href="group__glibmmEnums.html#gaaaedee3e1374af9f1d66ccd34252a68d">RegexCompileFlags</a> compile_options=static_cast&lt; <a class="el" href="group__glibmmEnums.html#gaaaedee3e1374af9f1d66ccd34252a68d">RegexCompileFlags</a> &gt;(0), <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> match_options=static_cast&lt; <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> &gt;(0))</td></tr>
<tr class="memdesc:a74905e31f14819b84c9e9cb53c79ca6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scans for a match in <em>string</em> for <em>pattern</em>.  <a href="#a74905e31f14819b84c9e9cb53c79ca6c">More...</a><br /></td></tr>
<tr class="separator:a74905e31f14819b84c9e9cb53c79ca6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0911a410fa5295667d54e900cce7f10"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__ContHandles.html#ga66b4a4b57f64be3fdc1972d8bf93723a">Glib::StringArrayHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#aa0911a410fa5295667d54e900cce7f10">split_simple</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; pattern, const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">string</a>, <a class="el" href="group__glibmmEnums.html#gaaaedee3e1374af9f1d66ccd34252a68d">RegexCompileFlags</a> compile_options=static_cast&lt; <a class="el" href="group__glibmmEnums.html#gaaaedee3e1374af9f1d66ccd34252a68d">RegexCompileFlags</a> &gt;(0), <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> match_options=static_cast&lt; <a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> &gt;(0))</td></tr>
<tr class="memdesc:aa0911a410fa5295667d54e900cce7f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Breaks the string on the pattern, and returns an array of the tokens.  <a href="#aa0911a410fa5295667d54e900cce7f10">More...</a><br /></td></tr>
<tr class="separator:aa0911a410fa5295667d54e900cce7f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54071d7bdd63db75099445fe0c84580c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#a54071d7bdd63db75099445fe0c84580c">check_replacement</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; replacement, gboolean* has_references)</td></tr>
<tr class="memdesc:a54071d7bdd63db75099445fe0c84580c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <em>replacement</em> is a valid replacement string (see g_regex_replace()), i.e. that all escape sequences in it are valid.  <a href="#a54071d7bdd63db75099445fe0c84580c">More...</a><br /></td></tr>
<tr class="separator:a54071d7bdd63db75099445fe0c84580c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a88fe75f456608b165b2a9e15bc31dc75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#a88fe75f456608b165b2a9e15bc31dc75">operator delete</a> (void*, std::size_t)</td></tr>
<tr class="separator:a88fe75f456608b165b2a9e15bc31dc75"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:aa502a39684fb9d59dc689da8bb9d9da8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGlib_1_1Regex.html">Glib::Regex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1Regex.html#aa502a39684fb9d59dc689da8bb9d9da8">wrap</a> (GRegex* object, bool take_copy=false)</td></tr>
<tr class="memdesc:aa502a39684fb9d59dc689da8bb9d9da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="namespaceGlib.html#a671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object.  <a href="#aa502a39684fb9d59dc689da8bb9d9da8">More...</a><br /></td></tr>
<tr class="separator:aa502a39684fb9d59dc689da8bb9d9da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Perl-compatible regular expressions - matches strings against regular expressions. </p>
<p>The <a class="el" href="classGlib_1_1Regex.html" title="Perl-compatible regular expressions - matches strings against regular expressions. ">Glib::Regex</a> functions implement regular expression pattern matching using syntax and semantics similar to Perl regular expression.</p>
<p>Some functions accept a start_position argument, setting it differs from just passing over a shortened string and setting REGEX_MATCH_NOTBOL in the case of a pattern that begins with any kind of lookbehind assertion. For example, consider the pattern "\Biss\B" which finds occurrences of "iss" in the middle of words. ("\B" matches only if the current position in the subject is not a word boundary.) When applied to the string "Mississipi" from the fourth byte, namely "issipi", it does not match, because "\B" is always false at the start of the subject, which is deemed to be a word boundary. However, if the entire string is passed , but with start_position set to 4, it finds the second occurrence of "iss" because it is able to look behind the starting point to discover that it is preceded by a letter.</p>
<p>Note that, unless you set the REGEX_RAW flag, all the strings passed to these functions must be encoded in UTF-8. The lengths and the positions inside the strings are in bytes and not in characters, so, for instance, "\xc3\xa0" (i.e. "à") is two bytes long but it is treated as a single character. If you set REGEX_RAW the strings can be non-valid UTF-8 strings and a byte is treated as a character, so "\xc3\xa0" is two bytes and two characters long.</p>
<p>When matching a pattern, "\n" matches only against a "\n" character in the string, and "\r" matches only a "\r" character. To match any newline sequence use "\R". This particular group matches either the two-character sequence CR + LF ("\r\n"), or one of the single characters LF (linefeed, U+000A, "\n"), VT (vertical tab, U+000B, "\v"), FF (formfeed, U+000C, "\f"), CR (carriage return, U+000D, "\r"), NEL (next line, U+0085), LS (line separator, U+2028), or PS (paragraph separator, U+2029).</p>
<p>The behaviour of the dot, circumflex, and dollar metacharacters are affected by newline characters, the default is to recognize any newline character (the same characters recognized by "\R"). This can be changed with REGEX_NEWLINE_CR, REGEX_NEWLINE_LF and REGEX_NEWLINE_CRLF compile options, and with REGEX_MATCH_NEWLINE_ANY, REGEX_MATCH_NEWLINE_CR, REGEX_MATCH_NEWLINE_LF and REGEX_MATCH_NEWLINE_CRLF match options. These settings are also relevant when compiling a pattern if REGEX_EXTENDED is set, and an unescaped "#" outside a character class is encountered. This indicates a comment that lasts until after the next newline.</p>
<p>Creating and manipulating the same <a class="el" href="classGlib_1_1Regex.html" title="Perl-compatible regular expressions - matches strings against regular expressions. ">Glib::Regex</a> class from different threads is not a problem as <a class="el" href="classGlib_1_1Regex.html" title="Perl-compatible regular expressions - matches strings against regular expressions. ">Glib::Regex</a> does not modify its internal state between creation and destruction, on the other hand <a class="el" href="classGlib_1_1MatchInfo.html" title="MatchInfo - MatchInfo is used to retrieve information about the regular expression match which create...">Glib::MatchInfo</a> is not threadsafe.</p>
<p>The regular expressions low level functionalities are obtained through the excellent PCRE library written by Philip Hazel.</p>
<dl class="since_2_14"><dt><b><a class="el" href="since_2_14.html#_since_2_14000016">Since glibmm 2.14:</a></b></dt><dd></dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aaae302567d5aa9648f216b349be26375"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Glib::Regex::Regex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acb85b2ec990227be37232a50e3e135d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Glib::Regex::Regex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1Regex.html">Regex</a>&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a54071d7bdd63db75099445fe0c84580c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Glib::Regex::check_replacement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gboolean *&#160;</td>
          <td class="paramname"><em>has_references</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether <em>replacement</em> is a valid replacement string (see g_regex_replace()), i.e. that all escape sequences in it are valid. </p>
<p>If <em>has_references</em> is not <code>nullptr</code> then <em>replacement</em> is checked for pattern references. For instance, replacement text 'foo\n' does not contain references and may be evaluated without information about actual match, but '\0\1' (whole match followed by first subpattern) requires valid <a class="el" href="classGlib_1_1MatchInfo.html" title="MatchInfo - MatchInfo is used to retrieve information about the regular expression match which create...">MatchInfo</a> object.</p>
<dl class="since_2_14"><dt><b><a class="el" href="since_2_14.html#_since_2_14000033">Since glibmm 2.14:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">replacement</td><td>The replacement string. </td></tr>
    <tr><td class="paramname">has_references</td><td>Location to store information about references in <em>replacement</em> or <code>nullptr</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether <em>replacement</em> is a valid replacement string. </dd></dl>

</div>
</div>
<a class="anchor" id="a09d723a3b495453399d9f685b528727a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGlib_1_1Regex.html">Glib::Regex</a>&gt; Glib::Regex::create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#gaaaedee3e1374af9f1d66ccd34252a68d">RegexCompileFlags</a>&#160;</td>
          <td class="paramname"><em>compile_options</em> = <code>static_cast&lt;&#160;<a class="el" href="group__glibmmEnums.html#gaaaedee3e1374af9f1d66ccd34252a68d">RegexCompileFlags</a>&#160;&gt;(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;</td>
          <td class="paramname"><em>match_options</em> = <code>static_cast&lt;&#160;<a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;&gt;(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abc2c9b4f7d042a125d0d65fb16b71ff1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a> Glib::Regex::escape_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a891b0f5b73a2beb390330778a0114c94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Glib::Regex::get_capture_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of capturing subpatterns in the pattern. </p>
<dl class="since_2_14"><dt><b><a class="el" href="since_2_14.html#_since_2_14000020">Since glibmm 2.14:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of capturing subpatterns. </dd></dl>

</div>
</div>
<a class="anchor" id="ac785eb93ccc7e89901467763e1592ed0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__glibmmEnums.html#gaaaedee3e1374af9f1d66ccd34252a68d">RegexCompileFlags</a> Glib::Regex::get_compile_flags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the compile options that <em>regex</em> was created with. </p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000050">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Flags from RegexCompileFlags. </dd></dl>

</div>
</div>
<a class="anchor" id="acaef8a96694c134997528e20af58f672"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::Regex::get_has_cr_or_lf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the pattern contains explicit CR or LF references. </p>
<dl class="since_2_34"><dt><b><a class="el" href="since_2_34.html#_since_2_34000027">Since glibmm 2.34:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the pattern contains explicit CR or LF references. </dd></dl>

</div>
</div>
<a class="anchor" id="a81f29d12b42f6315195a329805869594"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a> Glib::Regex::get_match_flags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the match options that <em>regex</em> was created with. </p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000051">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Flags from RegexMatchFlags. </dd></dl>

</div>
</div>
<a class="anchor" id="ac7123b6f880561ff94134c808a254387"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Glib::Regex::get_max_backref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of the highest back reference in the pattern, or 0 if the pattern does not contain back references. </p>
<dl class="since_2_14"><dt><b><a class="el" href="since_2_14.html#_since_2_14000019">Since glibmm 2.14:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of the highest back reference. </dd></dl>

</div>
</div>
<a class="anchor" id="a7e9f0256d613e009055fc5ab4a77b074"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Glib::Regex::get_max_lookbehind </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of characters in the longest lookbehind assertion in the pattern. </p>
<p>This information is useful when doing multi-segment matching using the partial matching facilities.</p>
<dl class="since_2_38"><dt><b><a class="el" href="since_2_38.html#_since_2_38000001">Since glibmm 2.38:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters in the longest lookbehind assertion. </dd></dl>

</div>
</div>
<a class="anchor" id="a802f0517b6bb5d72e55bc1dcaa8174a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a> Glib::Regex::get_pattern </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the pattern string associated with <em>regex</em>, i.e. a copy of the string passed to g_regex_new(). </p>
<dl class="since_2_14"><dt><b><a class="el" href="since_2_14.html#_since_2_14000018">Since glibmm 2.14:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The pattern of <em>regex</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a033e3e0480fc5904d307f06a35e3240b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Glib::Regex::get_string_number </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the number of the subexpression named <em>name</em>. </p>
<dl class="since_2_14"><dt><b><a class="el" href="since_2_14.html#_since_2_14000021">Since glibmm 2.14:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the subexpression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of the subexpression or -1 if <em>name</em> does not exists. </dd></dl>

</div>
</div>
<a class="anchor" id="a640d1c5b6bc6ff05461dbf11b97e4477"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GRegex* Glib::Regex::gobj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides access to the underlying C instance. </p>

</div>
</div>
<a class="anchor" id="ae5c9e3ee8fd94e728128ff8eacb138c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const GRegex* Glib::Regex::gobj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides access to the underlying C instance. </p>

</div>
</div>
<a class="anchor" id="a6766b1090ea2e97757a5585aca14f926"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GRegex* Glib::Regex::gobj_copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs. </p>

</div>
</div>
<a class="anchor" id="a52a55ce94fcdf6b24cc8d6cc2ba77ebf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::Regex::match </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGlib_1_1MatchInfo.html">Glib::MatchInfo</a>&amp;&#160;</td>
          <td class="paramname"><em>match_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;</td>
          <td class="paramname"><em>match_options</em> = <code>static_cast&lt;&#160;<a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;&gt;(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scans for a match in string for the pattern in <em>regex</em>. </p>
<p>The <em>match_options</em> are combined with the match options specified when the <em>regex</em> structure was created, letting you have more flexibility in reusing <a class="el" href="classGlib_1_1Regex.html" title="Perl-compatible regular expressions - matches strings against regular expressions. ">Regex</a> structures.</p>
<p>A <a class="el" href="classGlib_1_1MatchInfo.html" title="MatchInfo - MatchInfo is used to retrieve information about the regular expression match which create...">MatchInfo</a> structure, used to get information on the match, is stored in <em>match_info</em> if not <code>nullptr</code>. Note that if <em>match_info</em> is not <code>nullptr</code> then it is created even if the function returns <code>false</code>, i.e. you must free it regardless if regular expression actually matched.</p>
<p>To retrieve all the non-overlapping matches of the pattern in string you can use g_match_info_next().</p>
<p>[C example ellipted]</p>
<p><em>string</em> is not copied and is used in <a class="el" href="classGlib_1_1MatchInfo.html" title="MatchInfo - MatchInfo is used to retrieve information about the regular expression match which create...">MatchInfo</a> internally. If you use any <a class="el" href="classGlib_1_1MatchInfo.html" title="MatchInfo - MatchInfo is used to retrieve information about the regular expression match which create...">MatchInfo</a> method (except g_match_info_free()) after freeing or modifying <em>string</em> then the behaviour is undefined.</p>
<dl class="since_2_14"><dt><b><a class="el" href="since_2_14.html#_since_2_14000023">Since glibmm 2.14:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>The string to scan for matches. </td></tr>
    <tr><td class="paramname">match_options</td><td>Match options. </td></tr>
    <tr><td class="paramname">match_info</td><td>Pointer to location where to store the <a class="el" href="classGlib_1_1MatchInfo.html" title="MatchInfo - MatchInfo is used to retrieve information about the regular expression match which create...">MatchInfo</a>, or <code>nullptr</code> if you do not need it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> is the string matched, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ad19516ab8cbcad727a159160a50bf26e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::Regex::match </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;</td>
          <td class="paramname"><em>match_options</em> = <code>static_cast&lt;&#160;<a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;&gt;(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classGlib_1_1Regex.html#a52a55ce94fcdf6b24cc8d6cc2ba77ebf" title="Scans for a match in string for the pattern in regex. ">match()</a> method not requiring a <a class="el" href="classGlib_1_1MatchInfo.html" title="MatchInfo - MatchInfo is used to retrieve information about the regular expression match which create...">Glib::MatchInfo</a>. </p>

</div>
</div>
<a class="anchor" id="a0db06bc90254899673d1899a01f16652"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::Regex::match </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGlib_1_1MatchInfo.html">Glib::MatchInfo</a>&amp;&#160;</td>
          <td class="paramname"><em>match_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;</td>
          <td class="paramname"><em>match_options</em> = <code>static_cast&lt;&#160;<a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;&gt;(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classGlib_1_1Regex.html#a52a55ce94fcdf6b24cc8d6cc2ba77ebf" title="Scans for a match in string for the pattern in regex. ">match()</a> method with a start position and a <a class="el" href="classGlib_1_1MatchInfo.html" title="MatchInfo - MatchInfo is used to retrieve information about the regular expression match which create...">Glib::MatchInfo</a>. </p>

</div>
</div>
<a class="anchor" id="a723e145e1ed53d0c8c272386ec1bfbf6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::Regex::match </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gssize&#160;</td>
          <td class="paramname"><em>string_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGlib_1_1MatchInfo.html">Glib::MatchInfo</a>&amp;&#160;</td>
          <td class="paramname"><em>match_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;</td>
          <td class="paramname"><em>match_options</em> = <code>static_cast&lt;&#160;<a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;&gt;(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scans for a match in string for the pattern in <em>regex</em>. </p>
<p>The <em>match_options</em> are combined with the match options specified when the <em>regex</em> structure was created, letting you have more flexibility in reusing <a class="el" href="classGlib_1_1Regex.html" title="Perl-compatible regular expressions - matches strings against regular expressions. ">Regex</a> structures.</p>
<p>Setting <em>start_position</em> differs from just passing over a shortened string and setting REGEX_MATCH_NOTBOL in the case of a pattern that begins with any kind of lookbehind assertion, such as "\\b".</p>
<p>A <a class="el" href="classGlib_1_1MatchInfo.html" title="MatchInfo - MatchInfo is used to retrieve information about the regular expression match which create...">MatchInfo</a> structure, used to get information on the match, is stored in <em>match_info</em> if not <code>nullptr</code>. Note that if <em>match_info</em> is not <code>nullptr</code> then it is created even if the function returns <code>false</code>, i.e. you must free it regardless if regular expression actually matched.</p>
<p><em>string</em> is not copied and is used in <a class="el" href="classGlib_1_1MatchInfo.html" title="MatchInfo - MatchInfo is used to retrieve information about the regular expression match which create...">MatchInfo</a> internally. If you use any <a class="el" href="classGlib_1_1MatchInfo.html" title="MatchInfo - MatchInfo is used to retrieve information about the regular expression match which create...">MatchInfo</a> method (except g_match_info_free()) after freeing or modifying <em>string</em> then the behaviour is undefined.</p>
<p>To retrieve all the non-overlapping matches of the pattern in string you can use g_match_info_next().</p>
<p>[C example ellipted]</p>
<dl class="since_2_14"><dt><b><a class="el" href="since_2_14.html#_since_2_14000024">Since glibmm 2.14:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>The string to scan for matches. </td></tr>
    <tr><td class="paramname">string_len</td><td>The length of <em>string</em>, or -1 if <em>string</em> is nul-terminated. </td></tr>
    <tr><td class="paramname">start_position</td><td>Starting index of the string to match, in bytes. </td></tr>
    <tr><td class="paramname">match_options</td><td>Match options. </td></tr>
    <tr><td class="paramname">match_info</td><td>Pointer to location where to store the <a class="el" href="classGlib_1_1MatchInfo.html" title="MatchInfo - MatchInfo is used to retrieve information about the regular expression match which create...">MatchInfo</a>, or <code>nullptr</code> if you do not need it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> is the string matched, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="acbbd6f902b679b6b34554099a2ef67ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::Regex::match </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;</td>
          <td class="paramname"><em>match_options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classGlib_1_1Regex.html#a52a55ce94fcdf6b24cc8d6cc2ba77ebf" title="Scans for a match in string for the pattern in regex. ">match()</a> method with a start position not requiring a <a class="el" href="classGlib_1_1MatchInfo.html" title="MatchInfo - MatchInfo is used to retrieve information about the regular expression match which create...">Glib::MatchInfo</a>. </p>

</div>
</div>
<a class="anchor" id="a6e0224ad096ba88c94e6e648a619f163"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::Regex::match </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gssize&#160;</td>
          <td class="paramname"><em>string_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;</td>
          <td class="paramname"><em>match_options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classGlib_1_1Regex.html#a52a55ce94fcdf6b24cc8d6cc2ba77ebf" title="Scans for a match in string for the pattern in regex. ">match()</a> method with a string length and start position not requiring a <a class="el" href="classGlib_1_1MatchInfo.html" title="MatchInfo - MatchInfo is used to retrieve information about the regular expression match which create...">Glib::MatchInfo</a>. </p>

</div>
</div>
<a class="anchor" id="ac5d1e01c383fbf2d8646d3deaf50148f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::Regex::match_all </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGlib_1_1MatchInfo.html">Glib::MatchInfo</a>&amp;&#160;</td>
          <td class="paramname"><em>match_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;</td>
          <td class="paramname"><em>match_options</em> = <code>static_cast&lt;&#160;<a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;&gt;(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Using the standard algorithm for regular expression matching only the longest match in the string is retrieved. </p>
<p>This function uses a different algorithm so it can retrieve all the possible matches. For more documentation see g_regex_match_all_full().</p>
<p>A <a class="el" href="classGlib_1_1MatchInfo.html" title="MatchInfo - MatchInfo is used to retrieve information about the regular expression match which create...">MatchInfo</a> structure, used to get information on the match, is stored in <em>match_info</em> if not <code>nullptr</code>. Note that if <em>match_info</em> is not <code>nullptr</code> then it is created even if the function returns <code>false</code>, i.e. you must free it regardless if regular expression actually matched.</p>
<p><em>string</em> is not copied and is used in <a class="el" href="classGlib_1_1MatchInfo.html" title="MatchInfo - MatchInfo is used to retrieve information about the regular expression match which create...">MatchInfo</a> internally. If you use any <a class="el" href="classGlib_1_1MatchInfo.html" title="MatchInfo - MatchInfo is used to retrieve information about the regular expression match which create...">MatchInfo</a> method (except g_match_info_free()) after freeing or modifying <em>string</em> then the behaviour is undefined.</p>
<dl class="since_2_14"><dt><b><a class="el" href="since_2_14.html#_since_2_14000025">Since glibmm 2.14:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>The string to scan for matches. </td></tr>
    <tr><td class="paramname">match_options</td><td>Match options. </td></tr>
    <tr><td class="paramname">match_info</td><td>Pointer to location where to store the <a class="el" href="classGlib_1_1MatchInfo.html" title="MatchInfo - MatchInfo is used to retrieve information about the regular expression match which create...">MatchInfo</a>, or <code>nullptr</code> if you do not need it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> is the string matched, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a8e2a2daa7f18c41ca37080cdd4842fae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::Regex::match_all </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;</td>
          <td class="paramname"><em>match_options</em> = <code>static_cast&lt;&#160;<a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;&gt;(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classGlib_1_1Regex.html#ac5d1e01c383fbf2d8646d3deaf50148f" title="Using the standard algorithm for regular expression matching only the longest match in the string is ...">match_all()</a> method not requiring a <a class="el" href="classGlib_1_1MatchInfo.html" title="MatchInfo - MatchInfo is used to retrieve information about the regular expression match which create...">Glib::MatchInfo</a>. </p>

</div>
</div>
<a class="anchor" id="aa28e51fff3244cb499d89ef0919d8ec3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::Regex::match_all </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGlib_1_1MatchInfo.html">Glib::MatchInfo</a>&amp;&#160;</td>
          <td class="paramname"><em>match_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;</td>
          <td class="paramname"><em>match_options</em> = <code>static_cast&lt;&#160;<a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;&gt;(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classGlib_1_1Regex.html#ac5d1e01c383fbf2d8646d3deaf50148f" title="Using the standard algorithm for regular expression matching only the longest match in the string is ...">match_all()</a> method with a start positon and a <a class="el" href="classGlib_1_1MatchInfo.html" title="MatchInfo - MatchInfo is used to retrieve information about the regular expression match which create...">Glib::MatchInfo</a>. </p>

</div>
</div>
<a class="anchor" id="a3bd99c4fe2a912d0e6dd56ddaf16f9e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::Regex::match_all </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gssize&#160;</td>
          <td class="paramname"><em>string_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGlib_1_1MatchInfo.html">Glib::MatchInfo</a>&amp;&#160;</td>
          <td class="paramname"><em>match_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;</td>
          <td class="paramname"><em>match_options</em> = <code>static_cast&lt;&#160;<a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;&gt;(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Using the standard algorithm for regular expression matching only the longest match in the string is retrieved, it is not possible to obtain all the available matches. </p>
<p>For instance matching "&lt;a&gt; &lt;b&gt; &lt;c&gt;" against the pattern "&lt;.*&gt;" you get "&lt;a&gt; &lt;b&gt; &lt;c&gt;".</p>
<p>This function uses a different algorithm (called DFA, i.e. deterministic finite automaton), so it can retrieve all the possible matches, all starting at the same point in the string. For instance matching "&lt;a&gt; &lt;b&gt; &lt;c&gt;" against the pattern "&lt;.*&gt;;" you would obtain three matches: "&lt;a&gt; &lt;b&gt; &lt;c&gt;", "&lt;a&gt; &lt;b&gt;" and "&lt;a&gt;".</p>
<p>The number of matched strings is retrieved using g_match_info_get_match_count(). To obtain the matched strings and their position you can use, respectively, g_match_info_fetch() and g_match_info_fetch_pos(). Note that the strings are returned in reverse order of length; that is, the longest matching string is given first.</p>
<p>Note that the DFA algorithm is slower than the standard one and it is not able to capture substrings, so backreferences do not work.</p>
<p>Setting <em>start_position</em> differs from just passing over a shortened string and setting REGEX_MATCH_NOTBOL in the case of a pattern that begins with any kind of lookbehind assertion, such as "\\b".</p>
<p>A <a class="el" href="classGlib_1_1MatchInfo.html" title="MatchInfo - MatchInfo is used to retrieve information about the regular expression match which create...">MatchInfo</a> structure, used to get information on the match, is stored in <em>match_info</em> if not <code>nullptr</code>. Note that if <em>match_info</em> is not <code>nullptr</code> then it is created even if the function returns <code>false</code>, i.e. you must free it regardless if regular expression actually matched.</p>
<p><em>string</em> is not copied and is used in <a class="el" href="classGlib_1_1MatchInfo.html" title="MatchInfo - MatchInfo is used to retrieve information about the regular expression match which create...">MatchInfo</a> internally. If you use any <a class="el" href="classGlib_1_1MatchInfo.html" title="MatchInfo - MatchInfo is used to retrieve information about the regular expression match which create...">MatchInfo</a> method (except g_match_info_free()) after freeing or modifying <em>string</em> then the behaviour is undefined.</p>
<dl class="since_2_14"><dt><b><a class="el" href="since_2_14.html#_since_2_14000026">Since glibmm 2.14:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>The string to scan for matches. </td></tr>
    <tr><td class="paramname">string_len</td><td>The length of <em>string</em>, or -1 if <em>string</em> is nul-terminated. </td></tr>
    <tr><td class="paramname">start_position</td><td>Starting index of the string to match, in bytes. </td></tr>
    <tr><td class="paramname">match_options</td><td>Match options. </td></tr>
    <tr><td class="paramname">match_info</td><td>Pointer to location where to store the <a class="el" href="classGlib_1_1MatchInfo.html" title="MatchInfo - MatchInfo is used to retrieve information about the regular expression match which create...">MatchInfo</a>, or <code>nullptr</code> if you do not need it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> is the string matched, <code>false</code> otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Glib::Error.</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adf0dc5f15631c6a090c5724bfa71f4bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::Regex::match_all </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;</td>
          <td class="paramname"><em>match_options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classGlib_1_1Regex.html#ac5d1e01c383fbf2d8646d3deaf50148f" title="Using the standard algorithm for regular expression matching only the longest match in the string is ...">match_all()</a> method with a start position not requiring a <a class="el" href="classGlib_1_1MatchInfo.html" title="MatchInfo - MatchInfo is used to retrieve information about the regular expression match which create...">Glib::MatchInfo</a>. </p>

</div>
</div>
<a class="anchor" id="a2e393570c407f42cbf4e223fab19f499"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::Regex::match_all </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gssize&#160;</td>
          <td class="paramname"><em>string_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;</td>
          <td class="paramname"><em>match_options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classGlib_1_1Regex.html#ac5d1e01c383fbf2d8646d3deaf50148f" title="Using the standard algorithm for regular expression matching only the longest match in the string is ...">match_all()</a> method with a start position and a string length not requiring a <a class="el" href="classGlib_1_1MatchInfo.html" title="MatchInfo - MatchInfo is used to retrieve information about the regular expression match which create...">Glib::MatchInfo</a>. </p>

</div>
</div>
<a class="anchor" id="a74905e31f14819b84c9e9cb53c79ca6c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool Glib::Regex::match_simple </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#gaaaedee3e1374af9f1d66ccd34252a68d">RegexCompileFlags</a>&#160;</td>
          <td class="paramname"><em>compile_options</em> = <code>static_cast&lt;&#160;<a class="el" href="group__glibmmEnums.html#gaaaedee3e1374af9f1d66ccd34252a68d">RegexCompileFlags</a>&#160;&gt;(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;</td>
          <td class="paramname"><em>match_options</em> = <code>static_cast&lt;&#160;<a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;&gt;(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scans for a match in <em>string</em> for <em>pattern</em>. </p>
<p>This function is equivalent to g_regex_match() but it does not require to compile the pattern with g_regex_new(), avoiding some lines of code when you need just to do a match without extracting substrings, capture counts, and so on.</p>
<p>If this function is to be called on the same <em>pattern</em> more than once, it's more efficient to compile the pattern once with g_regex_new() and then use g_regex_match().</p>
<dl class="since_2_14"><dt><b><a class="el" href="since_2_14.html#_since_2_14000022">Since glibmm 2.14:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>The regular expression. </td></tr>
    <tr><td class="paramname">string</td><td>The string to scan for matches. </td></tr>
    <tr><td class="paramname">compile_options</td><td>Compile options for the regular expression, or 0. </td></tr>
    <tr><td class="paramname">match_options</td><td>Match options, or 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the string matched, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a88fe75f456608b165b2a9e15bc31dc75"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Glib::Regex::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a47a67fd6307c5e635d87c19d1c56b122"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1Regex.html">Regex</a>&amp; Glib::Regex::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1Regex.html">Regex</a>&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6099ec7a4be34e4fec017a9d18eeb7f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Glib::Regex::reference </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increment the reference count for this object. </p>
<p>You should never need to do this manually - use the object via a <a class="el" href="classGlib_1_1RefPtr.html" title="RefPtr<> is a reference-counting shared smartpointer. ">RefPtr</a> instead. </p>

</div>
</div>
<a class="anchor" id="ae9f40c233d33361814252f8bfb00a716"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a> Glib::Regex::replace </td>
          <td>(</td>
          <td class="paramtype">const gchar *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gssize&#160;</td>
          <td class="paramname"><em>string_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;</td>
          <td class="paramname"><em>match_options</em> = <code>static_cast&lt;&#160;<a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;&gt;(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces all occurrences of the pattern in <em>regex</em> with the replacement text. </p>
<p>Backreferences of the form '\number' or '\g&lt;number&gt;' in the replacement text are interpolated by the number-th captured subexpression of the match, '\g&lt;name&gt;' refers to the captured subexpression with the given name. '\0' refers to the complete match, but '\0' followed by a number is the octal representation of a character. To include a literal '\' in the replacement, write '\\'.</p>
<p>There are also escapes that changes the case of the following text:</p>
<ul>
<li>\l: Convert to lower case the next character</li>
<li>\u: Convert to upper case the next character</li>
<li>\L: Convert to lower case till \E</li>
<li>\U: Convert to upper case till \E</li>
<li>\E: End case modification</li>
</ul>
<p>If you do not need to use backreferences use g_regex_replace_literal().</p>
<p>The <em>replacement</em> string must be UTF-8 encoded even if REGEX_RAW was passed to g_regex_new(). If you want to use not UTF-8 encoded stings you can use g_regex_replace_literal().</p>
<p>Setting <em>start_position</em> differs from just passing over a shortened string and setting REGEX_MATCH_NOTBOL in the case of a pattern that begins with any kind of lookbehind assertion, such as "\\b".</p>
<dl class="since_2_14"><dt><b><a class="el" href="since_2_14.html#_since_2_14000030">Since glibmm 2.14:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>The string to perform matches against. </td></tr>
    <tr><td class="paramname">string_len</td><td>The length of <em>string</em>, or -1 if <em>string</em> is nul-terminated. </td></tr>
    <tr><td class="paramname">start_position</td><td>Starting index of the string to match, in bytes. </td></tr>
    <tr><td class="paramname">replacement</td><td>Text to replace each match with. </td></tr>
    <tr><td class="paramname">match_options</td><td>Options for the match. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly allocated string containing the replacements. </dd></dl>

</div>
</div>
<a class="anchor" id="add3848dcec1b22547ab57fddbfdaec1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a> Glib::Regex::replace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;</td>
          <td class="paramname"><em>match_options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac5a2cf889ebf233c5d467b3816c8d533"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a> Glib::Regex::replace_eval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gssize&#160;</td>
          <td class="paramname"><em>string_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;</td>
          <td class="paramname"><em>match_options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GRegexEvalCallback&#160;</td>
          <td class="paramname"><em>eval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gpointer&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces occurrences of the pattern in regex with the output of <em>eval</em> for that occurrence. </p>
<p>Setting <em>start_position</em> differs from just passing over a shortened string and setting REGEX_MATCH_NOTBOL in the case of a pattern that begins with any kind of lookbehind assertion, such as "\\b".</p>
<p>The following example uses g_regex_replace_eval() to replace multiple strings at once:</p>
<p>[C example ellipted]</p>
<dl class="since_2_14"><dt><b><a class="el" href="since_2_14.html#_since_2_14000032">Since glibmm 2.14:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>String to perform matches against. </td></tr>
    <tr><td class="paramname">string_len</td><td>The length of <em>string</em>, or -1 if <em>string</em> is nul-terminated. </td></tr>
    <tr><td class="paramname">start_position</td><td>Starting index of the string to match, in bytes. </td></tr>
    <tr><td class="paramname">match_options</td><td>Options for the match. </td></tr>
    <tr><td class="paramname">eval</td><td>A function to call for each match. </td></tr>
    <tr><td class="paramname">user_data</td><td>User data to pass to the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly allocated string containing the replacements. </dd></dl>

</div>
</div>
<a class="anchor" id="a4bccbbffa1c84249b35201ee6e6f39c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a> Glib::Regex::replace_literal </td>
          <td>(</td>
          <td class="paramtype">const gchar *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gssize&#160;</td>
          <td class="paramname"><em>string_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;</td>
          <td class="paramname"><em>match_options</em> = <code>static_cast&lt;&#160;<a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;&gt;(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces all occurrences of the pattern in <em>regex</em> with the replacement text. </p>
<p><em>replacement</em> is replaced literally, to include backreferences use g_regex_replace().</p>
<p>Setting <em>start_position</em> differs from just passing over a shortened string and setting REGEX_MATCH_NOTBOL in the case of a pattern that begins with any kind of lookbehind assertion, such as "\\b".</p>
<dl class="since_2_14"><dt><b><a class="el" href="since_2_14.html#_since_2_14000031">Since glibmm 2.14:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>The string to perform matches against. </td></tr>
    <tr><td class="paramname">string_len</td><td>The length of <em>string</em>, or -1 if <em>string</em> is nul-terminated. </td></tr>
    <tr><td class="paramname">start_position</td><td>Starting index of the string to match, in bytes. </td></tr>
    <tr><td class="paramname">replacement</td><td>Text to replace each match with. </td></tr>
    <tr><td class="paramname">match_options</td><td>Options for the match. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly allocated string containing the replacements. </dd></dl>

</div>
</div>
<a class="anchor" id="a6660f8fcf2ec8a6e90a7ecc85ced0e2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a> Glib::Regex::replace_literal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;</td>
          <td class="paramname"><em>match_options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a447bbb8dc8ca457d1c1a4ab0740ced7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ContHandles.html#ga66b4a4b57f64be3fdc1972d8bf93723a">Glib::StringArrayHandle</a> Glib::Regex::split </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;</td>
          <td class="paramname"><em>match_options</em> = <code>static_cast&lt;&#160;<a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;&gt;(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Breaks the string on the pattern, and returns an array of the tokens. </p>
<p>If the pattern contains capturing parentheses, then the text for each of the substrings will also be returned. If the pattern does not match anywhere in the string, then the whole string is returned as the first token.</p>
<p>As a special case, the result of splitting the empty string "" is an empty vector, not a vector containing a single string. The reason for this special case is that being able to represent a empty vector is typically more useful than consistent handling of empty elements. If you do need to represent empty elements, you'll need to check for the empty string before calling this function.</p>
<p>A pattern that can match empty strings splits <em>string</em> into separate characters wherever it matches the empty string between characters. For example splitting "ab c" using as a separator "\\s*", you will get "a", "b" and "c".</p>
<dl class="since_2_14"><dt><b><a class="el" href="since_2_14.html#_since_2_14000028">Since glibmm 2.14:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>The string to split with the pattern. </td></tr>
    <tr><td class="paramname">match_options</td><td>Match time option flags. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>nullptr</code>-terminated gchar ** array. Free it using g_strfreev(). </dd></dl>

</div>
</div>
<a class="anchor" id="ace0220e0ed2d7bd7771030e360e5141f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ContHandles.html#ga66b4a4b57f64be3fdc1972d8bf93723a">Glib::StringArrayHandle</a> Glib::Regex::split </td>
          <td>(</td>
          <td class="paramtype">const gchar *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gssize&#160;</td>
          <td class="paramname"><em>string_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;</td>
          <td class="paramname"><em>match_options</em> = <code>static_cast&lt;&#160;<a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;&gt;(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_tokens</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Breaks the string on the pattern, and returns an array of the tokens. </p>
<p>If the pattern contains capturing parentheses, then the text for each of the substrings will also be returned. If the pattern does not match anywhere in the string, then the whole string is returned as the first token.</p>
<p>As a special case, the result of splitting the empty string "" is an empty vector, not a vector containing a single string. The reason for this special case is that being able to represent a empty vector is typically more useful than consistent handling of empty elements. If you do need to represent empty elements, you'll need to check for the empty string before calling this function.</p>
<p>A pattern that can match empty strings splits <em>string</em> into separate characters wherever it matches the empty string between characters. For example splitting "ab c" using as a separator "\\s*", you will get "a", "b" and "c".</p>
<p>Setting <em>start_position</em> differs from just passing over a shortened string and setting REGEX_MATCH_NOTBOL in the case of a pattern that begins with any kind of lookbehind assertion, such as "\\b".</p>
<dl class="since_2_14"><dt><b><a class="el" href="since_2_14.html#_since_2_14000029">Since glibmm 2.14:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">string</td><td>The string to split with the pattern. </td></tr>
    <tr><td class="paramname">string_len</td><td>The length of <em>string</em>, or -1 if <em>string</em> is nul-terminated. </td></tr>
    <tr><td class="paramname">start_position</td><td>Starting index of the string to match, in bytes. </td></tr>
    <tr><td class="paramname">match_options</td><td>Match time option flags. </td></tr>
    <tr><td class="paramname">max_tokens</td><td>The maximum number of tokens to split <em>string</em> into. If this is less than 1, the string is split completely. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>nullptr</code>-terminated gchar ** array. Free it using g_strfreev(). </dd></dl>

</div>
</div>
<a class="anchor" id="a3f2f68542607519a358dd0ada1b5e3d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ContHandles.html#ga66b4a4b57f64be3fdc1972d8bf93723a">Glib::StringArrayHandle</a> Glib::Regex::split </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;</td>
          <td class="paramname"><em>match_options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_tokens</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa0911a410fa5295667d54e900cce7f10"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__ContHandles.html#ga66b4a4b57f64be3fdc1972d8bf93723a">Glib::StringArrayHandle</a> Glib::Regex::split_simple </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#gaaaedee3e1374af9f1d66ccd34252a68d">RegexCompileFlags</a>&#160;</td>
          <td class="paramname"><em>compile_options</em> = <code>static_cast&lt;&#160;<a class="el" href="group__glibmmEnums.html#gaaaedee3e1374af9f1d66ccd34252a68d">RegexCompileFlags</a>&#160;&gt;(0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;</td>
          <td class="paramname"><em>match_options</em> = <code>static_cast&lt;&#160;<a class="el" href="group__glibmmEnums.html#ga8375c7f6797efc96929e8be89435c746">RegexMatchFlags</a>&#160;&gt;(0)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Breaks the string on the pattern, and returns an array of the tokens. </p>
<p>If the pattern contains capturing parentheses, then the text for each of the substrings will also be returned. If the pattern does not match anywhere in the string, then the whole string is returned as the first token.</p>
<p>This function is equivalent to g_regex_split() but it does not require to compile the pattern with g_regex_new(), avoiding some lines of code when you need just to do a split without extracting substrings, capture counts, and so on.</p>
<p>If this function is to be called on the same <em>pattern</em> more than once, it's more efficient to compile the pattern once with g_regex_new() and then use g_regex_split().</p>
<p>As a special case, the result of splitting the empty string "" is an empty vector, not a vector containing a single string. The reason for this special case is that being able to represent a empty vector is typically more useful than consistent handling of empty elements. If you do need to represent empty elements, you'll need to check for the empty string before calling this function.</p>
<p>A pattern that can match empty strings splits <em>string</em> into separate characters wherever it matches the empty string between characters. For example splitting "ab c" using as a separator "\\s*", you will get "a", "b" and "c".</p>
<dl class="since_2_14"><dt><b><a class="el" href="since_2_14.html#_since_2_14000027">Since glibmm 2.14:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pattern</td><td>The regular expression. </td></tr>
    <tr><td class="paramname">string</td><td>The string to scan for matches. </td></tr>
    <tr><td class="paramname">compile_options</td><td>Compile options for the regular expression, or 0. </td></tr>
    <tr><td class="paramname">match_options</td><td>Match options, or 0. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>nullptr</code>-terminated array of strings. Free it using g_strfreev(). </dd></dl>

</div>
</div>
<a class="anchor" id="a661a9b85f52dbaaa68a6495ace7df50a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Glib::Regex::unreference </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrement the reference count for this object. </p>
<p>You should never need to do this manually - use the object via a <a class="el" href="classGlib_1_1RefPtr.html" title="RefPtr<> is a reference-counting shared smartpointer. ">RefPtr</a> instead. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="aa502a39684fb9d59dc689da8bb9d9da8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGlib_1_1Regex.html">Glib::Regex</a> &gt; wrap </td>
          <td>(</td>
          <td class="paramtype">GRegex *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>take_copy</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A <a class="el" href="namespaceGlib.html#a671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>The C instance. </td></tr>
    <tr><td class="paramname">take_copy</td><td>False if the result should take ownership of the C instance. True if it should take a new copy or ref. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A C++ instance that wraps this C instance. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Mar 31 2016 11:46:41 for glibmm by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
