<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>glibmm: Glib::VariantBase Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">glibmm
   &#160;<span id="projectnumber">2.48.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceGlib.html">Glib</a></li><li class="navelem"><a class="el" href="classGlib_1_1VariantBase.html">VariantBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classGlib_1_1VariantBase-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Glib::VariantBase Class Reference<div class="ingroups"><a class="el" href="group__Variant.html">Variant Data Types</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>This is the base class for all <a class="el" href="classGlib_1_1Variant.html" title="Template class used for the specialization of the Variant<> classes. ">Variant</a> types.  
 <a href="classGlib_1_1VariantBase.html#details">More...</a></p>

<p><code>#include &lt;glibmm/variant.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Glib::VariantBase:</div>
<div class="dyncontent">
<div class="center"><img src="classGlib_1_1VariantBase__inherit__graph.png" border="0" usemap="#Glib_1_1VariantBase_inherit__map" alt="Inheritance graph"/></div>
<map name="Glib_1_1VariantBase_inherit__map" id="Glib_1_1VariantBase_inherit__map">
<area shape="rect" id="node2" href="classGlib_1_1Variant.html" title="Template class used for the specialization of the Variant&lt;&gt; classes. " alt="" coords="213,5,349,32"/><area shape="rect" id="node3" href="classGlib_1_1Variant_3_01bool_01_4.html" title="Specialization of Glib::Variant containing a bool type. " alt="" coords="203,56,359,83"/><area shape="rect" id="node4" href="classGlib_1_1Variant_3_01double_01_4.html" title="Specialization of Glib::Variant containing a double type. " alt="" coords="195,107,367,133"/><area shape="rect" id="node5" href="classGlib_1_1Variant_3_01gint16_01_4.html" title="Specialization of Glib::Variant containing a gint16 type. " alt="" coords="196,157,365,184"/><area shape="rect" id="node6" href="classGlib_1_1Variant_3_01gint32_01_4.html" title="Specialization of Glib::Variant containing a gint32 type. " alt="" coords="196,208,365,235"/><area shape="rect" id="node7" href="classGlib_1_1Variant_3_01gint64_01_4.html" title="Specialization of Glib::Variant containing a gint64 type. " alt="" coords="196,259,365,285"/><area shape="rect" id="node8" href="classGlib_1_1Variant_3_01guint16_01_4.html" title="Specialization of Glib::Variant containing a guint16 type. " alt="" coords="192,309,369,336"/><area shape="rect" id="node9" href="classGlib_1_1Variant_3_01guint32_01_4.html" title="Specialization of Glib::Variant containing a guint32 type. " alt="" coords="192,360,369,387"/><area shape="rect" id="node10" href="classGlib_1_1Variant_3_01guint64_01_4.html" title="Specialization of Glib::Variant containing a guint64 type. " alt="" coords="192,411,369,437"/><area shape="rect" id="node11" href="classGlib_1_1Variant_3_01unsigned_01char_01_4.html" title="Specialization of Glib::Variant containing a unsigned char type. " alt="" coords="195,462,367,503"/><area shape="rect" id="node12" href="classGlib_1_1VariantContainerBase.html" title="The base class from which multiple&#45;item Variants derive, such as Variants containing tuples or arrays..." alt="" coords="184,528,377,555"/><area shape="rect" id="node19" href="classGlib_1_1VariantStringBase.html" title="Base class from which string variant classes derive. " alt="" coords="196,711,365,737"/><area shape="rect" id="node13" href="classGlib_1_1Variant_3_01std_1_1map_3_01K_00_01V_01_4_01_4.html" title="Specialization of Variant containing a dictionary (a map of (key, value) elements). " alt="" coords="461,325,596,366"/><area shape="rect" id="node14" href="classGlib_1_1Variant_3_01std_1_1vector_3_01Glib_1_1ustring_01_4_01_4.html" title="Specialization of Variant containing an array of UTF&#45;8 capable strings. " alt="" coords="433,390,624,431"/><area shape="rect" id="node15" href="classGlib_1_1Variant_3_01std_1_1vector_3_01std_1_1string_01_4_01_4.html" title="Specialization of Variant containing an array of non&#45;UTF&#45;8 strings (byte string arrays). " alt="" coords="439,455,618,497"/><area shape="rect" id="node16" href="classGlib_1_1Variant_3_01std_1_1vector_3_01T_01_4_01_4.html" title="Specialization of Variant containing an array of items. " alt="" coords="461,521,596,562"/><area shape="rect" id="node17" href="classGlib_1_1Variant_3_01Variant_3_01T_01_4_01_4.html" title="Specialization of Variant containing a Variant&lt;T&gt;. " alt="" coords="449,586,608,627"/><area shape="rect" id="node18" href="classGlib_1_1Variant_3_01VariantBase_01_4.html" title="Specialization of Variant containing a VariantBase. " alt="" coords="425,652,632,679"/><area shape="rect" id="node20" href="classGlib_1_1Variant_3_01Glib_1_1ustring_01_4.html" title="Specialization of Variant containing a Glib::ustring, for variants of type string, object path, or signature. " alt="" coords="459,703,598,745"/><area shape="rect" id="node21" href="classGlib_1_1Variant_3_01std_1_1string_01_4.html" title="Specialization of Variant containing a std::string, for variants of type bytestring, string, object path, or signature. " alt="" coords="461,769,596,810"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae46eeafcd6f827fabb1a61e53a0d401b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantBase.html#ae46eeafcd6f827fabb1a61e53a0d401b">BoolExpr</a> = const void*</td></tr>
<tr class="memdesc:ae46eeafcd6f827fabb1a61e53a0d401b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This typedef is just to make it more obvious that our operator const void* should be used like operator bool().  <a href="#ae46eeafcd6f827fabb1a61e53a0d401b">More...</a><br /></td></tr>
<tr class="separator:ae46eeafcd6f827fabb1a61e53a0d401b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a74bb8db40a8cd10d2fed3d02c4cb413e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantBase.html#a74bb8db40a8cd10d2fed3d02c4cb413e">VariantBase</a> ()</td></tr>
<tr class="memdesc:a74bb8db40a8cd10d2fed3d02c4cb413e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an invalid object.  <a href="#a74bb8db40a8cd10d2fed3d02c4cb413e">More...</a><br /></td></tr>
<tr class="separator:a74bb8db40a8cd10d2fed3d02c4cb413e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afac0ab2bacb3ff7c1b8eea15ac75df9c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantBase.html#afac0ab2bacb3ff7c1b8eea15ac75df9c">VariantBase</a> (GVariant* castitem, bool make_a_copy=false)</td></tr>
<tr class="separator:afac0ab2bacb3ff7c1b8eea15ac75df9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb13ac35e3de8d16a866aa8822aea25"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantBase.html#a6eb13ac35e3de8d16a866aa8822aea25">VariantBase</a> (const <a class="el" href="classGlib_1_1VariantBase.html">VariantBase</a>&amp; src)</td></tr>
<tr class="separator:a6eb13ac35e3de8d16a866aa8822aea25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f30d304c0343fa3e86d1f9df2726d7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1VariantBase.html">VariantBase</a>&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantBase.html#a2f30d304c0343fa3e86d1f9df2726d7c">operator=</a> (const <a class="el" href="classGlib_1_1VariantBase.html">VariantBase</a>&amp; src)</td></tr>
<tr class="separator:a2f30d304c0343fa3e86d1f9df2726d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd23a76dad128ee5e8c290a8a250ca4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantBase.html#afdd23a76dad128ee5e8c290a8a250ca4">VariantBase</a> (<a class="el" href="classGlib_1_1VariantBase.html">VariantBase</a>&amp;&amp; other) noexcept</td></tr>
<tr class="separator:afdd23a76dad128ee5e8c290a8a250ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0325c35f55ea53e64146ad20661f6d8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1VariantBase.html">VariantBase</a>&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantBase.html#a0325c35f55ea53e64146ad20661f6d8d">operator=</a> (<a class="el" href="classGlib_1_1VariantBase.html">VariantBase</a>&amp;&amp; other) noexcept</td></tr>
<tr class="separator:a0325c35f55ea53e64146ad20661f6d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1853f1bd452866789479f9d5d48cadd9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantBase.html#a1853f1bd452866789479f9d5d48cadd9">~VariantBase</a> () noexcept</td></tr>
<tr class="separator:a1853f1bd452866789479f9d5d48cadd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a336846c1fd9175e222e58d74aa5c9156"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantBase.html#a336846c1fd9175e222e58d74aa5c9156">swap</a> (<a class="el" href="classGlib_1_1VariantBase.html">VariantBase</a>&amp; other) noexcept</td></tr>
<tr class="separator:a336846c1fd9175e222e58d74aa5c9156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b980321e6b0d16401343129dfc439e8"><td class="memItemLeft" align="right" valign="top">GVariant*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantBase.html#a3b980321e6b0d16401343129dfc439e8">gobj</a> ()</td></tr>
<tr class="separator:a3b980321e6b0d16401343129dfc439e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f0a920cd09d1b01a09888a38ef962d"><td class="memItemLeft" align="right" valign="top">const GVariant*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantBase.html#a45f0a920cd09d1b01a09888a38ef962d">gobj</a> () const </td></tr>
<tr class="separator:a45f0a920cd09d1b01a09888a38ef962d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08796c6b0ca3eacfe2c1b9d4f6100c05"><td class="memItemLeft" align="right" valign="top">GVariant*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantBase.html#a08796c6b0ca3eacfe2c1b9d4f6100c05">gobj_copy</a> () const </td></tr>
<tr class="memdesc:a08796c6b0ca3eacfe2c1b9d4f6100c05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C instance. The caller is responsible for freeing it. Use when directly setting fields in structs.  <a href="#a08796c6b0ca3eacfe2c1b9d4f6100c05">More...</a><br /></td></tr>
<tr class="separator:a08796c6b0ca3eacfe2c1b9d4f6100c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b02a861503f991df8af088aa63ee22b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantBase.html#a5b02a861503f991df8af088aa63ee22b">operator BoolExpr</a> () const </td></tr>
<tr class="memdesc:a5b02a861503f991df8af088aa63ee22b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether the <a class="el" href="classGlib_1_1Variant.html" title="Template class used for the specialization of the Variant<> classes. ">Variant</a> has an underlying instance.  <a href="#a5b02a861503f991df8af088aa63ee22b">More...</a><br /></td></tr>
<tr class="separator:a5b02a861503f991df8af088aa63ee22b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a980a39e735ac4e68dfc37fe004161018"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantBase.html#a980a39e735ac4e68dfc37fe004161018">init</a> (const GVariant* cobject, bool take_a_reference=false)</td></tr>
<tr class="memdesc:a980a39e735ac4e68dfc37fe004161018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the underlying GVariant.  <a href="#a980a39e735ac4e68dfc37fe004161018">More...</a><br /></td></tr>
<tr class="separator:a980a39e735ac4e68dfc37fe004161018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c80e6f06c6e521313becc282abc8c3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1VariantType.html">VariantType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantBase.html#a3c80e6f06c6e521313becc282abc8c3c">get_type</a> () const </td></tr>
<tr class="memdesc:a3c80e6f06c6e521313becc282abc8c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the type of <em>value</em>.  <a href="#a3c80e6f06c6e521313becc282abc8c3c">More...</a><br /></td></tr>
<tr class="separator:a3c80e6f06c6e521313becc282abc8c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af33ac1d71e48fdf3461b701b4d081d67"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantBase.html#af33ac1d71e48fdf3461b701b4d081d67">get_type_string</a> () const </td></tr>
<tr class="memdesc:af33ac1d71e48fdf3461b701b4d081d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type string of <em>value</em>.  <a href="#af33ac1d71e48fdf3461b701b4d081d67">More...</a><br /></td></tr>
<tr class="separator:af33ac1d71e48fdf3461b701b4d081d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf3b9e20b90e788017520aeeef6b572e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantBase.html#abf3b9e20b90e788017520aeeef6b572e">is_floating</a> () const </td></tr>
<tr class="memdesc:abf3b9e20b90e788017520aeeef6b572e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether <em>value</em> has a floating reference count.  <a href="#abf3b9e20b90e788017520aeeef6b572e">More...</a><br /></td></tr>
<tr class="separator:abf3b9e20b90e788017520aeeef6b572e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add8f349a4b28bcaa2f371ff0a1e2e156"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantBase.html#add8f349a4b28bcaa2f371ff0a1e2e156">is_of_type</a> (const <a class="el" href="classGlib_1_1VariantType.html">VariantType</a>&amp; type) const </td></tr>
<tr class="memdesc:add8f349a4b28bcaa2f371ff0a1e2e156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a value has a type matching the provided type.  <a href="#add8f349a4b28bcaa2f371ff0a1e2e156">More...</a><br /></td></tr>
<tr class="separator:add8f349a4b28bcaa2f371ff0a1e2e156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a820465e7ed6003933fcb2cc26ebb0b6a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantBase.html#a820465e7ed6003933fcb2cc26ebb0b6a">is_container</a> () const </td></tr>
<tr class="memdesc:a820465e7ed6003933fcb2cc26ebb0b6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <em>value</em> is a container.  <a href="#a820465e7ed6003933fcb2cc26ebb0b6a">More...</a><br /></td></tr>
<tr class="separator:a820465e7ed6003933fcb2cc26ebb0b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d83a47f0e2d3c42df0d8059c36528d"><td class="memItemLeft" align="right" valign="top">GVariantClass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantBase.html#a70d83a47f0e2d3c42df0d8059c36528d">classify</a> () const </td></tr>
<tr class="memdesc:a70d83a47f0e2d3c42df0d8059c36528d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Classifies <em>value</em> according to its top-level type.  <a href="#a70d83a47f0e2d3c42df0d8059c36528d">More...</a><br /></td></tr>
<tr class="separator:a70d83a47f0e2d3c42df0d8059c36528d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44e000834c16fae60ea26d95e5a4c58e"><td class="memItemLeft" align="right" valign="top">gsize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantBase.html#a44e000834c16fae60ea26d95e5a4c58e">get_size</a> () const </td></tr>
<tr class="memdesc:a44e000834c16fae60ea26d95e5a4c58e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the number of bytes that would be required to store <em>value</em> with g_variant_store().  <a href="#a44e000834c16fae60ea26d95e5a4c58e">More...</a><br /></td></tr>
<tr class="separator:a44e000834c16fae60ea26d95e5a4c58e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a687306a73541b9b5e11e91d6d8f97831"><td class="memItemLeft" align="right" valign="top">gconstpointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantBase.html#a687306a73541b9b5e11e91d6d8f97831">get_data</a> ()</td></tr>
<tr class="memdesc:a687306a73541b9b5e11e91d6d8f97831"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the serialised form of a <a class="el" href="classGlib_1_1Variant.html" title="Template class used for the specialization of the Variant<> classes. ">Variant</a> instance.  <a href="#a687306a73541b9b5e11e91d6d8f97831">More...</a><br /></td></tr>
<tr class="separator:a687306a73541b9b5e11e91d6d8f97831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c148a173e04f7b337194b033262e01c"><td class="memItemLeft" align="right" valign="top">gconstpointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantBase.html#a7c148a173e04f7b337194b033262e01c">get_data</a> () const </td></tr>
<tr class="memdesc:a7c148a173e04f7b337194b033262e01c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the serialised form of a <a class="el" href="classGlib_1_1Variant.html" title="Template class used for the specialization of the Variant<> classes. ">Variant</a> instance.  <a href="#a7c148a173e04f7b337194b033262e01c">More...</a><br /></td></tr>
<tr class="separator:a7c148a173e04f7b337194b033262e01c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bbd1db41c752aa8c0c0bfe60a27a0b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; const <a class="el" href="classGlib_1_1Bytes.html">Glib::Bytes</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantBase.html#a2bbd1db41c752aa8c0c0bfe60a27a0b0">get_data_as_bytes</a> () const </td></tr>
<tr class="memdesc:a2bbd1db41c752aa8c0c0bfe60a27a0b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the serialised form of a <a class="el" href="classGlib_1_1Variant.html" title="Template class used for the specialization of the Variant<> classes. ">Variant</a> instance.  <a href="#a2bbd1db41c752aa8c0c0bfe60a27a0b0">More...</a><br /></td></tr>
<tr class="separator:a2bbd1db41c752aa8c0c0bfe60a27a0b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf846816697993b48edc7918524f8d59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantBase.html#acf846816697993b48edc7918524f8d59">store</a> (gpointer data) const </td></tr>
<tr class="memdesc:acf846816697993b48edc7918524f8d59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the serialised form of <em>value</em> at <em>data</em>.  <a href="#acf846816697993b48edc7918524f8d59">More...</a><br /></td></tr>
<tr class="separator:acf846816697993b48edc7918524f8d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7710b7b3452bd70c8e07679eba195fdc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantBase.html#a7710b7b3452bd70c8e07679eba195fdc">print</a> (bool type_annotate=false) const </td></tr>
<tr class="memdesc:a7710b7b3452bd70c8e07679eba195fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pretty-prints <em>value</em> in the format understood by g_variant_parse().  <a href="#a7710b7b3452bd70c8e07679eba195fdc">More...</a><br /></td></tr>
<tr class="separator:a7710b7b3452bd70c8e07679eba195fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3961de1c9f10ab5afc3ca47b953b806"><td class="memItemLeft" align="right" valign="top">guint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantBase.html#ac3961de1c9f10ab5afc3ca47b953b806">hash</a> () const </td></tr>
<tr class="memdesc:ac3961de1c9f10ab5afc3ca47b953b806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a hash value for a <a class="el" href="classGlib_1_1Variant.html" title="Template class used for the specialization of the Variant<> classes. ">Variant</a> instance.  <a href="#ac3961de1c9f10ab5afc3ca47b953b806">More...</a><br /></td></tr>
<tr class="separator:ac3961de1c9f10ab5afc3ca47b953b806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34a6a44b9002dcc43478a30207d2e6c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantBase.html#a34a6a44b9002dcc43478a30207d2e6c7">equal</a> (const <a class="el" href="classGlib_1_1VariantBase.html">VariantBase</a>&amp; other) const </td></tr>
<tr class="memdesc:a34a6a44b9002dcc43478a30207d2e6c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <em>*this</em> and <em>other</em> have the same type and value.  <a href="#a34a6a44b9002dcc43478a30207d2e6c7">More...</a><br /></td></tr>
<tr class="separator:a34a6a44b9002dcc43478a30207d2e6c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa132cf27e283a93954ed088444267d1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantBase.html#aa132cf27e283a93954ed088444267d1b">get_normal_form</a> (<a class="el" href="classGlib_1_1VariantBase.html">VariantBase</a>&amp; result) const </td></tr>
<tr class="memdesc:aa132cf27e283a93954ed088444267d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a <a class="el" href="classGlib_1_1VariantBase.html" title="This is the base class for all Variant types. ">VariantBase</a> instance that has the same value as this variant and is trusted to be in normal form.  <a href="#aa132cf27e283a93954ed088444267d1b">More...</a><br /></td></tr>
<tr class="separator:aa132cf27e283a93954ed088444267d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba3e2dafc50fe64df6408dcb44f5870"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantBase.html#aeba3e2dafc50fe64df6408dcb44f5870">is_normal_form</a> () const </td></tr>
<tr class="memdesc:aeba3e2dafc50fe64df6408dcb44f5870"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if <em>value</em> is in normal form.  <a href="#aeba3e2dafc50fe64df6408dcb44f5870">More...</a><br /></td></tr>
<tr class="separator:aeba3e2dafc50fe64df6408dcb44f5870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb202d5375b8f5e9ce7fc721aeff9c45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantBase.html#adb202d5375b8f5e9ce7fc721aeff9c45">byteswap</a> (<a class="el" href="classGlib_1_1VariantBase.html">VariantBase</a>&amp; result) const </td></tr>
<tr class="memdesc:adb202d5375b8f5e9ce7fc721aeff9c45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a byteswapping operation on the contents of this variant.  <a href="#adb202d5375b8f5e9ce7fc721aeff9c45">More...</a><br /></td></tr>
<tr class="separator:adb202d5375b8f5e9ce7fc721aeff9c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc2cb96b12e7a3ccf068e5d8d4605972"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantBase.html#adc2cb96b12e7a3ccf068e5d8d4605972">check_format_string</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; format_string, bool copy_only=false) const </td></tr>
<tr class="memdesc:adc2cb96b12e7a3ccf068e5d8d4605972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if calling g_variant_get() with <em>format_string</em> on <em>value</em> would be valid from a type-compatibility standpoint.  <a href="#adc2cb96b12e7a3ccf068e5d8d4605972">More...</a><br /></td></tr>
<tr class="separator:adc2cb96b12e7a3ccf068e5d8d4605972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9564ae1398eb9015369b3842d50b67e8"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a9564ae1398eb9015369b3842d50b67e8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1VariantContainerBase.html">VariantContainerBase</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantBase.html#a9564ae1398eb9015369b3842d50b67e8">cast_dynamic</a> (const <a class="el" href="classGlib_1_1VariantBase.html">VariantBase</a>&amp; v)  throw (std::bad_cast)</td></tr>
<tr class="separator:a9564ae1398eb9015369b3842d50b67e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a1f65fc45c20886cd9a5351ed5fa81463"><td class="memTemplParams" colspan="2">template&lt;class V_CastTo &gt; </td></tr>
<tr class="memitem:a1f65fc45c20886cd9a5351ed5fa81463"><td class="memTemplItemLeft" align="right" valign="top">static V_CastTo&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantBase.html#a1f65fc45c20886cd9a5351ed5fa81463">cast_dynamic</a> (const <a class="el" href="classGlib_1_1VariantBase.html">VariantBase</a>&amp; v)  throw (std::bad_cast)</td></tr>
<tr class="memdesc:a1f65fc45c20886cd9a5351ed5fa81463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast to a specific variant type.  <a href="#a1f65fc45c20886cd9a5351ed5fa81463">More...</a><br /></td></tr>
<tr class="separator:a1f65fc45c20886cd9a5351ed5fa81463"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:afb327758aeb118b06e9c9e6b0a796892"><td class="memItemLeft" align="right" valign="top">GVariant*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantBase.html#afb327758aeb118b06e9c9e6b0a796892">gobject_</a></td></tr>
<tr class="separator:afb327758aeb118b06e9c9e6b0a796892"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:ad70df57e9ee2e532a0c836923e7d0b2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantBase.html#ad70df57e9ee2e532a0c836923e7d0b2a">swap</a> (<a class="el" href="classGlib_1_1VariantBase.html">VariantBase</a>&amp; lhs, <a class="el" href="classGlib_1_1VariantBase.html">VariantBase</a>&amp; rhs) noexcept</td></tr>
<tr class="separator:ad70df57e9ee2e532a0c836923e7d0b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea2fee9e9505dfd38d7f086a335655b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1VariantBase.html">Glib::VariantBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1VariantBase.html#aea2fee9e9505dfd38d7f086a335655b0">wrap</a> (GVariant* object, bool take_copy=false)</td></tr>
<tr class="memdesc:aea2fee9e9505dfd38d7f086a335655b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="namespaceGlib.html#a671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object.  <a href="#aea2fee9e9505dfd38d7f086a335655b0">More...</a><br /></td></tr>
<tr class="separator:aea2fee9e9505dfd38d7f086a335655b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is the base class for all <a class="el" href="classGlib_1_1Variant.html" title="Template class used for the specialization of the Variant<> classes. ">Variant</a> types. </p>
<p>If the actual type is known at compile-time then you should use a specific Variant&lt;&gt;, such as Variant&lt;int&gt;. Otherwise, you may use <a class="el" href="classGlib_1_1VariantBase.html#a3c80e6f06c6e521313becc282abc8c3c" title="Determines the type of value. ">get_type()</a>, <a class="el" href="classGlib_1_1VariantBase.html#add8f349a4b28bcaa2f371ff0a1e2e156" title="Checks if a value has a type matching the provided type. ">is_of_type()</a>, or <a class="el" href="classGlib_1_1VariantBase.html#a1f65fc45c20886cd9a5351ed5fa81463" title="Cast to a specific variant type. ">cast_dynamic()</a>.</p>
<dl class="since_2_28"><dt><b><a class="el" href="since_2_28.html#_since_2_28000012">Since glibmm 2.28:</a></b></dt><dd></dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="ae46eeafcd6f827fabb1a61e53a0d401b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classGlib_1_1VariantBase.html#ae46eeafcd6f827fabb1a61e53a0d401b">Glib::VariantBase::BoolExpr</a> =  const void*</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This typedef is just to make it more obvious that our operator const void* should be used like operator bool(). </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a74bb8db40a8cd10d2fed3d02c4cb413e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::VariantBase::VariantBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an invalid object. </p>
<p>E.g. for output arguments to methods. There is not much you can do with the object before it has been assigned a valid value. </p>

</div>
</div>
<a class="anchor" id="afac0ab2bacb3ff7c1b8eea15ac75df9c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Glib::VariantBase::VariantBase </td>
          <td>(</td>
          <td class="paramtype">GVariant *&#160;</td>
          <td class="paramname"><em>castitem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>make_a_copy</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6eb13ac35e3de8d16a866aa8822aea25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::VariantBase::VariantBase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1VariantBase.html">VariantBase</a>&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afdd23a76dad128ee5e8c290a8a250ca4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Glib::VariantBase::VariantBase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGlib_1_1VariantBase.html">VariantBase</a>&amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1853f1bd452866789479f9d5d48cadd9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Glib::VariantBase::~VariantBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="adb202d5375b8f5e9ce7fc721aeff9c45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Glib::VariantBase::byteswap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGlib_1_1VariantBase.html">VariantBase</a>&amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a byteswapping operation on the contents of this variant. </p>
<p>The result is that all multi-byte numeric data contained in the variant is byteswapped. That includes 16, 32, and 64bit signed and unsigned integers as well as file handles and double precision floating point values.</p>
<p>This function is an identity mapping on any value that does not contain multi-byte numeric data. That include strings, booleans, bytes and containers containing only these things (recursively).</p>
<p>The returned value is always in normal form and is marked as trusted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>A location in which to store the byteswapped form of this variant. </td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000015">Since glibmm 2.24:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a1f65fc45c20886cd9a5351ed5fa81463"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;class V_CastTo &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">V_CastTo Glib::VariantBase::cast_dynamic </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1VariantBase.html">VariantBase</a>&amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00619.html">std::bad_cast</a></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast to a specific variant type. </p>
<p>For instance: </p><div class="fragment"><div class="line">Variant&lt;std::string&gt; derived = VariantBase::cast_dynamic&lt; Variant&lt;std::string&gt; &gt;(base);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The variant to cast to a specific type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The variant as a specific type. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00619.html">std::bad_cast</a></td><td>if the <a class="el" href="classGlib_1_1Variant.html" title="Template class used for the specialization of the Variant<> classes. ">Variant</a> was not of the expected type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9564ae1398eb9015369b3842d50b67e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template &lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1VariantContainerBase.html">VariantContainerBase</a> Glib::VariantBase::cast_dynamic </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1VariantBase.html">VariantBase</a>&amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a00619.html">std::bad_cast</a></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="adc2cb96b12e7a3ccf068e5d8d4605972"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::VariantBase::check_format_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>format_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if calling g_variant_get() with <em>format_string</em> on <em>value</em> would be valid from a type-compatibility standpoint. </p>
<p><em>format_string</em> is assumed to be a valid format string (from a syntactic standpoint).</p>
<p>If <em>copy_only</em> is <code>true</code> then this function additionally checks that it would be safe to call g_variant_unref() on <em>value</em> immediately after the call to g_variant_get() without invalidating the result. This is only possible if deep copies are made (ie: there are no pointers to the data inside of the soon-to-be-freed <a class="el" href="classGlib_1_1Variant.html" title="Template class used for the specialization of the Variant<> classes. ">Variant</a> instance). If this check fails then a g_critical() is printed and <code>false</code> is returned.</p>
<p>This function is meant to be used by functions that wish to provide varargs accessors to <a class="el" href="classGlib_1_1Variant.html" title="Template class used for the specialization of the Variant<> classes. ">Variant</a> values of uncertain values (eg: g_variant_lookup() or Glib::menu_model_get_item_attribute()).</p>
<dl class="since_2_34"><dt><b><a class="el" href="since_2_34.html#_since_2_34000029">Since glibmm 2.34:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">format_string</td><td>A valid <a class="el" href="classGlib_1_1Variant.html" title="Template class used for the specialization of the Variant<> classes. ">Variant</a> format string. </td></tr>
    <tr><td class="paramname">copy_only</td><td><code>true</code> to ensure the format string makes deep copies. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>format_string</em> is safe to use. </dd></dl>

</div>
</div>
<a class="anchor" id="a70d83a47f0e2d3c42df0d8059c36528d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GVariantClass Glib::VariantBase::classify </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Classifies <em>value</em> according to its top-level type. </p>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000006">Since glibmm 2.24:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The VariantClass of <em>value</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a34a6a44b9002dcc43478a30207d2e6c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::VariantBase::equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1VariantBase.html">VariantBase</a>&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <em>*this</em> and <em>other</em> have the same type and value. </p>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000012">Since glibmm 2.24:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The <a class="el" href="classGlib_1_1Variant.html" title="Template class used for the specialization of the Variant<> classes. ">Variant</a> to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>*this</em> and <em>other</em> are equal. </dd></dl>

</div>
</div>
<a class="anchor" id="a687306a73541b9b5e11e91d6d8f97831"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gconstpointer Glib::VariantBase::get_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the serialised form of a <a class="el" href="classGlib_1_1Variant.html" title="Template class used for the specialization of the Variant<> classes. ">Variant</a> instance. </p>
<p>The returned data may not be in fully-normalised form if read from an untrusted source. The returned data must not be freed; it remains valid for as long as <em>value</em> exists.</p>
<p>If <em>value</em> is a fixed-sized value that was deserialised from a corrupted serialised container then <code>nullptr</code> may be returned. In this case, the proper thing to do is typically to use the appropriate number of nul bytes in place of <em>value</em>. If <em>value</em> is not fixed-sized then <code>nullptr</code> is never returned.</p>
<p>In the case that <em>value</em> is already in serialised form, this function is O(1). If the value is not already in serialised form, serialisation occurs implicitly and is approximately O(n) in the size of the result.</p>
<p>To deserialise the data returned by this function, in addition to the serialised data, you must know the type of the <a class="el" href="classGlib_1_1Variant.html" title="Template class used for the specialization of the Variant<> classes. ">Variant</a>, and (if the machine might be different) the endianness of the machine that stored it. As a result, file formats or network messages that incorporate serialised Variants must include this information either implicitly (for instance "the file always contains a
VARIANT_TYPE_VARIANT and it is always in little-endian order") or explicitly (by storing the type and/or endianness in addition to the serialised data).</p>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000008">Since glibmm 2.24:</a></b></dt><dd></dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000059">Deprecated:</a></b></dt><dd>Use the const version instead.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The serialised form of <em>value</em>, or <code>nullptr</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a7c148a173e04f7b337194b033262e01c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gconstpointer Glib::VariantBase::get_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the serialised form of a <a class="el" href="classGlib_1_1Variant.html" title="Template class used for the specialization of the Variant<> classes. ">Variant</a> instance. </p>
<p>The returned data may not be in fully-normalised form if read from an untrusted source. The returned data must not be freed; it remains valid for as long as <em>value</em> exists.</p>
<p>If <em>value</em> is a fixed-sized value that was deserialised from a corrupted serialised container then <code>nullptr</code> may be returned. In this case, the proper thing to do is typically to use the appropriate number of nul bytes in place of <em>value</em>. If <em>value</em> is not fixed-sized then <code>nullptr</code> is never returned.</p>
<p>In the case that <em>value</em> is already in serialised form, this function is O(1). If the value is not already in serialised form, serialisation occurs implicitly and is approximately O(n) in the size of the result.</p>
<p>To deserialise the data returned by this function, in addition to the serialised data, you must know the type of the <a class="el" href="classGlib_1_1Variant.html" title="Template class used for the specialization of the Variant<> classes. ">Variant</a>, and (if the machine might be different) the endianness of the machine that stored it. As a result, file formats or network messages that incorporate serialised Variants must include this information either implicitly (for instance "the file always contains a
VARIANT_TYPE_VARIANT and it is always in little-endian order") or explicitly (by storing the type and/or endianness in addition to the serialised data).</p>
<dl class="since_2_46"><dt><b><a class="el" href="since_2_46.html#_since_2_46000003">Since glibmm 2.46:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The serialised form of <em>value</em>, or <code>nullptr</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a2bbd1db41c752aa8c0c0bfe60a27a0b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;const <a class="el" href="classGlib_1_1Bytes.html">Glib::Bytes</a>&gt; Glib::VariantBase::get_data_as_bytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the serialised form of a <a class="el" href="classGlib_1_1Variant.html" title="Template class used for the specialization of the Variant<> classes. ">Variant</a> instance. </p>
<p>The semantics of this function are exactly the same as g_variant_get_data(), except that the returned <a class="el" href="classGlib_1_1Bytes.html" title="A simple refcounted data type representing an immutable byte sequence from an unspecified origin...">Bytes</a> holds a reference to the variant data.</p>
<dl class="since_2_46"><dt><b><a class="el" href="since_2_46.html#_since_2_46000004">Since glibmm 2.46:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classGlib_1_1Bytes.html" title="A simple refcounted data type representing an immutable byte sequence from an unspecified origin...">Bytes</a> representing the variant data. </dd></dl>

</div>
</div>
<a class="anchor" id="aa132cf27e283a93954ed088444267d1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Glib::VariantBase::get_normal_form </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGlib_1_1VariantBase.html">VariantBase</a>&amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a <a class="el" href="classGlib_1_1VariantBase.html" title="This is the base class for all Variant types. ">VariantBase</a> instance that has the same value as this variant and is trusted to be in normal form. </p>
<p>If this variant is already trusted to be in normal form then a new reference to the variant is returned.</p>
<p>If this variant is not already trusted, then it is scanned to check if it is in normal form. If it is found to be in normal form then it is marked as trusted and a new reference to it is returned.</p>
<p>If this variant is found not to be in normal form then a new trusted <a class="el" href="classGlib_1_1VariantBase.html" title="This is the base class for all Variant types. ">VariantBase</a> is created with the same value as this variant.</p>
<p>It makes sense to call this function if you've received variant data from untrusted sources and you want to ensure your serialised output is definitely in normal form.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>A location in which to store the trusted <a class="el" href="classGlib_1_1VariantBase.html" title="This is the base class for all Variant types. ">VariantBase</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000013">Since glibmm 2.24:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a44e000834c16fae60ea26d95e5a4c58e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsize Glib::VariantBase::get_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the number of bytes that would be required to store <em>value</em> with g_variant_store(). </p>
<p>If <em>value</em> has a fixed-sized type then this function always returned that fixed size.</p>
<p>In the case that <em>value</em> is already in serialised form or the size has already been calculated (ie: this function has been called before) then this function is O(1). Otherwise, the size is calculated, an operation which is approximately O(n) in the number of values involved.</p>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000007">Since glibmm 2.24:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The serialised size of <em>value</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a3c80e6f06c6e521313becc282abc8c3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1VariantType.html">VariantType</a> Glib::VariantBase::get_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines the type of <em>value</em>. </p>
<p>The return value is valid for the lifetime of <em>value</em> and must not be freed.</p>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000002">Since glibmm 2.24:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classGlib_1_1VariantType.html" title="VariantType - The VariantBase type system. ">VariantType</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="af33ac1d71e48fdf3461b701b4d081d67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> Glib::VariantBase::get_type_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the type string of <em>value</em>. </p>
<p>Unlike the result of calling g_variant_type_peek_string(), this string is nul-terminated. This string belongs to <a class="el" href="classGlib_1_1Variant.html" title="Template class used for the specialization of the Variant<> classes. ">Variant</a> and must not be freed.</p>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000003">Since glibmm 2.24:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The type string for the type of <em>value</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b980321e6b0d16401343129dfc439e8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GVariant* Glib::VariantBase::gobj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a45f0a920cd09d1b01a09888a38ef962d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const GVariant* Glib::VariantBase::gobj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a08796c6b0ca3eacfe2c1b9d4f6100c05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GVariant* Glib::VariantBase::gobj_copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides access to the underlying C instance. The caller is responsible for freeing it. Use when directly setting fields in structs. </p>

</div>
</div>
<a class="anchor" id="ac3961de1c9f10ab5afc3ca47b953b806"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">guint Glib::VariantBase::hash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a hash value for a <a class="el" href="classGlib_1_1Variant.html" title="Template class used for the specialization of the Variant<> classes. ">Variant</a> instance. </p>
<p>The output of this function is guaranteed to be the same for a given value only per-process. It may change between different processor architectures or even different versions of GLib. Do not use this function as a basis for building protocols or file formats.</p>
<p>The type of <em>value</em> is #gconstpointer only to allow use of this function with HashTable. <em>value</em> must be a <a class="el" href="classGlib_1_1Variant.html" title="Template class used for the specialization of the Variant<> classes. ">Variant</a>.</p>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000011">Since glibmm 2.24:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A hash value corresponding to <em>value</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a980a39e735ac4e68dfc37fe004161018"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Glib::VariantBase::init </td>
          <td>(</td>
          <td class="paramtype">const GVariant *&#160;</td>
          <td class="paramname"><em>cobject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>take_a_reference</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace the underlying GVariant. </p>
<p>This is for use by methods that take a <a class="el" href="classGlib_1_1VariantBase.html" title="This is the base class for all Variant types. ">VariantBase</a>&amp; as an output parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cobject</td><td>The GVariant* obtained from a C function. </td></tr>
    <tr><td class="paramname">take_a_reference</td><td>Whether this method should take a reference, for instance if the C function has not given one. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a820465e7ed6003933fcb2cc26ebb0b6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::VariantBase::is_container </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <em>value</em> is a container. </p>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000005">Since glibmm 2.24:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>value</em> is a container. </dd></dl>

</div>
</div>
<a class="anchor" id="abf3b9e20b90e788017520aeeef6b572e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::VariantBase::is_floating </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether <em>value</em> has a floating reference count. </p>
<p>This function should only ever be used to assert that a given variant is or is not floating, or for debug purposes. To acquire a reference to a variant that might be floating, always use g_variant_ref_sink() or g_variant_take_ref().</p>
<p>See g_variant_ref_sink() for more information about floating reference counts.</p>
<dl class="since_2_26"><dt><b><a class="el" href="since_2_26.html#_since_2_26000060">Since glibmm 2.26:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Whether <em>value</em> is floating. </dd></dl>

</div>
</div>
<a class="anchor" id="aeba3e2dafc50fe64df6408dcb44f5870"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::VariantBase::is_normal_form </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if <em>value</em> is in normal form. </p>
<p>The main reason to do this is to detect if a given chunk of serialised data is in normal form: load the data into a <a class="el" href="classGlib_1_1Variant.html" title="Template class used for the specialization of the Variant<> classes. ">Variant</a> using g_variant_new_from_data() and then use this function to check.</p>
<p>If <em>value</em> is found to be in normal form then it will be marked as being trusted. If the value was already marked as being trusted then this function will immediately return <code>true</code>.</p>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000014">Since glibmm 2.24:</a></b></dt><dd></dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if <em>value</em> is in normal form. </dd></dl>

</div>
</div>
<a class="anchor" id="add8f349a4b28bcaa2f371ff0a1e2e156"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::VariantBase::is_of_type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1VariantType.html">VariantType</a>&amp;&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a value has a type matching the provided type. </p>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000004">Since glibmm 2.24:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>A <a class="el" href="classGlib_1_1VariantType.html" title="VariantType - The VariantBase type system. ">VariantType</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the type of <em>value</em> matches <em>type</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a5b02a861503f991df8af088aa63ee22b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Glib::VariantBase::operator <a class="el" href="classGlib_1_1VariantBase.html#ae46eeafcd6f827fabb1a61e53a0d401b">BoolExpr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether the <a class="el" href="classGlib_1_1Variant.html" title="Template class used for the specialization of the Variant<> classes. ">Variant</a> has an underlying instance. </p>
<p>Mimics usage of pointers: </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (variant)</div>
<div class="line">  do_something();</div>
</div><!-- fragment --><dl class="since_2_36"><dt><b><a class="el" href="since_2_36.html#_since_2_36000008">Since glibmm 2.36:</a></b></dt><dd></dd></dl>

</div>
</div>
<a class="anchor" id="a2f30d304c0343fa3e86d1f9df2726d7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1VariantBase.html">VariantBase</a>&amp; Glib::VariantBase::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1VariantBase.html">VariantBase</a>&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0325c35f55ea53e64146ad20661f6d8d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1VariantBase.html">VariantBase</a>&amp; Glib::VariantBase::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGlib_1_1VariantBase.html">VariantBase</a>&amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7710b7b3452bd70c8e07679eba195fdc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a> Glib::VariantBase::print </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>type_annotate</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pretty-prints <em>value</em> in the format understood by g_variant_parse(). </p>
<p>The format is described [here][gvariant-text].</p>
<p>If <em>type_annotate</em> is <code>true</code>, then type information is included in the output.</p>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000010">Since glibmm 2.24:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type_annotate</td><td><code>true</code> if type information should be included in the output. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A newly-allocated string holding the result. </dd></dl>

</div>
</div>
<a class="anchor" id="acf846816697993b48edc7918524f8d59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Glib::VariantBase::store </td>
          <td>(</td>
          <td class="paramtype">gpointer&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores the serialised form of <em>value</em> at <em>data</em>. </p>
<p><em>data</em> should be large enough. See g_variant_get_size().</p>
<p>The stored data is in machine native byte order but may not be in fully-normalised form if read from an untrusted source. See g_variant_get_normal_form() for a solution.</p>
<p>As with g_variant_get_data(), to be able to deserialise the serialised variant successfully, its type and (if the destination machine might be different) its endianness must also be available.</p>
<p>This function is approximately O(n) in the size of <em>data</em>.</p>
<dl class="since_2_24"><dt><b><a class="el" href="since_2_24.html#_since_2_24000009">Since glibmm 2.24:</a></b></dt><dd></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The location to store the serialised data at. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a336846c1fd9175e222e58d74aa5c9156"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Glib::VariantBase::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGlib_1_1VariantBase.html">VariantBase</a>&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="ad70df57e9ee2e532a0c836923e7d0b2a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGlib_1_1VariantBase.html">VariantBase</a>&amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGlib_1_1VariantBase.html">VariantBase</a>&amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The left-hand side </td></tr>
    <tr><td class="paramname">rhs</td><td>The right-hand side </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aea2fee9e9505dfd38d7f086a335655b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1VariantBase.html">Glib::VariantBase</a> wrap </td>
          <td>(</td>
          <td class="paramtype">GVariant *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>take_copy</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A <a class="el" href="namespaceGlib.html#a671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>The C instance. </td></tr>
    <tr><td class="paramname">take_copy</td><td>False if the result should take ownership of the C instance. True if it should take a new copy or ref. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A C++ instance that wraps this C instance. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="afb327758aeb118b06e9c9e6b0a796892"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GVariant* Glib::VariantBase::gobject_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Mar 31 2016 11:46:42 for glibmm by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
