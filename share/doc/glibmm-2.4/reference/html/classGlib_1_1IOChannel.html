<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>glibmm: Glib::IOChannel Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">glibmm
   &#160;<span id="projectnumber">2.48.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceGlib.html">Glib</a></li><li class="navelem"><a class="el" href="classGlib_1_1IOChannel.html">IOChannel</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classGlib_1_1IOChannel-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Glib::IOChannel Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and to integrate them wi...">IOChannel</a> aims to provide portable I/O support for files, pipes and sockets, and to integrate them with the GLib main event loop.  
 <a href="classGlib_1_1IOChannel.html#details">More...</a></p>

<p><code>#include &lt;glibmm/iochannel.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Glib::IOChannel:</div>
<div class="dyncontent">
<div class="center"><img src="classGlib_1_1IOChannel__inherit__graph.png" border="0" usemap="#Glib_1_1IOChannel_inherit__map" alt="Inheritance graph"/></div>
<map name="Glib_1_1IOChannel_inherit__map" id="Glib_1_1IOChannel_inherit__map">
<area shape="rect" id="node3" href="classGlib_1_1StreamIOChannel.html" title="Glib::StreamIOChannel" alt="" coords="5,155,172,181"/><area shape="rect" id="node2" href="file:///C:/msys/1.0/local/share/doc/libsigc++-2.0/reference/html/structsigc_1_1trackable.html" title="sigc::trackable" alt="" coords="31,5,146,32"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0a6c1cddcf00c77c6ab99b096c86544f"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#a0a6c1cddcf00c77c6ab99b096c86544f">~IOChannel</a> ()</td></tr>
<tr class="separator:a0a6c1cddcf00c77c6ab99b096c86544f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5878a4510f52f194f18c0743f6a9b5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#ae5878a4510f52f194f18c0743f6a9b5c">read</a> (gunichar&amp; thechar)</td></tr>
<tr class="memdesc:ae5878a4510f52f194f18c0743f6a9b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a single UCS-4 character.  <a href="#ae5878a4510f52f194f18c0743f6a9b5c">More...</a><br /></td></tr>
<tr class="separator:ae5878a4510f52f194f18c0743f6a9b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1afb78d2e29a2f01a7034279a0c12636"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#a1afb78d2e29a2f01a7034279a0c12636">read</a> (char* buf, gsize <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01659.html#gad2f89a1340c43c8451e522d045aaa1b6">count</a>, gsize&amp; bytes_read)</td></tr>
<tr class="memdesc:a1afb78d2e29a2f01a7034279a0c12636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a character sequence into memory.  <a href="#a1afb78d2e29a2f01a7034279a0c12636">More...</a><br /></td></tr>
<tr class="separator:a1afb78d2e29a2f01a7034279a0c12636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4553088deea02ebea2ab7a9e2cff0a1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#a4553088deea02ebea2ab7a9e2cff0a1c">read</a> (<a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; str, gsize <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01659.html#gad2f89a1340c43c8451e522d045aaa1b6">count</a>)</td></tr>
<tr class="memdesc:a4553088deea02ebea2ab7a9e2cff0a1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a maximum of <em>count</em> bytes into <em>str</em>.  <a href="#a4553088deea02ebea2ab7a9e2cff0a1c">More...</a><br /></td></tr>
<tr class="separator:a4553088deea02ebea2ab7a9e2cff0a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2950510fff168d5753ee1eb14714d67a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#a2950510fff168d5753ee1eb14714d67a">read_line</a> (<a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; line)</td></tr>
<tr class="memdesc:a2950510fff168d5753ee1eb14714d67a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a whole line.  <a href="#a2950510fff168d5753ee1eb14714d67a">More...</a><br /></td></tr>
<tr class="separator:a2950510fff168d5753ee1eb14714d67a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d64e84ab360b3c83399c94076487df1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#a0d64e84ab360b3c83399c94076487df1">read_to_end</a> (<a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; str)</td></tr>
<tr class="memdesc:a0d64e84ab360b3c83399c94076487df1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads all the remaining data from the file.  <a href="#a0d64e84ab360b3c83399c94076487df1">More...</a><br /></td></tr>
<tr class="separator:a0d64e84ab360b3c83399c94076487df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acacb5599be21f549911c6aca5f820fcf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#acacb5599be21f549911c6aca5f820fcf">write</a> (const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp; str)</td></tr>
<tr class="memdesc:acacb5599be21f549911c6aca5f820fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a string to the I/O channel.  <a href="#acacb5599be21f549911c6aca5f820fcf">More...</a><br /></td></tr>
<tr class="separator:acacb5599be21f549911c6aca5f820fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29114ed2bcb64b8af551271394968528"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#a29114ed2bcb64b8af551271394968528">write</a> (const char* buf, gssize <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01659.html#gad2f89a1340c43c8451e522d045aaa1b6">count</a>, gsize&amp; bytes_written)</td></tr>
<tr class="memdesc:a29114ed2bcb64b8af551271394968528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a memory area of <em>count</em> bytes to the I/O channel.  <a href="#a29114ed2bcb64b8af551271394968528">More...</a><br /></td></tr>
<tr class="separator:a29114ed2bcb64b8af551271394968528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e0a187ff012b3b90c6d3d8593c18e92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#a5e0a187ff012b3b90c6d3d8593c18e92">write</a> (gunichar unichar)</td></tr>
<tr class="memdesc:a5e0a187ff012b3b90c6d3d8593c18e92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a single UCS-4 character to the I/O channel.  <a href="#a5e0a187ff012b3b90c6d3d8593c18e92">More...</a><br /></td></tr>
<tr class="separator:a5e0a187ff012b3b90c6d3d8593c18e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a5048c32ecde11827b5ae1973ee0b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#a65a5048c32ecde11827b5ae1973ee0b1">seek</a> (gint64 offset, <a class="el" href="group__glibmmEnums.html#gaa3767731311bdba4ef42dc99215e5cda">SeekType</a> type=<a class="el" href="namespaceGlib.html#gaa3767731311bdba4ef42dc99215e5cdaaa8e02688f42163a11bb8b47a72456bc4">SEEK_TYPE_SET</a>)</td></tr>
<tr class="memdesc:a65a5048c32ecde11827b5ae1973ee0b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seek the I/O channel to a specific position.  <a href="#a65a5048c32ecde11827b5ae1973ee0b1">More...</a><br /></td></tr>
<tr class="separator:a65a5048c32ecde11827b5ae1973ee0b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba6702093bd1c58ea22231446ed2f6e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#aba6702093bd1c58ea22231446ed2f6e4">flush</a> ()</td></tr>
<tr class="memdesc:aba6702093bd1c58ea22231446ed2f6e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush the buffers of the I/O channel.  <a href="#aba6702093bd1c58ea22231446ed2f6e4">More...</a><br /></td></tr>
<tr class="separator:aba6702093bd1c58ea22231446ed2f6e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a074ce46305db3423879012c5b44dfe64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#a074ce46305db3423879012c5b44dfe64">close</a> (bool flush_pending=true)</td></tr>
<tr class="memdesc:a074ce46305db3423879012c5b44dfe64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the I/O channel.  <a href="#a074ce46305db3423879012c5b44dfe64">More...</a><br /></td></tr>
<tr class="separator:a074ce46305db3423879012c5b44dfe64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f5c5979ad729df9524fcb1940e5d2fe"><td class="memItemLeft" align="right" valign="top">gsize&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#a2f5c5979ad729df9524fcb1940e5d2fe">get_buffer_size</a> () const </td></tr>
<tr class="memdesc:a2f5c5979ad729df9524fcb1940e5d2fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and to integrate them wi...">IOChannel</a> internal buffer size.  <a href="#a2f5c5979ad729df9524fcb1940e5d2fe">More...</a><br /></td></tr>
<tr class="separator:a2f5c5979ad729df9524fcb1940e5d2fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a535767c92f2678e5e72051f6f4bc5326"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#a535767c92f2678e5e72051f6f4bc5326">set_buffer_size</a> (gsize <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01656.html#ga445a43f417432dd1b9aed90ef239c700">size</a>)</td></tr>
<tr class="memdesc:a535767c92f2678e5e72051f6f4bc5326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the internal <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and to integrate them wi...">IOChannel</a> buffer size.  <a href="#a535767c92f2678e5e72051f6f4bc5326">More...</a><br /></td></tr>
<tr class="separator:a535767c92f2678e5e72051f6f4bc5326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15e424b863d398ed458315b7f799243"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__glibmmEnums.html#gaee093e5db5bc1ea5738771ba0d1af3b7">IOFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#ac15e424b863d398ed458315b7f799243">get_flags</a> () const </td></tr>
<tr class="memdesc:ac15e424b863d398ed458315b7f799243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current flags for a <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and to integrate them wi...">IOChannel</a>, including read-only flags such as <a class="el" href="namespaceGlib.html#gaee093e5db5bc1ea5738771ba0d1af3b7a45c527b36c1a1df9b5b1202f84eafeed" title="Indicates that the io channel is readable. ">Glib::IO_FLAG_IS_READABLE</a>.  <a href="#ac15e424b863d398ed458315b7f799243">More...</a><br /></td></tr>
<tr class="separator:ac15e424b863d398ed458315b7f799243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c16c87c174d836247f47c2b87539fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#ab6c16c87c174d836247f47c2b87539fd">set_flags</a> (<a class="el" href="group__glibmmEnums.html#gaee093e5db5bc1ea5738771ba0d1af3b7">IOFlags</a> flags)</td></tr>
<tr class="memdesc:ab6c16c87c174d836247f47c2b87539fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set flags on the <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and to integrate them wi...">IOChannel</a>.  <a href="#ab6c16c87c174d836247f47c2b87539fd">More...</a><br /></td></tr>
<tr class="separator:ab6c16c87c174d836247f47c2b87539fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf37b0d76cd41628fd0c41a674495de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#abaf37b0d76cd41628fd0c41a674495de">set_buffered</a> (bool buffered)</td></tr>
<tr class="memdesc:abaf37b0d76cd41628fd0c41a674495de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the buffering status of the I/O channel.  <a href="#abaf37b0d76cd41628fd0c41a674495de">More...</a><br /></td></tr>
<tr class="separator:abaf37b0d76cd41628fd0c41a674495de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3013c245f30ca81e11c01f8a031b1745"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#a3013c245f30ca81e11c01f8a031b1745">get_buffered</a> () const </td></tr>
<tr class="memdesc:a3013c245f30ca81e11c01f8a031b1745"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the buffering status of the I/O channel.  <a href="#a3013c245f30ca81e11c01f8a031b1745">More...</a><br /></td></tr>
<tr class="separator:a3013c245f30ca81e11c01f8a031b1745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ba943e998468e3b86d841c5aec8a551"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__glibmmEnums.html#gabd96381793b70d4ae32c725926990918">IOCondition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#a9ba943e998468e3b86d841c5aec8a551">get_buffer_condition</a> () const </td></tr>
<tr class="memdesc:a9ba943e998468e3b86d841c5aec8a551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an IOCondition depending on whether there is data to be read/space to write data in the internal buffers in the I/O channel.  <a href="#a9ba943e998468e3b86d841c5aec8a551">More...</a><br /></td></tr>
<tr class="separator:a9ba943e998468e3b86d841c5aec8a551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac93b128c8ee396702b2a20c5a060949d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#ac93b128c8ee396702b2a20c5a060949d">get_close_on_unref</a> () const </td></tr>
<tr class="memdesc:ac93b128c8ee396702b2a20c5a060949d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether the file/socket/whatever associated with the I/O channel will be closed when the channel receives its final unref and is destroyed.  <a href="#ac93b128c8ee396702b2a20c5a060949d">More...</a><br /></td></tr>
<tr class="separator:ac93b128c8ee396702b2a20c5a060949d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4fbc2a4c3670863fbf504d7fc96253"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#a3f4fbc2a4c3670863fbf504d7fc96253">set_close_on_unref</a> (bool do_close)</td></tr>
<tr class="memdesc:a3f4fbc2a4c3670863fbf504d7fc96253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setting this flag to <code>true</code> for a channel you have already closed can cause problems.  <a href="#a3f4fbc2a4c3670863fbf504d7fc96253">More...</a><br /></td></tr>
<tr class="separator:a3f4fbc2a4c3670863fbf504d7fc96253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d3ae667bd425ef830929a67cf526e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#ab1d3ae667bd425ef830929a67cf526e0">set_encoding</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; encoding=<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>())</td></tr>
<tr class="memdesc:ab1d3ae667bd425ef830929a67cf526e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the encoding for the input/output of the channel.  <a href="#ab1d3ae667bd425ef830929a67cf526e0">More...</a><br /></td></tr>
<tr class="separator:ab1d3ae667bd425ef830929a67cf526e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae52a79ec5f3acc2b0990870668c4ea2a"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#ae52a79ec5f3acc2b0990870668c4ea2a">get_encoding</a> () const </td></tr>
<tr class="memdesc:ae52a79ec5f3acc2b0990870668c4ea2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the encoding of the I/O channel.  <a href="#ae52a79ec5f3acc2b0990870668c4ea2a">More...</a><br /></td></tr>
<tr class="separator:ae52a79ec5f3acc2b0990870668c4ea2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad42d03bdd0288cf5517737a73f7268b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#ad42d03bdd0288cf5517737a73f7268b3">set_line_term</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; term=<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>())</td></tr>
<tr class="separator:ad42d03bdd0288cf5517737a73f7268b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd08e7a2a6cbfbdad2ef599c9eadcc01"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#afd08e7a2a6cbfbdad2ef599c9eadcc01">get_line_term</a> () const </td></tr>
<tr class="separator:afd08e7a2a6cbfbdad2ef599c9eadcc01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a755c88fe8c78dc0727b5686fc62b736c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGlib_1_1IOSource.html">IOSource</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#a755c88fe8c78dc0727b5686fc62b736c">create_watch</a> (<a class="el" href="group__glibmmEnums.html#gabd96381793b70d4ae32c725926990918">IOCondition</a> condition)</td></tr>
<tr class="memdesc:a755c88fe8c78dc0727b5686fc62b736c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an <a class="el" href="classGlib_1_1IOSource.html">IOSource</a> object.  <a href="#a755c88fe8c78dc0727b5686fc62b736c">More...</a><br /></td></tr>
<tr class="separator:a755c88fe8c78dc0727b5686fc62b736c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa63e3a39347848387cd9422d0073a7be"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#aa63e3a39347848387cd9422d0073a7be">reference</a> () const </td></tr>
<tr class="separator:aa63e3a39347848387cd9422d0073a7be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c57bf6b00844fc3ddb9d0e60cac7dcf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#a4c57bf6b00844fc3ddb9d0e60cac7dcf">unreference</a> () const </td></tr>
<tr class="separator:a4c57bf6b00844fc3ddb9d0e60cac7dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab05ed8535a51b04749e11386c845a581"><td class="memItemLeft" align="right" valign="top">GIOChannel*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#ab05ed8535a51b04749e11386c845a581">gobj</a> ()</td></tr>
<tr class="separator:ab05ed8535a51b04749e11386c845a581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad550f12d9d2ec2fef0a2c7ba78f2595"><td class="memItemLeft" align="right" valign="top">const GIOChannel*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#aad550f12d9d2ec2fef0a2c7ba78f2595">gobj</a> () const </td></tr>
<tr class="separator:aad550f12d9d2ec2fef0a2c7ba78f2595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_structsigc_1_1trackable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_structsigc_1_1trackable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1trackable.html">sigc::trackable</a></td></tr>
<tr class="memitem:a7e1348841e762fb41b41c6f2ce9fa073 inherit pub_methods_structsigc_1_1trackable"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="file:///C:/msys/1.0/local/share/doc/libsigc++-2.0/reference/html/structsigc_1_1trackable.html#a7e1348841e762fb41b41c6f2ce9fa073">trackable</a> () noexcept</td></tr>
<tr class="separator:a7e1348841e762fb41b41c6f2ce9fa073 inherit pub_methods_structsigc_1_1trackable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8431d9452c9698a012597e6560c72fa inherit pub_methods_structsigc_1_1trackable"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="file:///C:/msys/1.0/local/share/doc/libsigc++-2.0/reference/html/structsigc_1_1trackable.html#ac8431d9452c9698a012597e6560c72fa">trackable</a> (const <a class="elRef" href="file:///C:/msys/1.0/local/share/doc/libsigc++-2.0/reference/html/structsigc_1_1trackable.html">trackable</a> &amp;src) noexcept</td></tr>
<tr class="separator:ac8431d9452c9698a012597e6560c72fa inherit pub_methods_structsigc_1_1trackable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba42ed8afb6598106cf68c18a7387f18 inherit pub_methods_structsigc_1_1trackable"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="file:///C:/msys/1.0/local/share/doc/libsigc++-2.0/reference/html/structsigc_1_1trackable.html#aba42ed8afb6598106cf68c18a7387f18">trackable</a> (<a class="elRef" href="file:///C:/msys/1.0/local/share/doc/libsigc++-2.0/reference/html/structsigc_1_1trackable.html">trackable</a> &amp;&amp;src)</td></tr>
<tr class="separator:aba42ed8afb6598106cf68c18a7387f18 inherit pub_methods_structsigc_1_1trackable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75587da09e30031db7a2519843f1f4fb inherit pub_methods_structsigc_1_1trackable"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="file:///C:/msys/1.0/local/share/doc/libsigc++-2.0/reference/html/structsigc_1_1trackable.html#a75587da09e30031db7a2519843f1f4fb">~trackable</a> ()</td></tr>
<tr class="separator:a75587da09e30031db7a2519843f1f4fb inherit pub_methods_structsigc_1_1trackable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab14931670837728e49bb5ca88fb16db5 inherit pub_methods_structsigc_1_1trackable"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="file:///C:/msys/1.0/local/share/doc/libsigc++-2.0/reference/html/structsigc_1_1trackable.html#ab14931670837728e49bb5ca88fb16db5">add_destroy_notify_callback</a> (void *data, <a class="elRef" href="file:///C:/msys/1.0/local/share/doc/libsigc++-2.0/reference/html/structsigc_1_1trackable.html#a3338954d7565534bd945290b798e13ed">func_destroy_notify</a> func) const </td></tr>
<tr class="separator:ab14931670837728e49bb5ca88fb16db5 inherit pub_methods_structsigc_1_1trackable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e23cfe7adc1ca844a3350bbac557cb inherit pub_methods_structsigc_1_1trackable"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="file:///C:/msys/1.0/local/share/doc/libsigc++-2.0/reference/html/structsigc_1_1trackable.html#af2e23cfe7adc1ca844a3350bbac557cb">notify_callbacks</a> ()</td></tr>
<tr class="separator:af2e23cfe7adc1ca844a3350bbac557cb inherit pub_methods_structsigc_1_1trackable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7494fbad23a65932ff1457d00d4edaf5 inherit pub_methods_structsigc_1_1trackable"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="file:///C:/msys/1.0/local/share/doc/libsigc++-2.0/reference/html/structsigc_1_1trackable.html">trackable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="file:///C:/msys/1.0/local/share/doc/libsigc++-2.0/reference/html/structsigc_1_1trackable.html#a7494fbad23a65932ff1457d00d4edaf5">operator=</a> (const <a class="elRef" href="file:///C:/msys/1.0/local/share/doc/libsigc++-2.0/reference/html/structsigc_1_1trackable.html">trackable</a> &amp;src)</td></tr>
<tr class="separator:a7494fbad23a65932ff1457d00d4edaf5 inherit pub_methods_structsigc_1_1trackable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d61cdb452dc46fcdc8a8d42d9c079d inherit pub_methods_structsigc_1_1trackable"><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="file:///C:/msys/1.0/local/share/doc/libsigc++-2.0/reference/html/structsigc_1_1trackable.html">trackable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="file:///C:/msys/1.0/local/share/doc/libsigc++-2.0/reference/html/structsigc_1_1trackable.html#ac3d61cdb452dc46fcdc8a8d42d9c079d">operator=</a> (<a class="elRef" href="file:///C:/msys/1.0/local/share/doc/libsigc++-2.0/reference/html/structsigc_1_1trackable.html">trackable</a> &amp;&amp;src)</td></tr>
<tr class="separator:ac3d61cdb452dc46fcdc8a8d42d9c079d inherit pub_methods_structsigc_1_1trackable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b9dffa8a50ff13ba33e6c7f10468e2b inherit pub_methods_structsigc_1_1trackable"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="file:///C:/msys/1.0/local/share/doc/libsigc++-2.0/reference/html/structsigc_1_1trackable.html#a8b9dffa8a50ff13ba33e6c7f10468e2b">remove_destroy_notify_callback</a> (void *data) const </td></tr>
<tr class="separator:a8b9dffa8a50ff13ba33e6c7f10468e2b inherit pub_methods_structsigc_1_1trackable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ac175ea1fd6ef84ac3758ca57b42b7f33"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGlib_1_1IOChannel.html">IOChannel</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#ac175ea1fd6ef84ac3758ca57b42b7f33">create_from_file</a> (const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; filename, const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>&amp; mode)</td></tr>
<tr class="memdesc:ac175ea1fd6ef84ac3758ca57b42b7f33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a file <em>filename</em> as an I/O channel using mode <em>mode</em>.  <a href="#ac175ea1fd6ef84ac3758ca57b42b7f33">More...</a><br /></td></tr>
<tr class="separator:ac175ea1fd6ef84ac3758ca57b42b7f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078698e18f61bb75fe3fd33d82970f5d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGlib_1_1IOChannel.html">IOChannel</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#a078698e18f61bb75fe3fd33d82970f5d">create_from_fd</a> (int fd)</td></tr>
<tr class="memdesc:a078698e18f61bb75fe3fd33d82970f5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an I/O channel from a file descriptor.  <a href="#a078698e18f61bb75fe3fd33d82970f5d">More...</a><br /></td></tr>
<tr class="separator:a078698e18f61bb75fe3fd33d82970f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a22bd01752d233c23babdef800c0d87"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGlib_1_1IOChannel.html">IOChannel</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#a1a22bd01752d233c23babdef800c0d87">create_from_win32_fd</a> (int fd)</td></tr>
<tr class="memdesc:a1a22bd01752d233c23babdef800c0d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an I/O channel for C runtime (emulated Unix-like) file descriptors.  <a href="#a1a22bd01752d233c23babdef800c0d87">More...</a><br /></td></tr>
<tr class="separator:a1a22bd01752d233c23babdef800c0d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087946554b86d42f1cd72277fd1b0530"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGlib_1_1IOChannel.html">IOChannel</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#a087946554b86d42f1cd72277fd1b0530">create_from_win32_socket</a> (int socket)</td></tr>
<tr class="memdesc:a087946554b86d42f1cd72277fd1b0530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an I/O channel for a winsock socket.  <a href="#a087946554b86d42f1cd72277fd1b0530">More...</a><br /></td></tr>
<tr class="separator:a087946554b86d42f1cd72277fd1b0530"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aded3d9a998914bcac0b3f1aef1eeb974"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#aded3d9a998914bcac0b3f1aef1eeb974">IOChannel</a> ()</td></tr>
<tr class="memdesc:aded3d9a998914bcac0b3f1aef1eeb974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor that should be used by derived classes.  <a href="#aded3d9a998914bcac0b3f1aef1eeb974">More...</a><br /></td></tr>
<tr class="separator:aded3d9a998914bcac0b3f1aef1eeb974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb4faa07e80b86f21b0f18f0b8606cd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#abfb4faa07e80b86f21b0f18f0b8606cd">read_vfunc</a> (char* buf, gsize <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01659.html#gad2f89a1340c43c8451e522d045aaa1b6">count</a>, gsize&amp; bytes_read)</td></tr>
<tr class="separator:abfb4faa07e80b86f21b0f18f0b8606cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed5372da9d4ad3465012fc2317507b5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#a4ed5372da9d4ad3465012fc2317507b5">write_vfunc</a> (const char* buf, gsize <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01659.html#gad2f89a1340c43c8451e522d045aaa1b6">count</a>, gsize&amp; bytes_written)</td></tr>
<tr class="separator:a4ed5372da9d4ad3465012fc2317507b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781de88aec2c032d05f74402779665f3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#a781de88aec2c032d05f74402779665f3">seek_vfunc</a> (gint64 offset, <a class="el" href="group__glibmmEnums.html#gaa3767731311bdba4ef42dc99215e5cda">SeekType</a> type)</td></tr>
<tr class="separator:a781de88aec2c032d05f74402779665f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a735b70808acbb542b04bf55b0133927e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#a735b70808acbb542b04bf55b0133927e">close_vfunc</a> ()</td></tr>
<tr class="separator:a735b70808acbb542b04bf55b0133927e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f690f1e0a8945b75ad7be4949e44cf"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#af8f690f1e0a8945b75ad7be4949e44cf">set_flags_vfunc</a> (<a class="el" href="group__glibmmEnums.html#gaee093e5db5bc1ea5738771ba0d1af3b7">IOFlags</a> flags)</td></tr>
<tr class="separator:af8f690f1e0a8945b75ad7be4949e44cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3326db3877358b563de11fb3dd8367f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__glibmmEnums.html#gaee093e5db5bc1ea5738771ba0d1af3b7">IOFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#ae3326db3877358b563de11fb3dd8367f">get_flags_vfunc</a> ()</td></tr>
<tr class="separator:ae3326db3877358b563de11fb3dd8367f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a128f2bfd977617a6a1a7e4a7fbe6aa5b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGlib_1_1Source.html">Glib::Source</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#a128f2bfd977617a6a1a7e4a7fbe6aa5b">create_watch_vfunc</a> (<a class="el" href="group__glibmmEnums.html#gabd96381793b70d4ae32c725926990918">IOCondition</a> cond)</td></tr>
<tr class="separator:a128f2bfd977617a6a1a7e4a7fbe6aa5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a6683e47c0d78492b83d7021288d9b6d0"><td class="memItemLeft" align="right" valign="top">GIOChannel*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGlib_1_1IOChannel.html#a6683e47c0d78492b83d7021288d9b6d0">gobject_</a></td></tr>
<tr class="separator:a6683e47c0d78492b83d7021288d9b6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_structsigc_1_1trackable"><td colspan="2" onclick="javascript:toggleInherit('pub_types_structsigc_1_1trackable')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="http://library.gnome.org/devel/libsigc++/unstable/structsigc_1_1trackable.html">sigc::trackable</a></td></tr>
<tr class="memitem:a3338954d7565534bd945290b798e13ed inherit pub_types_structsigc_1_1trackable"><td class="memItemLeft" align="right" valign="top">typedef internal::func_destroy_notify&#160;</td><td class="memItemRight" valign="bottom"><a class="elRef" href="file:///C:/msys/1.0/local/share/doc/libsigc++-2.0/reference/html/structsigc_1_1trackable.html#a3338954d7565534bd945290b798e13ed">func_destroy_notify</a></td></tr>
<tr class="separator:a3338954d7565534bd945290b798e13ed inherit pub_types_structsigc_1_1trackable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and to integrate them wi...">IOChannel</a> aims to provide portable I/O support for files, pipes and sockets, and to integrate them with the GLib main event loop. </p>
<p>Note that IOChannels implement an automatic implicit character set conversion to the data stream, and usually will not pass by default binary data unchanged. To set the encoding of the channel, use e.g. set_encoding("ISO-8859-15"). To set the channel to no encoding, use <a class="el" href="classGlib_1_1IOChannel.html#ab1d3ae667bd425ef830929a67cf526e0" title="Sets the encoding for the input/output of the channel. ">set_encoding()</a> without any arguments.</p>
<p>You can create an <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and to integrate them wi...">IOChannel</a> with one of the static create methods. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a0a6c1cddcf00c77c6ab99b096c86544f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Glib::IOChannel::~IOChannel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aded3d9a998914bcac0b3f1aef1eeb974"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Glib::IOChannel::IOChannel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor that should be used by derived classes. </p>
<p>Use this constructor if you want to inherit from <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and to integrate them wi...">IOChannel</a>. It will set up a GIOChannel that will call the vfuncs of your class even if it is being used from C code, and it will keep a reference to the C++ code while the GIOChannel exists. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a074ce46305db3423879012c5b44dfe64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> Glib::IOChannel::close </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flush_pending</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close the I/O channel. </p>
<p>Any pending data to be written will be flushed if <em>flush</em> is <code>true</code>. The channel will not be freed until the last reference is dropped. Accessing the channel after closing it is considered an error. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flush_pending</td><td>Whether to <a class="el" href="classGlib_1_1IOChannel.html#aba6702093bd1c58ea22231446ed2f6e4" title="Flush the buffers of the I/O channel. ">flush()</a> pending data before closing the channel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status of the operation. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classGlib_1_1IOChannelError.html" title="Exception class for IOChannel errors. ">Glib::IOChannelError</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a735b70808acbb542b04bf55b0133927e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> Glib::IOChannel::close_vfunc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000005">Deprecated:</a></b></dt><dd>Custom <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and to integrate them wi...">Glib::IOChannel</a> implementation was never really supported. </dd></dl>

<p>Reimplemented in <a class="el" href="classGlib_1_1StreamIOChannel.html#a75a9297cdbd4d88dcd7151403ef51c02">Glib::StreamIOChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a078698e18f61bb75fe3fd33d82970f5d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGlib_1_1IOChannel.html">IOChannel</a>&gt; Glib::IOChannel::create_from_fd </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates an I/O channel from a file descriptor. </p>
<p>On Unix, IOChannels created with this function work for any file descriptor or socket.</p>
<p>On Win32, this can be used either for files opened with the MSVCRT (the Microsoft run-time C library) <code>_open()</code> or <code>_pipe()</code>, including file descriptors 0, 1 and 2 (corresponding to <code>stdin</code>, <code>stdout</code> and <code>stderr</code>), or for Winsock <code>SOCKET</code>s. If the parameter is a legal file descriptor, it is assumed to be such, otherwise it should be a <code>SOCKET</code>. This relies on <code>SOCKET</code>s and file descriptors not overlapping. If you want to be certain, call either <a class="el" href="classGlib_1_1IOChannel.html#a1a22bd01752d233c23babdef800c0d87" title="Create an I/O channel for C runtime (emulated Unix-like) file descriptors. ">create_from_win32_fd()</a> or <a class="el" href="classGlib_1_1IOChannel.html#a087946554b86d42f1cd72277fd1b0530" title="Create an I/O channel for a winsock socket. ">create_from_win32_socket()</a> instead as appropriate.</p>
<p>The term file descriptor as used in the context of Win32 refers to the emulated Unix-like file descriptors MSVCRT provides. The native corresponding concept is file <code>HANDLE</code>. There isn't as of yet a way to get IOChannels for Win32 file <code>HANDLE</code>s. </p>

</div>
</div>
<a class="anchor" id="ac175ea1fd6ef84ac3758ca57b42b7f33"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGlib_1_1IOChannel.html">IOChannel</a>&gt; Glib::IOChannel::create_from_file </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Open a file <em>filename</em> as an I/O channel using mode <em>mode</em>. </p>
<p>This channel will be closed when the last reference to it is dropped, so there is no need to call <a class="el" href="classGlib_1_1IOChannel.html#a074ce46305db3423879012c5b44dfe64" title="Close the I/O channel. ">close()</a> (though doing so will not cause problems, as long as no attempt is made to access the channel after it is closed). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the file to open. </td></tr>
    <tr><td class="paramname">mode</td><td>One of <code>"r"</code>, <code>"w"</code>, <code>"a"</code>, <code>"r+"</code>, <code>"w+"</code>, <code>"a+"</code>. These have the same meaning as in <code>fopen()</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and to integrate them wi...">IOChannel</a> for the opened file. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classGlib_1_1FileError.html" title="Exception class for file-related errors. ">Glib::FileError</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1a22bd01752d233c23babdef800c0d87"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGlib_1_1IOChannel.html">IOChannel</a>&gt; Glib::IOChannel::create_from_win32_fd </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an I/O channel for C runtime (emulated Unix-like) file descriptors. </p>
<p>After calling add_watch() on a I/O channel returned by this function, you shouldn't call <a class="el" href="classGlib_1_1IOChannel.html#ae5878a4510f52f194f18c0743f6a9b5c" title="Read a single UCS-4 character. ">read()</a> on the file descriptor. This is because adding polling for a file descriptor is implemented on Win32 by starting a thread that sits blocked in a <code>read()</code> from the file descriptor most of the time. All reads from the file descriptor should be done by this internal GLib thread. Your code should call only <a class="el" href="classGlib_1_1IOChannel.html#ae5878a4510f52f194f18c0743f6a9b5c" title="Read a single UCS-4 character. ">IOChannel::read()</a>. </p>

</div>
</div>
<a class="anchor" id="a087946554b86d42f1cd72277fd1b0530"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGlib_1_1IOChannel.html">IOChannel</a>&gt; Glib::IOChannel::create_from_win32_socket </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socket</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an I/O channel for a winsock socket. </p>
<p>The parameter should be a <code>SOCKET</code>. Contrary to I/O channels for file descriptors (on Win32), you can use normal <code>recv()</code> or <code>recvfrom()</code> on sockets even if GLib is polling them. </p>

</div>
</div>
<a class="anchor" id="a755c88fe8c78dc0727b5686fc62b736c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGlib_1_1IOSource.html">IOSource</a>&gt; Glib::IOChannel::create_watch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#gabd96381793b70d4ae32c725926990918">IOCondition</a>&#160;</td>
          <td class="paramname"><em>condition</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an <a class="el" href="classGlib_1_1IOSource.html">IOSource</a> object. </p>
<p>Create a slot from a function to be called when condition is met for the channel with <a class="elRef" href="file:///C:/msys/1.0/local/share/doc/libsigc++-2.0/reference/html/group__ptr__fun.html#ga9c80de72f656fb05e81fda622dddc863">sigc::ptr_fun()</a> or <a class="elRef" href="file:///C:/msys/1.0/local/share/doc/libsigc++-2.0/reference/html/group__mem__fun.html#gadf6b6d22c503b439019f0a2e77352419">sigc::mem_fun()</a> and pass it into the connect() function of the returned <a class="el" href="classGlib_1_1IOSource.html">IOSource</a> object. Polling of the channel will start when you attach a <a class="el" href="classGlib_1_1MainContext.html" title="Main context. ">MainContext</a> object to the returned <a class="el" href="classGlib_1_1IOSource.html">IOSource</a> object using its attach() function.</p>
<p><a class="el" href="group__MainLoop.html#gaf391654b755a32169d18be4835677376" title="Convenience I/O signal. ">Glib::signal_io()</a>.connect() is a simpler interface to the same functionality, for the case where you want to add the source to the default main context. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">condition</td><td>The condition to watch for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classGlib_1_1IOSource.html">IOSource</a> object that can be polled from a <a class="el" href="classGlib_1_1MainContext.html" title="Main context. ">MainContext</a>'s event loop. </dd></dl>

</div>
</div>
<a class="anchor" id="a128f2bfd977617a6a1a7e4a7fbe6aa5b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGlib_1_1Source.html">Glib::Source</a>&gt; Glib::IOChannel::create_watch_vfunc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#gabd96381793b70d4ae32c725926990918">IOCondition</a>&#160;</td>
          <td class="paramname"><em>cond</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000008">Deprecated:</a></b></dt><dd>Custom <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and to integrate them wi...">Glib::IOChannel</a> implementation was never really supported. </dd></dl>

<p>Reimplemented in <a class="el" href="classGlib_1_1StreamIOChannel.html#a9e447a1517b139a25b7dbdd19a46c617">Glib::StreamIOChannel</a>.</p>

</div>
</div>
<a class="anchor" id="aba6702093bd1c58ea22231446ed2f6e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> Glib::IOChannel::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush the buffers of the I/O channel. </p>
<dl class="section return"><dt>Returns</dt><dd>The status of the operation. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classGlib_1_1IOChannelError.html" title="Exception class for IOChannel errors. ">Glib::IOChannelError</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="classGlib_1_1ConvertError.html" title="Exception class for charset conversion errors. ">Glib::ConvertError</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9ba943e998468e3b86d841c5aec8a551"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__glibmmEnums.html#gabd96381793b70d4ae32c725926990918">IOCondition</a> Glib::IOChannel::get_buffer_condition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an IOCondition depending on whether there is data to be read/space to write data in the internal buffers in the I/O channel. </p>
<p>Only the flags <a class="el" href="namespaceGlib.html#gabd96381793b70d4ae32c725926990918aa38ee764d957d52ccd85688c27778daf" title="A bitwise combination representing an I/O condition to watch for on an event source. ">Glib::IO_IN</a> and <a class="el" href="namespaceGlib.html#gabd96381793b70d4ae32c725926990918a0945b81e85eb8d2d26e77fdc04821cae" title="Data can be written (without blocking). ">Glib::IO_OUT</a> may be set. </p><dl class="section return"><dt>Returns</dt><dd>Bitwise combination of <a class="el" href="group__glibmmEnums.html#gabd96381793b70d4ae32c725926990918" title="A bitwise combination representing a condition to watch for on an event source. ">Glib::IOCondition</a> flags. </dd></dl>

</div>
</div>
<a class="anchor" id="a2f5c5979ad729df9524fcb1940e5d2fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gsize Glib::IOChannel::get_buffer_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and to integrate them wi...">IOChannel</a> internal buffer size. </p>
<dl class="section return"><dt>Returns</dt><dd>The buffer size. </dd></dl>

</div>
</div>
<a class="anchor" id="a3013c245f30ca81e11c01f8a031b1745"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::IOChannel::get_buffered </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the buffering status of the I/O channel. </p>
<dl class="section return"><dt>Returns</dt><dd>The buffering status of the channel. </dd></dl>

</div>
</div>
<a class="anchor" id="ac93b128c8ee396702b2a20c5a060949d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Glib::IOChannel::get_close_on_unref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether the file/socket/whatever associated with the I/O channel will be closed when the channel receives its final unref and is destroyed. </p>
<p>The default value of this is <code>true</code> for channels created by <a class="el" href="classGlib_1_1IOChannel.html#ac175ea1fd6ef84ac3758ca57b42b7f33" title="Open a file filename as an I/O channel using mode mode. ">create_from_file()</a>, and <code>false</code> for all other channels. </p><dl class="section return"><dt>Returns</dt><dd>Whether the channel will be closed on the final unref of the <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and to integrate them wi...">IOChannel</a> object. </dd></dl>

</div>
</div>
<a class="anchor" id="ae52a79ec5f3acc2b0990870668c4ea2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> Glib::IOChannel::get_encoding </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the encoding of the I/O channel. </p>
<dl class="section return"><dt>Returns</dt><dd>The current encoding of the channel. </dd></dl>

</div>
</div>
<a class="anchor" id="ac15e424b863d398ed458315b7f799243"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__glibmmEnums.html#gaee093e5db5bc1ea5738771ba0d1af3b7">IOFlags</a> Glib::IOChannel::get_flags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current flags for a <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and to integrate them wi...">IOChannel</a>, including read-only flags such as <a class="el" href="namespaceGlib.html#gaee093e5db5bc1ea5738771ba0d1af3b7a45c527b36c1a1df9b5b1202f84eafeed" title="Indicates that the io channel is readable. ">Glib::IO_FLAG_IS_READABLE</a>. </p>
<p>The values of the flags <a class="el" href="namespaceGlib.html#gaee093e5db5bc1ea5738771ba0d1af3b7a45c527b36c1a1df9b5b1202f84eafeed" title="Indicates that the io channel is readable. ">Glib::IO_FLAG_IS_READABLE</a> and <a class="el" href="namespaceGlib.html#gaee093e5db5bc1ea5738771ba0d1af3b7ac8bc4ce7e268189488cb98c94e15ce66" title="A misspelled version of G_IO_FLAG_IS_WRITABLE that existed before the spelling was fixed in GLib 2...">Glib::IO_FLAG_IS_WRITEABLE</a> are cached for internal use by the channel when it is created. If they should change at some later point (e.g. partial shutdown of a socket with the UNIX <code>shutdown()</code> function), the user should immediately call <a class="el" href="classGlib_1_1IOChannel.html#ac15e424b863d398ed458315b7f799243" title="Get the current flags for a IOChannel, including read-only flags such as Glib::IO_FLAG_IS_READABLE. ">get_flags()</a> to update the internal values of these flags. </p><dl class="section return"><dt>Returns</dt><dd>Bitwise combination of the flags set on the channel. </dd></dl>

</div>
</div>
<a class="anchor" id="ae3326db3877358b563de11fb3dd8367f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__glibmmEnums.html#gaee093e5db5bc1ea5738771ba0d1af3b7">IOFlags</a> Glib::IOChannel::get_flags_vfunc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000007">Deprecated:</a></b></dt><dd>Custom <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and to integrate them wi...">Glib::IOChannel</a> implementation was never really supported. </dd></dl>

<p>Reimplemented in <a class="el" href="classGlib_1_1StreamIOChannel.html#a02e90d9f7b0a80d01c8134b6d86c824c">Glib::StreamIOChannel</a>.</p>

</div>
</div>
<a class="anchor" id="afd08e7a2a6cbfbdad2ef599c9eadcc01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> Glib::IOChannel::get_line_term </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab05ed8535a51b04749e11386c845a581"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GIOChannel* Glib::IOChannel::gobj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aad550f12d9d2ec2fef0a2c7ba78f2595"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const GIOChannel* Glib::IOChannel::gobj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae5878a4510f52f194f18c0743f6a9b5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> Glib::IOChannel::read </td>
          <td>(</td>
          <td class="paramtype">gunichar &amp;&#160;</td>
          <td class="paramname"><em>thechar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a single UCS-4 character. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">thechar</td><td>The <a class="el" href="namespaceGlib_1_1Unicode.html">Unicode</a> character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status of the operation. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classGlib_1_1IOChannelError.html" title="Exception class for IOChannel errors. ">Glib::IOChannelError</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="classGlib_1_1ConvertError.html" title="Exception class for charset conversion errors. ">Glib::ConvertError</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1afb78d2e29a2f01a7034279a0c12636"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> Glib::IOChannel::read </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp;&#160;</td>
          <td class="paramname"><em>bytes_read</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a character sequence into memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>A buffer to read data into. </td></tr>
    <tr><td class="paramname">count</td><td>The size of the buffer in bytes. Note that the buffer may not be complelely filled even if there is data in the buffer if the remaining data is not a complete character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bytes_read</td><td>The number of bytes read. This may be zero even on success if <em>count</em> &lt; 6 and the channel's encoding is not <code>""</code>. This indicates that the next UTF-8 character is too wide for the buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status of the operation. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classGlib_1_1IOChannelError.html" title="Exception class for IOChannel errors. ">Glib::IOChannelError</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="classGlib_1_1ConvertError.html" title="Exception class for charset conversion errors. ">Glib::ConvertError</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4553088deea02ebea2ab7a9e2cff0a1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> Glib::IOChannel::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a maximum of <em>count</em> bytes into <em>str</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>The maximum number of bytes to read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">str</td><td>The characters that have been read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status of the operation. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classGlib_1_1IOChannelError.html" title="Exception class for IOChannel errors. ">Glib::IOChannelError</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="classGlib_1_1ConvertError.html" title="Exception class for charset conversion errors. ">Glib::ConvertError</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2950510fff168d5753ee1eb14714d67a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> Glib::IOChannel::read_line </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a whole line. </p>
<p>Reads until the line separator is found, which is included in the result string. </p><dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">line</td><td>The line that was read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status of the operation. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classGlib_1_1IOChannelError.html" title="Exception class for IOChannel errors. ">Glib::IOChannelError</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="classGlib_1_1ConvertError.html" title="Exception class for charset conversion errors. ">Glib::ConvertError</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0d64e84ab360b3c83399c94076487df1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> Glib::IOChannel::read_to_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads all the remaining data from the file. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">str</td><td>The resulting string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespaceGlib.html#ga23fb251e48485b62a9c2677bb1f87d5eaf2008e64a9691fc76ad9320baef5c8ba" title="Success. ">Glib::IO_STATUS_NORMAL</a> on success. This function never returns <a class="el" href="namespaceGlib.html#ga23fb251e48485b62a9c2677bb1f87d5ea63be2a355cd7187f9ccdd854c80fd10c" title="End of file. ">Glib::IO_STATUS_EOF</a>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classGlib_1_1IOChannelError.html" title="Exception class for IOChannel errors. ">Glib::IOChannelError</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="classGlib_1_1ConvertError.html" title="Exception class for charset conversion errors. ">Glib::ConvertError</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abfb4faa07e80b86f21b0f18f0b8606cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> Glib::IOChannel::read_vfunc </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp;&#160;</td>
          <td class="paramname"><em>bytes_read</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>Custom <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and to integrate them wi...">Glib::IOChannel</a> implementation was never really supported. </dd></dl>

<p>Reimplemented in <a class="el" href="classGlib_1_1StreamIOChannel.html#a24138a4545a14e11fe63e5226167bc71">Glib::StreamIOChannel</a>.</p>

</div>
</div>
<a class="anchor" id="aa63e3a39347848387cd9422d0073a7be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Glib::IOChannel::reference </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a65a5048c32ecde11827b5ae1973ee0b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> Glib::IOChannel::seek </td>
          <td>(</td>
          <td class="paramtype">gint64&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#gaa3767731311bdba4ef42dc99215e5cda">SeekType</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="namespaceGlib.html#gaa3767731311bdba4ef42dc99215e5cdaaa8e02688f42163a11bb8b47a72456bc4">SEEK_TYPE_SET</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Seek the I/O channel to a specific position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The offset in bytes from the position specified by <em>type</em>. </td></tr>
    <tr><td class="paramname">type</td><td>A SeekType. The type <a class="el" href="namespaceGlib.html#gaa3767731311bdba4ef42dc99215e5cdaac0fc030f79f4b5623de9867333011e30" title="The current position in the file. ">Glib::SEEK_TYPE_CUR</a> is only allowed in those cases where a call to <a class="el" href="classGlib_1_1IOChannel.html#ab1d3ae667bd425ef830929a67cf526e0" title="Sets the encoding for the input/output of the channel. ">set_encoding()</a> is allowed. See the documentation for <a class="el" href="classGlib_1_1IOChannel.html#ab1d3ae667bd425ef830929a67cf526e0" title="Sets the encoding for the input/output of the channel. ">set_encoding()</a> for details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status of the operation. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classGlib_1_1IOChannelError.html" title="Exception class for IOChannel errors. ">Glib::IOChannelError</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="classGlib_1_1ConvertError.html" title="Exception class for charset conversion errors. ">Glib::ConvertError</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a781de88aec2c032d05f74402779665f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> Glib::IOChannel::seek_vfunc </td>
          <td>(</td>
          <td class="paramtype">gint64&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#gaa3767731311bdba4ef42dc99215e5cda">SeekType</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd>Custom <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and to integrate them wi...">Glib::IOChannel</a> implementation was never really supported. </dd></dl>

<p>Reimplemented in <a class="el" href="classGlib_1_1StreamIOChannel.html#a0c8d70439ad73056437d650a7f732c51">Glib::StreamIOChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a535767c92f2678e5e72051f6f4bc5326"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Glib::IOChannel::set_buffer_size </td>
          <td>(</td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the internal <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and to integrate them wi...">IOChannel</a> buffer size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The buffer size the <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and to integrate them wi...">IOChannel</a> should use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abaf37b0d76cd41628fd0c41a674495de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Glib::IOChannel::set_buffered </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>buffered</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the buffering status of the I/O channel. </p>
<p>The buffering state can only be set if the channel's encoding is <code>""</code>. For any other encoding, the channel must be buffered.</p>
<p>A buffered channel can only be set unbuffered if the channel's internal buffers have been flushed. Newly created channels or channels which have returned <a class="el" href="namespaceGlib.html#ga23fb251e48485b62a9c2677bb1f87d5ea63be2a355cd7187f9ccdd854c80fd10c" title="End of file. ">Glib::IO_STATUS_EOF</a> not require such a flush. For write-only channels, a call to <a class="el" href="classGlib_1_1IOChannel.html#aba6702093bd1c58ea22231446ed2f6e4" title="Flush the buffers of the I/O channel. ">flush()</a> is sufficient. For all other channels, the buffers may be flushed by a call to <a class="el" href="classGlib_1_1IOChannel.html#a65a5048c32ecde11827b5ae1973ee0b1" title="Seek the I/O channel to a specific position. ">seek()</a>. This includes the possibility of seeking with seek type <a class="el" href="namespaceGlib.html#gaa3767731311bdba4ef42dc99215e5cdaac0fc030f79f4b5623de9867333011e30" title="The current position in the file. ">Glib::SEEK_TYPE_CUR</a> and an offset of zero. Note that this means that socket-based channels cannot be set unbuffered once they have had data read from them.</p>
<p>The default state of the channel is buffered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffered</td><td>Whether to set the channel buffered or unbuffered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3f4fbc2a4c3670863fbf504d7fc96253"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Glib::IOChannel::set_close_on_unref </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>do_close</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Setting this flag to <code>true</code> for a channel you have already closed can cause problems. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">do_close</td><td>Whether to close the channel on the final unref of the <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and to integrate them wi...">IOChannel</a> object. The default value of this is <code>true</code> for channels created by <a class="el" href="classGlib_1_1IOChannel.html#ac175ea1fd6ef84ac3758ca57b42b7f33" title="Open a file filename as an I/O channel using mode mode. ">create_from_file()</a>, and <code>false</code> for all other channels. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab1d3ae667bd425ef830929a67cf526e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> Glib::IOChannel::set_encoding </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>encoding</em> = <code><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the encoding for the input/output of the channel. </p>
<p>The internal encoding is always UTF-8. The default encoding for the external file is UTF-8. The encoding <code>""</code> is safe to use with binary data.</p>
<p>The encoding can only be set if one of the following conditions is true:</p>
<ol type="1">
<li>The channel was just created, and has not been written to or read from yet.</li>
<li>The channel is write-only.</li>
<li>The channel is a file, and the file pointer was just repositioned by a call to seek_position(). (This flushes all the internal buffers.)</li>
<li>The current encoding is <code>""</code> or UTF-8.</li>
<li>One of the read methods has just returned <a class="el" href="namespaceGlib.html#ga23fb251e48485b62a9c2677bb1f87d5ea63be2a355cd7187f9ccdd854c80fd10c" title="End of file. ">Glib::IO_STATUS_EOF</a> (or, in the case of <a class="el" href="classGlib_1_1IOChannel.html#a0d64e84ab360b3c83399c94076487df1" title="Reads all the remaining data from the file. ">read_to_end()</a>, <a class="el" href="namespaceGlib.html#ga23fb251e48485b62a9c2677bb1f87d5eaf2008e64a9691fc76ad9320baef5c8ba" title="Success. ">Glib::IO_STATUS_NORMAL</a>).</li>
<li>The <a class="el" href="classGlib_1_1IOChannel.html#ae5878a4510f52f194f18c0743f6a9b5c" title="Read a single UCS-4 character. ">read()</a> method has returned <a class="el" href="namespaceGlib.html#ga23fb251e48485b62a9c2677bb1f87d5ead240a3a0fd203dd76e11b76a8115d881" title="Resource temporarily unavailable. ">Glib::IO_STATUS_AGAIN</a> or thrown a <a class="el" href="classGlib_1_1Error.html">Glib::Error</a> exception. This may be useful in the case of <a class="el" href="group__CharsetConv.html#ggaea4b79ac3149c1fcfcab32155e3561a9a78ad26d8d7b6f5dabfd812747508275e" title="Invalid byte sequence in conversion input. ">ConvertError::ILLEGAL_SEQUENCE</a>. Returning one of these statuses from <a class="el" href="classGlib_1_1IOChannel.html#a2950510fff168d5753ee1eb14714d67a" title="Read a whole line. ">read_line()</a> or <a class="el" href="classGlib_1_1IOChannel.html#a0d64e84ab360b3c83399c94076487df1" title="Reads all the remaining data from the file. ">read_to_end()</a> does <em>not</em> guarantee that the encoding can be changed.</li>
</ol>
<p>Channels which do not meet one of the above conditions cannot call seek_position() with a seek type of <a class="el" href="namespaceGlib.html#gaa3767731311bdba4ef42dc99215e5cdaac0fc030f79f4b5623de9867333011e30" title="The current position in the file. ">Glib::SEEK_TYPE_CUR</a> and, if they are "seekable", cannot call <a class="el" href="classGlib_1_1IOChannel.html#acacb5599be21f549911c6aca5f820fcf" title="Write a string to the I/O channel. ">write()</a> after calling one of the API "read" methods.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">encoding</td><td>The encoding name, or <code>""</code> for binary. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespaceGlib.html#ga23fb251e48485b62a9c2677bb1f87d5eaf2008e64a9691fc76ad9320baef5c8ba" title="Success. ">Glib::IO_STATUS_NORMAL</a> if the encoding was successfully set. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classGlib_1_1IOChannelError.html" title="Exception class for IOChannel errors. ">Glib::IOChannelError</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab6c16c87c174d836247f47c2b87539fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> Glib::IOChannel::set_flags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#gaee093e5db5bc1ea5738771ba0d1af3b7">IOFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set flags on the <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and to integrate them wi...">IOChannel</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>Bitwise combination of the flags to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The operation result code. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classGlib_1_1IOChannelError.html" title="Exception class for IOChannel errors. ">Glib::IOChannelError</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af8f690f1e0a8945b75ad7be4949e44cf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> Glib::IOChannel::set_flags_vfunc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__glibmmEnums.html#gaee093e5db5bc1ea5738771ba0d1af3b7">IOFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000006">Deprecated:</a></b></dt><dd>Custom <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and to integrate them wi...">Glib::IOChannel</a> implementation was never really supported. </dd></dl>

<p>Reimplemented in <a class="el" href="classGlib_1_1StreamIOChannel.html#a7d7553f34d9f9eff125b17a413afc8a1">Glib::StreamIOChannel</a>.</p>

</div>
</div>
<a class="anchor" id="ad42d03bdd0288cf5517737a73f7268b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Glib::IOChannel::set_line_term </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>term</em> = <code><a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01681.html#ga32db3d9898c44d3b3a578b560f7758cc">std::string</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4c57bf6b00844fc3ddb9d0e60cac7dcf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Glib::IOChannel::unreference </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acacb5599be21f549911c6aca5f820fcf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> Glib::IOChannel::write </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGlib_1_1ustring.html">Glib::ustring</a>&amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a string to the I/O channel. </p>
<p>Note that this method does not return the number of characters written. If the channel is blocking and the returned value is <a class="el" href="namespaceGlib.html#ga23fb251e48485b62a9c2677bb1f87d5eaf2008e64a9691fc76ad9320baef5c8ba" title="Success. ">Glib::IO_STATUS_NORMAL</a>, the whole string was written. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status of the operation. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classGlib_1_1IOChannelError.html" title="Exception class for IOChannel errors. ">Glib::IOChannelError</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="classGlib_1_1ConvertError.html" title="Exception class for charset conversion errors. ">Glib::ConvertError</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a29114ed2bcb64b8af551271394968528"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> Glib::IOChannel::write </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gssize&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp;&#160;</td>
          <td class="paramname"><em>bytes_written</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a memory area of <em>count</em> bytes to the I/O channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The start of the memory area. </td></tr>
    <tr><td class="paramname">count</td><td>The number of bytes to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bytes_written</td><td>The number of bytes written to the channel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status of the operation. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classGlib_1_1IOChannelError.html" title="Exception class for IOChannel errors. ">Glib::IOChannelError</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="classGlib_1_1ConvertError.html" title="Exception class for charset conversion errors. ">Glib::ConvertError</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5e0a187ff012b3b90c6d3d8593c18e92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> Glib::IOChannel::write </td>
          <td>(</td>
          <td class="paramtype">gunichar&#160;</td>
          <td class="paramname"><em>unichar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a single UCS-4 character to the I/O channel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unichar</td><td>The character to write. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status of the operation. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classGlib_1_1IOChannelError.html" title="Exception class for IOChannel errors. ">Glib::IOChannelError</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="classGlib_1_1ConvertError.html" title="Exception class for charset conversion errors. ">Glib::ConvertError</a></td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4ed5372da9d4ad3465012fc2317507b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__glibmmEnums.html#ga23fb251e48485b62a9c2677bb1f87d5e">IOStatus</a> Glib::IOChannel::write_vfunc </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsize &amp;&#160;</td>
          <td class="paramname"><em>bytes_written</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd>Custom <a class="el" href="classGlib_1_1IOChannel.html" title="IOChannel aims to provide portable I/O support for files, pipes and sockets, and to integrate them wi...">Glib::IOChannel</a> implementation was never really supported. </dd></dl>

<p>Reimplemented in <a class="el" href="classGlib_1_1StreamIOChannel.html#aa01353b86622ec2e3a924503b1504893">Glib::StreamIOChannel</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a6683e47c0d78492b83d7021288d9b6d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GIOChannel* Glib::IOChannel::gobject_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Mar 31 2016 11:46:41 for glibmm by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
