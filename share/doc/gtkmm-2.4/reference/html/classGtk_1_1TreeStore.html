<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>gtkmm: Gtk::TreeStore Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">gtkmm&#160;<span id="projectnumber">2.24.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceGtk.html">Gtk</a> </li>
      <li class="navelem"><a class="el" href="classGtk_1_1TreeStore.html">TreeStore</a> </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#related">Related Functions</a> </div>
  <div class="headertitle">
<h1>Gtk::TreeStore Class Reference<div class="ingroups"><a class="el" href="group__TreeView.html">TreeView Classes</a></div></h1> </div>
</div>
<div class="contents">
<!-- doxytag: class="Gtk::TreeStore" --><!-- doxytag: inherits="Glib::Object,Gtk::TreeModel,Gtk::TreeSortable,Gtk::TreeDragSource,Gtk::TreeDragDest" --><div class="dynheader">
Inheritance diagram for Gtk::TreeStore:</div>
<div class="dyncontent">
<div class="center"><img src="classGtk_1_1TreeStore__inherit__graph.png" border="0" usemap="#Gtk_1_1TreeStore_inherit__map" alt="Inheritance graph"/></div>
<map name="Gtk_1_1TreeStore_inherit__map" id="Gtk_1_1TreeStore_inherit__map">
<area shape="rect" id="node2" href="file:///C:/msys/1.0/local/share/doc/glibmm-2.4/reference/html/classGlib_1_1Object.html" title="Glib::Object" alt="" coords="5,160,99,189"/><area shape="rect" id="node4" href="file:///C:/msys/1.0/local/share/doc/glibmm-2.4/reference/html/classGlib_1_1ObjectBase.html" title="Glib::ObjectBase" alt="" coords="109,83,235,112"/><area shape="rect" id="node10" href="file:///C:/msys/1.0/local/share/doc/glibmm-2.4/reference/html/classGlib_1_1Interface.html" title="Glib::Interface" alt="" coords="181,160,291,189"/><area shape="rect" id="node6" href="file:///C:/msys/1.0/local/share/doc/libsigc++-2.0/reference/html/structsigc_1_1trackable.html" title="sigc::trackable" alt="" coords="115,5,229,35"/><area shape="rect" id="node8" href="classGtk_1_1TreeModel.html" title="This class defines a generic tree interface for use by the Gtk::TreeView widget." alt="" coords="32,237,147,267"/><area shape="rect" id="node13" href="classGtk_1_1TreeSortable.html" title="Gtk::TreeSortable" alt="" coords="171,237,301,267"/><area shape="rect" id="node16" href="classGtk_1_1TreeDragSource.html" title="Gtk::TreeDragSource" alt="" coords="325,237,480,267"/><area shape="rect" id="node19" href="classGtk_1_1TreeDragDest.html" title="Gtk::TreeDragDest" alt="" coords="504,237,643,267"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Gtk::TreeStore:</div>
<div class="dyncontent">
<div class="center"><img src="classGtk_1_1TreeStore__coll__graph.png" border="0" usemap="#Gtk_1_1TreeStore_coll__map" alt="Collaboration graph"/></div>
<map name="Gtk_1_1TreeStore_coll__map" id="Gtk_1_1TreeStore_coll__map">
<area shape="rect" id="node2" href="file:///C:/msys/1.0/local/share/doc/glibmm-2.4/reference/html/classGlib_1_1Object.html" title="Glib::Object" alt="" coords="5,160,99,189"/><area shape="rect" id="node4" href="file:///C:/msys/1.0/local/share/doc/glibmm-2.4/reference/html/classGlib_1_1ObjectBase.html" title="Glib::ObjectBase" alt="" coords="109,83,235,112"/><area shape="rect" id="node10" href="file:///C:/msys/1.0/local/share/doc/glibmm-2.4/reference/html/classGlib_1_1Interface.html" title="Glib::Interface" alt="" coords="181,160,291,189"/><area shape="rect" id="node6" href="file:///C:/msys/1.0/local/share/doc/libsigc++-2.0/reference/html/structsigc_1_1trackable.html" title="sigc::trackable" alt="" coords="115,5,229,35"/><area shape="rect" id="node8" href="classGtk_1_1TreeModel.html" title="This class defines a generic tree interface for use by the Gtk::TreeView widget." alt="" coords="32,237,147,267"/><area shape="rect" id="node13" href="classGtk_1_1TreeSortable.html" title="Gtk::TreeSortable" alt="" coords="171,237,301,267"/><area shape="rect" id="node16" href="classGtk_1_1TreeDragSource.html" title="Gtk::TreeDragSource" alt="" coords="325,237,480,267"/><area shape="rect" id="node19" href="classGtk_1_1TreeDragDest.html" title="Gtk::TreeDragDest" alt="" coords="504,237,643,267"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="classGtk_1_1TreeStore-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TreeStore.html#aafa2251d7bd6b7cf5ec05d1ec4d633de">~TreeStore</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GtkTreeStore*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TreeStore.html#a1f6405d80c3b1e4a9672a69f6c13f6f6">gobj</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C GObject. <a href="#a1f6405d80c3b1e4a9672a69f6c13f6f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const GtkTreeStore*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TreeStore.html#adecedf7e9f77e9aa8e7eb44990fd8a74">gobj</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C GObject. <a href="#adecedf7e9f77e9aa8e7eb44990fd8a74"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">GtkTreeStore*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TreeStore.html#a03c99380578b846392bee1d7b6b49e52">gobj_copy</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs. <a href="#a03c99380578b846392bee1d7b6b49e52"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TreeStore.html#ae403175617926a3156d91c661e0170d4">set_column_types</a> (const <a class="el" href="classGtk_1_1TreeModelColumnRecord.html">TreeModelColumnRecord</a>&amp; columns)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGtk_1_1TreeIter.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TreeStore.html#aaf27501bd1c7f533feea94a8fa97be63">erase</a> (const <a class="el" href="classGtk_1_1TreeIter.html">iterator</a>&amp; iter)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the given row from the list store. <a href="#aaf27501bd1c7f533feea94a8fa97be63"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGtk_1_1TreeIter.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TreeStore.html#ad4545e4d3e813f53eb0387ed3fe2db2e">insert</a> (const <a class="el" href="classGtk_1_1TreeIter.html">iterator</a>&amp; iter)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new row before the position. <a href="#ad4545e4d3e813f53eb0387ed3fe2db2e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGtk_1_1TreeIter.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TreeStore.html#aafba6cb5bfad42f83b1edf6975d29aad">insert_after</a> (const <a class="el" href="classGtk_1_1TreeIter.html">iterator</a>&amp; iter)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new row after the position. <a href="#aafba6cb5bfad42f83b1edf6975d29aad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGtk_1_1TreeIter.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TreeStore.html#a66db1d0c1b1230e6e2be8f3774b8a570">prepend</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new row at the start of the top-level. <a href="#a66db1d0c1b1230e6e2be8f3774b8a570"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGtk_1_1TreeIter.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TreeStore.html#ad287ec923f9649320ce455693c920e96">prepend</a> (const <a class="el" href="classGtk_1_1TreeNodeChildren.html">TreeNodeChildren</a>&amp; node)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new row at the start of the row's children. <a href="#ad287ec923f9649320ce455693c920e96"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGtk_1_1TreeIter.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TreeStore.html#a3568029b9a2faf8a919aa5fd44661c37">append</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new row at the end of the top-level. <a href="#a3568029b9a2faf8a919aa5fd44661c37"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGtk_1_1TreeIter.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TreeStore.html#a5be56047f3d4066874b26166b1882c86">append</a> (const <a class="el" href="classGtk_1_1TreeNodeChildren.html">TreeNodeChildren</a>&amp; node)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new row at the end of the row's children. <a href="#a5be56047f3d4066874b26166b1882c86"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TreeStore.html#ac43cf2594d06cfe44eb8d84fbc250c1e">iter_swap</a> (const <a class="el" href="classGtk_1_1TreeIter.html">iterator</a>&amp; a, const <a class="el" href="classGtk_1_1TreeIter.html">iterator</a>&amp; b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps <em>a</em> and <em>b</em> in the same level of <em>tree_store</em>. <a href="#ac43cf2594d06cfe44eb8d84fbc250c1e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TreeStore.html#af1db9129be2cc296e701aa40aff7499c">move</a> (const <a class="el" href="classGtk_1_1TreeIter.html">iterator</a>&amp; source, const <a class="el" href="classGtk_1_1TreeIter.html">iterator</a>&amp; destination)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves <em>source</em> to the position at <em>destination</em>. <a href="#af1db9129be2cc296e701aa40aff7499c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TreeStore.html#abf552038fad8c3d7ecf7d70f668a0db2">reorder</a> (const <a class="el" href="classGtk_1_1TreeNodeChildren.html">TreeNodeChildren</a>&amp; node, const <a class="elRef" href="file:///C:/msys/1.0/local/share/doc/glibmm-2.4/reference/html/classGlib_1_1ArrayHandle.html">Glib::ArrayHandle</a>&lt; int &gt;&amp; new_order)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders the children of <em>node</em> to follow the order indicated by <em>new_order</em>. <a href="#abf552038fad8c3d7ecf7d70f668a0db2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TreeStore.html#a59860756eec8e5a63c0103dd947db87c">clear</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all rows from <em>tree_store</em>. <a href="#a59860756eec8e5a63c0103dd947db87c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TreeStore.html#aeee48c56b6298cd0a39b4a52d63449ba">is_ancestor</a> (const <a class="el" href="classGtk_1_1TreeIter.html">iterator</a>&amp; iter, const <a class="el" href="classGtk_1_1TreeIter.html">iterator</a>&amp; descendant) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if <em>iter</em> is an ancestor of <em>descendant</em>. <a href="#aeee48c56b6298cd0a39b4a52d63449ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TreeStore.html#ae9c345c47ad60b249e851cf839732564">iter_depth</a> (const <a class="el" href="classGtk_1_1TreeIter.html">iterator</a>&amp; iter) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the depth of <em>iter</em>. <a href="#ae9c345c47ad60b249e851cf839732564"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TreeStore.html#a1daf0f3011c00246dc3ca0d32c824d31">iter_is_valid</a> (const <a class="el" href="classGtk_1_1TreeIter.html">iterator</a>&amp; iter) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">WARNING: This function is slow. <a href="#a1daf0f3011c00246dc3ca0d32c824d31"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="elRef" href="file:///C:/msys/1.0/local/share/doc/glibmm-2.4/reference/html/classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGtk_1_1TreeStore.html">TreeStore</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TreeStore.html#a65fc563bfbef2f1a31028cd33ff228c0">create</a> (const <a class="el" href="classGtk_1_1TreeModelColumnRecord.html">TreeModelColumnRecord</a>&amp; columns)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiate a new <a class="el" href="classGtk_1_1TreeStore.html">TreeStore</a>. <a href="#a65fc563bfbef2f1a31028cd33ff228c0"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TreeStore.html#a9dd7365f0848d5a353e27a71c5727d72">TreeStore</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">When using this constructor, you must use <a class="el" href="classGtk_1_1TreeStore.html#ae403175617926a3156d91c661e0170d4">set_column_types()</a> immediately afterwards. <a href="#a9dd7365f0848d5a353e27a71c5727d72"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TreeStore.html#a01c88818f7b270651e9b22adaa929149">TreeStore</a> (const <a class="el" href="classGtk_1_1TreeModelColumnRecord.html">TreeModelColumnRecord</a>&amp; columns)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TreeStore.html#a8c4ca1e9aff504e70e2b23c164692712">set_value_impl</a> (const <a class="el" href="classGtk_1_1TreeIter.html">iterator</a>&amp; row, int column, const <a class="elRef" href="file:///C:/msys/1.0/local/share/doc/glibmm-2.4/reference/html/classGlib_1_1ValueBase.html">Glib::ValueBase</a>&amp;<a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01191.html#ga1c9e781d8d15a3814a601f471797c825">value</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Override and implement this in a derived <a class="el" href="classGtk_1_1TreeModel.html" title="This class defines a generic tree interface for use by the Gtk::TreeView widget.">TreeModel</a> class, so that Row::operator() and <a class="el" href="classGtk_1_1TreeRow.html#ae25785fc6de538f6dd632bb434a5f2ff" title="Sets the value of this column of this row.">Row::set_value()</a> work. <a href="#a8c4ca1e9aff504e70e2b23c164692712"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td colspan="2">(Note that these are not member functions.) <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="elRef" href="file:///C:/msys/1.0/local/share/doc/glibmm-2.4/reference/html/classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGtk_1_1TreeStore.html">Gtk::TreeStore</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classGtk_1_1TreeStore.html#a9d0f6eb130cef2f7fcaceacbf28d4510">wrap</a> (GtkTreeStore* object, bool take_copy=false)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="elRef" href="file:///C:/msys/1.0/local/share/doc/glibmm-2.4/reference/html/namespaceGlib.html#a671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object. <a href="#a9d0f6eb130cef2f7fcaceacbf28d4510"></a><br/></td></tr>
</table>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aafa2251d7bd6b7cf5ec05d1ec4d633de"></a><!-- doxytag: member="Gtk::TreeStore::~TreeStore" ref="aafa2251d7bd6b7cf5ec05d1ec4d633de" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual Gtk::TreeStore::~TreeStore </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9dd7365f0848d5a353e27a71c5727d72"></a><!-- doxytag: member="Gtk::TreeStore::TreeStore" ref="a9dd7365f0848d5a353e27a71c5727d72" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Gtk::TreeStore::TreeStore </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>When using this constructor, you must use <a class="el" href="classGtk_1_1TreeStore.html#ae403175617926a3156d91c661e0170d4">set_column_types()</a> immediately afterwards. </p>
<p>This can be useful when deriving from this class, with a fixed <a class="el" href="classGtk_1_1TreeModelColumnRecord.html" title="Typedefed as TreeModel::ColumnRecord.">TreeModelColumnRecord</a> that is a member of the class. There is no <a class="el" href="classGtk_1_1TreeStore.html#a65fc563bfbef2f1a31028cd33ff228c0" title="Instantiate a new TreeStore.">create()</a> method that corresponds to this constructor, because this constructor should only be used by derived classes. </p>

</div>
</div>
<a class="anchor" id="a01c88818f7b270651e9b22adaa929149"></a><!-- doxytag: member="Gtk::TreeStore::TreeStore" ref="a01c88818f7b270651e9b22adaa929149" args="(const TreeModelColumnRecord &amp;columns)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Gtk::TreeStore::TreeStore </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TreeModelColumnRecord.html">TreeModelColumnRecord</a>&amp;&#160;</td>
          <td class="paramname"><em>columns</em></td><td>)</td>
          <td><code> [explicit, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a3568029b9a2faf8a919aa5fd44661c37"></a><!-- doxytag: member="Gtk::TreeStore::append" ref="a3568029b9a2faf8a919aa5fd44661c37" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGtk_1_1TreeIter.html">iterator</a> Gtk::TreeStore::append </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new row at the end of the top-level. </p>
<p>The row will be empty - to fill in values, you need to dereference the returned iterator and use <a class="el" href="classGtk_1_1TreeRow.html#ad1880375e2c3b45a6ba69b225dd7f6a4" title="Use this to set and get the value of this column of this row.">Row::operator[]</a> or <a class="el" href="classGtk_1_1TreeRow.html#ae25785fc6de538f6dd632bb434a5f2ff" title="Sets the value of this column of this row.">Row::set_value()</a>. See also <a class="el" href="classGtk_1_1TreeStore.html#ad4545e4d3e813f53eb0387ed3fe2db2e" title="Creates a new row before the position.">insert()</a> and <a class="el" href="classGtk_1_1TreeStore.html#a66db1d0c1b1230e6e2be8f3774b8a570" title="Creates a new row at the start of the top-level.">prepend()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator to the new row. </dd></dl>

</div>
</div>
<a class="anchor" id="a5be56047f3d4066874b26166b1882c86"></a><!-- doxytag: member="Gtk::TreeStore::append" ref="a5be56047f3d4066874b26166b1882c86" args="(const TreeNodeChildren &amp;node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGtk_1_1TreeIter.html">iterator</a> Gtk::TreeStore::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TreeNodeChildren.html">TreeNodeChildren</a>&amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new row at the end of the row's children. </p>
<p>The row will be empty - to fill in values, you need to dereference the returned iterator and use <a class="el" href="classGtk_1_1TreeRow.html#ad1880375e2c3b45a6ba69b225dd7f6a4" title="Use this to set and get the value of this column of this row.">Row::operator[]</a> or <a class="el" href="classGtk_1_1TreeRow.html#ae25785fc6de538f6dd632bb434a5f2ff" title="Sets the value of this column of this row.">Row::set_value()</a>. See also <a class="el" href="classGtk_1_1TreeStore.html#ad4545e4d3e813f53eb0387ed3fe2db2e" title="Creates a new row before the position.">insert()</a> and <a class="el" href="classGtk_1_1TreeStore.html#a66db1d0c1b1230e6e2be8f3774b8a570" title="Creates a new row at the start of the top-level.">prepend()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The list of the parent row's children, as returned by Gtk::TreeModel::iterator::children(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator to the new row. </dd></dl>

</div>
</div>
<a class="anchor" id="a59860756eec8e5a63c0103dd947db87c"></a><!-- doxytag: member="Gtk::TreeStore::clear" ref="a59860756eec8e5a63c0103dd947db87c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtk::TreeStore::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes all rows from <em>tree_store</em>. </p>

</div>
</div>
<a class="anchor" id="a65fc563bfbef2f1a31028cd33ff228c0"></a><!-- doxytag: member="Gtk::TreeStore::create" ref="a65fc563bfbef2f1a31028cd33ff228c0" args="(const TreeModelColumnRecord &amp;columns)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="elRef" href="file:///C:/msys/1.0/local/share/doc/glibmm-2.4/reference/html/classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt;<a class="el" href="classGtk_1_1TreeStore.html">TreeStore</a>&gt; Gtk::TreeStore::create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TreeModelColumnRecord.html">TreeModelColumnRecord</a>&amp;&#160;</td>
          <td class="paramname"><em>columns</em></td><td>)</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Instantiate a new <a class="el" href="classGtk_1_1TreeStore.html">TreeStore</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">columns</td><td>The column types for this tree model. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The new <a class="el" href="classGtk_1_1TreeStore.html">TreeStore</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="aaf27501bd1c7f533feea94a8fa97be63"></a><!-- doxytag: member="Gtk::TreeStore::erase" ref="aaf27501bd1c7f533feea94a8fa97be63" args="(const iterator &amp;iter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGtk_1_1TreeIter.html">iterator</a> Gtk::TreeStore::erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TreeIter.html">iterator</a>&amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes the given row from the list store. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>The iterator to the row to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator to the next row, or <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01176.html#ga9390a942ee3787d3c444ebeb276d872f">end()</a> if there is none. </dd></dl>

</div>
</div>
<a class="anchor" id="adecedf7e9f77e9aa8e7eb44990fd8a74"></a><!-- doxytag: member="Gtk::TreeStore::gobj" ref="adecedf7e9f77e9aa8e7eb44990fd8a74" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const GtkTreeStore* Gtk::TreeStore::gobj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides access to the underlying C GObject. </p>

<p>Reimplemented from <a class="el" href="classGtk_1_1TreeDragDest.html#ad1b553d8d973304da419ffcafa679482">Gtk::TreeDragDest</a>.</p>

</div>
</div>
<a class="anchor" id="a1f6405d80c3b1e4a9672a69f6c13f6f6"></a><!-- doxytag: member="Gtk::TreeStore::gobj" ref="a1f6405d80c3b1e4a9672a69f6c13f6f6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GtkTreeStore* Gtk::TreeStore::gobj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides access to the underlying C GObject. </p>

<p>Reimplemented from <a class="el" href="classGtk_1_1TreeDragDest.html#a32d7775ca642898c25273907634a28b9">Gtk::TreeDragDest</a>.</p>

</div>
</div>
<a class="anchor" id="a03c99380578b846392bee1d7b6b49e52"></a><!-- doxytag: member="Gtk::TreeStore::gobj_copy" ref="a03c99380578b846392bee1d7b6b49e52" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GtkTreeStore* Gtk::TreeStore::gobj_copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides access to the underlying C instance. The caller is responsible for unrefing it. Use when directly setting fields in structs. </p>

</div>
</div>
<a class="anchor" id="ad4545e4d3e813f53eb0387ed3fe2db2e"></a><!-- doxytag: member="Gtk::TreeStore::insert" ref="ad4545e4d3e813f53eb0387ed3fe2db2e" args="(const iterator &amp;iter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGtk_1_1TreeIter.html">iterator</a> Gtk::TreeStore::insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TreeIter.html">iterator</a>&amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new row before the position. </p>
<p>If iter is <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01176.html#ga9390a942ee3787d3c444ebeb276d872f">end()</a> then a new row will be appended to the list. The row will be empty - to fill in values, you need to dereference the returned iterator and use <a class="el" href="classGtk_1_1TreeRow.html#ad1880375e2c3b45a6ba69b225dd7f6a4" title="Use this to set and get the value of this column of this row.">Row::operator[]</a> or <a class="el" href="classGtk_1_1TreeRow.html#ae25785fc6de538f6dd632bb434a5f2ff" title="Sets the value of this column of this row.">Row::set_value()</a>. See also <a class="el" href="classGtk_1_1TreeStore.html#a66db1d0c1b1230e6e2be8f3774b8a570" title="Creates a new row at the start of the top-level.">prepend()</a> and <a class="el" href="classGtk_1_1TreeStore.html#a3568029b9a2faf8a919aa5fd44661c37" title="Creates a new row at the end of the top-level.">append()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>An iterator to the row before which the new row will be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator to the new row. </dd></dl>

</div>
</div>
<a class="anchor" id="aafba6cb5bfad42f83b1edf6975d29aad"></a><!-- doxytag: member="Gtk::TreeStore::insert_after" ref="aafba6cb5bfad42f83b1edf6975d29aad" args="(const iterator &amp;iter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGtk_1_1TreeIter.html">iterator</a> Gtk::TreeStore::insert_after </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TreeIter.html">iterator</a>&amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new row after the position. </p>
<p>If iter is <a class="elRef" href="http://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01176.html#ga9390a942ee3787d3c444ebeb276d872f">end()</a> then a new row will be prepended to the list. The row will be empty - to fill in values, you need to dereference the returned iterator and use <a class="el" href="classGtk_1_1TreeRow.html#ad1880375e2c3b45a6ba69b225dd7f6a4" title="Use this to set and get the value of this column of this row.">Row::operator[]</a> or <a class="el" href="classGtk_1_1TreeRow.html#ae25785fc6de538f6dd632bb434a5f2ff" title="Sets the value of this column of this row.">Row::set_value()</a>. See also <a class="el" href="classGtk_1_1TreeStore.html#a66db1d0c1b1230e6e2be8f3774b8a570" title="Creates a new row at the start of the top-level.">prepend()</a> and <a class="el" href="classGtk_1_1TreeStore.html#a3568029b9a2faf8a919aa5fd44661c37" title="Creates a new row at the end of the top-level.">append()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>An iterator to the row after which the new row will be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator to the new row. </dd></dl>

</div>
</div>
<a class="anchor" id="aeee48c56b6298cd0a39b4a52d63449ba"></a><!-- doxytag: member="Gtk::TreeStore::is_ancestor" ref="aeee48c56b6298cd0a39b4a52d63449ba" args="(const iterator &amp;iter, const iterator &amp;descendant) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TreeStore::is_ancestor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TreeIter.html">iterator</a>&amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TreeIter.html">iterator</a>&amp;&#160;</td>
          <td class="paramname"><em>descendant</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <code>true</code> if <em>iter</em> is an ancestor of <em>descendant</em>. </p>
<p>That is, <em>iter</em> is the parent (or grandparent or great-grandparent) of <em>descendant</em>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>A valid <a class="el" href="classGtk_1_1TreeIter.html" title="A Gtk::TreeModel::iterator is a reference to a specific node on a specific model.">Gtk::TreeIter</a>. </td></tr>
    <tr><td class="paramname">descendant</td><td>A valid <a class="el" href="classGtk_1_1TreeIter.html" title="A Gtk::TreeModel::iterator is a reference to a specific node on a specific model.">Gtk::TreeIter</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code>, if <em>iter</em> is an ancestor of <em>descendant</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="ae9c345c47ad60b249e851cf839732564"></a><!-- doxytag: member="Gtk::TreeStore::iter_depth" ref="ae9c345c47ad60b249e851cf839732564" args="(const iterator &amp;iter) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Gtk::TreeStore::iter_depth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TreeIter.html">iterator</a>&amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the depth of <em>iter</em>. </p>
<p>This will be 0 for anything on the root level, 1 for anything down a level, etc. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>A valid <a class="el" href="classGtk_1_1TreeIter.html" title="A Gtk::TreeModel::iterator is a reference to a specific node on a specific model.">Gtk::TreeIter</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The depth of <em>iter</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a1daf0f3011c00246dc3ca0d32c824d31"></a><!-- doxytag: member="Gtk::TreeStore::iter_is_valid" ref="a1daf0f3011c00246dc3ca0d32c824d31" args="(const iterator &amp;iter) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Gtk::TreeStore::iter_is_valid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TreeIter.html">iterator</a>&amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>WARNING: This function is slow. </p>
<p>Only use it for debugging and/or testing purposes.</p>
<p>Checks if the given iter is a valid iter for this <a class="el" href="classGtk_1_1TreeStore.html">Gtk::TreeStore</a>.</p>
<dl class="since_2_2"><dt><b><a class="el" href="since_2_2.html#_since_2_2000109">Since gtkmm 2.2:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>A <a class="el" href="classGtk_1_1TreeIter.html" title="A Gtk::TreeModel::iterator is a reference to a specific node on a specific model.">Gtk::TreeIter</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>true</code> if the iter is valid, <code>false</code> if the iter is invalid. </dd></dl>

<p>Reimplemented from <a class="el" href="classGtk_1_1TreeModel.html#aa5c6526633d0fa8a78fd3d14d1fbd6cf">Gtk::TreeModel</a>.</p>

</div>
</div>
<a class="anchor" id="ac43cf2594d06cfe44eb8d84fbc250c1e"></a><!-- doxytag: member="Gtk::TreeStore::iter_swap" ref="ac43cf2594d06cfe44eb8d84fbc250c1e" args="(const iterator &amp;a, const iterator &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtk::TreeStore::iter_swap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TreeIter.html">iterator</a>&amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TreeIter.html">iterator</a>&amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swaps <em>a</em> and <em>b</em> in the same level of <em>tree_store</em>. </p>
<p>Note that this function only works with unsorted stores.</p>
<dl class="since_2_2"><dt><b><a class="el" href="since_2_2.html#_since_2_2000108">Since gtkmm 2.2:</a></b></dt><dd></dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>A <a class="el" href="classGtk_1_1TreeIter.html" title="A Gtk::TreeModel::iterator is a reference to a specific node on a specific model.">Gtk::TreeIter</a>. </td></tr>
    <tr><td class="paramname">b</td><td>Another <a class="el" href="classGtk_1_1TreeIter.html" title="A Gtk::TreeModel::iterator is a reference to a specific node on a specific model.">Gtk::TreeIter</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af1db9129be2cc296e701aa40aff7499c"></a><!-- doxytag: member="Gtk::TreeStore::move" ref="af1db9129be2cc296e701aa40aff7499c" args="(const iterator &amp;source, const iterator &amp;destination)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtk::TreeStore::move </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TreeIter.html">iterator</a>&amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TreeIter.html">iterator</a>&amp;&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Moves <em>source</em> to the position at <em>destination</em>. </p>
<p><em>source</em> and <em>destination</em> should be at the same level. Note that this function only works with unsorted stores. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The row that should be moved. </td></tr>
    <tr><td class="paramname">destination</td><td>The position to move to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad287ec923f9649320ce455693c920e96"></a><!-- doxytag: member="Gtk::TreeStore::prepend" ref="ad287ec923f9649320ce455693c920e96" args="(const TreeNodeChildren &amp;node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGtk_1_1TreeIter.html">iterator</a> Gtk::TreeStore::prepend </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TreeNodeChildren.html">TreeNodeChildren</a>&amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new row at the start of the row's children. </p>
<p>The row will be empty - to fill in values, you need to dereference the returned iterator and use <a class="el" href="classGtk_1_1TreeRow.html#ad1880375e2c3b45a6ba69b225dd7f6a4" title="Use this to set and get the value of this column of this row.">Row::operator[]</a> or <a class="el" href="classGtk_1_1TreeRow.html#ae25785fc6de538f6dd632bb434a5f2ff" title="Sets the value of this column of this row.">Row::set_value()</a>. See also <a class="el" href="classGtk_1_1TreeStore.html#ad4545e4d3e813f53eb0387ed3fe2db2e" title="Creates a new row before the position.">insert()</a> and <a class="el" href="classGtk_1_1TreeStore.html#a3568029b9a2faf8a919aa5fd44661c37" title="Creates a new row at the end of the top-level.">append()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The list of the parent row's children, as returned by Gtk::TreeModel::iterator::children(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator to the new row. </dd></dl>

</div>
</div>
<a class="anchor" id="a66db1d0c1b1230e6e2be8f3774b8a570"></a><!-- doxytag: member="Gtk::TreeStore::prepend" ref="a66db1d0c1b1230e6e2be8f3774b8a570" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGtk_1_1TreeIter.html">iterator</a> Gtk::TreeStore::prepend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new row at the start of the top-level. </p>
<p>The row will be empty - to fill in values, you need to dereference the returned iterator and use <a class="el" href="classGtk_1_1TreeRow.html#ad1880375e2c3b45a6ba69b225dd7f6a4" title="Use this to set and get the value of this column of this row.">Row::operator[]</a> or <a class="el" href="classGtk_1_1TreeRow.html#ae25785fc6de538f6dd632bb434a5f2ff" title="Sets the value of this column of this row.">Row::set_value()</a>. See also <a class="el" href="classGtk_1_1TreeStore.html#ad4545e4d3e813f53eb0387ed3fe2db2e" title="Creates a new row before the position.">insert()</a> and <a class="el" href="classGtk_1_1TreeStore.html#a3568029b9a2faf8a919aa5fd44661c37" title="Creates a new row at the end of the top-level.">append()</a>.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator to the new row. </dd></dl>

</div>
</div>
<a class="anchor" id="abf552038fad8c3d7ecf7d70f668a0db2"></a><!-- doxytag: member="Gtk::TreeStore::reorder" ref="abf552038fad8c3d7ecf7d70f668a0db2" args="(const TreeNodeChildren &amp;node, const Glib::ArrayHandle&lt; int &gt; &amp;new_order)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtk::TreeStore::reorder </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TreeNodeChildren.html">TreeNodeChildren</a>&amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="file:///C:/msys/1.0/local/share/doc/glibmm-2.4/reference/html/classGlib_1_1ArrayHandle.html">Glib::ArrayHandle</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reorders the children of <em>node</em> to follow the order indicated by <em>new_order</em>. </p>
<p>Note that this function only works with unsorted stores. </p>

</div>
</div>
<a class="anchor" id="ae403175617926a3156d91c661e0170d4"></a><!-- doxytag: member="Gtk::TreeStore::set_column_types" ref="ae403175617926a3156d91c661e0170d4" args="(const TreeModelColumnRecord &amp;columns)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Gtk::TreeStore::set_column_types </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TreeModelColumnRecord.html">TreeModelColumnRecord</a>&amp;&#160;</td>
          <td class="paramname"><em>columns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8c4ca1e9aff504e70e2b23c164692712"></a><!-- doxytag: member="Gtk::TreeStore::set_value_impl" ref="a8c4ca1e9aff504e70e2b23c164692712" args="(const iterator &amp;row, int column, const Glib::ValueBase &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Gtk::TreeStore::set_value_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGtk_1_1TreeIter.html">iterator</a>&amp;&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" href="file:///C:/msys/1.0/local/share/doc/glibmm-2.4/reference/html/classGlib_1_1ValueBase.html">Glib::ValueBase</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Override and implement this in a derived <a class="el" href="classGtk_1_1TreeModel.html" title="This class defines a generic tree interface for use by the Gtk::TreeView widget.">TreeModel</a> class, so that Row::operator() and <a class="el" href="classGtk_1_1TreeRow.html#ae25785fc6de538f6dd632bb434a5f2ff" title="Sets the value of this column of this row.">Row::set_value()</a> work. </p>
<p>You can probably just implement this by calling set_value_vfunc(). Your implementation of <a class="el" href="classGtk_1_1TreeStore.html#a8c4ca1e9aff504e70e2b23c164692712" title="Override and implement this in a derived TreeModel class, so that Row::operator() and Row::set_value(...">set_value_impl()</a> should also call <a class="el" href="classGtk_1_1TreeModel.html#a8f06ebb80f930bb780eab62aac748df2" title="Emits the &quot;row-changed&quot; signal on tree_model.">row_changed()</a> after changing the value. </p>

<p>Reimplemented from <a class="el" href="classGtk_1_1TreeModel.html#a26cf070eadb8e242bcf2b57f7e6d7d9e">Gtk::TreeModel</a>.</p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a9d0f6eb130cef2f7fcaceacbf28d4510"></a><!-- doxytag: member="Gtk::TreeStore::wrap" ref="a9d0f6eb130cef2f7fcaceacbf28d4510" args="(GtkTreeStore *object, bool take_copy=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" href="file:///C:/msys/1.0/local/share/doc/glibmm-2.4/reference/html/classGlib_1_1RefPtr.html">Glib::RefPtr</a>&lt; <a class="el" href="classGtk_1_1TreeStore.html">Gtk::TreeStore</a> &gt; wrap </td>
          <td>(</td>
          <td class="paramtype">GtkTreeStore *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>take_copy</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A <a class="elRef" href="file:///C:/msys/1.0/local/share/doc/glibmm-2.4/reference/html/namespaceGlib.html#a671306f4a3a0cae5ab4d7a9d54886592">Glib::wrap()</a> method for this object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>The C instance. </td></tr>
    <tr><td class="paramname">take_copy</td><td>False if the result should take ownership of the C instance. True if it should take a new copy or ref. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A C++ instance that wraps this C instance. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>gtkmm/treestore.h</li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jun 25 2013 for gtkmm by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
